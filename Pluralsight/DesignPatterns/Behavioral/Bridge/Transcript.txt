Course Overview
Hi, everyone. My name is Vladimir Khorikov, and welcome to my course about the bridge pattern in C#. The bridge pattern is one of those design patterns that a lot of people find quite difficult, and understandably so. The official definition of the bridge pattern is quite confusing. In this course, you will learn when you should apply this pattern. You will see a fully‑fledged example of the bridge pattern in a typical enterprise‑level application. We will first implement it using a naive approach, and we will then simplify it with the help of the bridge pattern. Some of the major topics that we will cover include how to handle over‑complicated class hierarchies, an alternative implementation of the bridge pattern, and why you should prefer composition over inheritance. By the end of this course, you will know everything needed to start applying the bridge pattern in your own projects. before beginning this course, you should be familiar with the C# programming language. I hope you will join me on this journey to learn about the bridge pattern in C#, here at Pluralsight.

The Bridge Design Pattern
Introduction
Hi. My name is Vladimir Khorikov, and this is the course about the bridge design pattern in C#. The bridge pattern is one of those design patterns that a lot of people find pretty difficult to grasp, and understandably so. The official definition of the bridge pattern is quite confusing. The Gang of Four, in their Design Patterns book, defined its purpose as to decouple an instruction from its implementation, so that the two can very independently. This definition is confusing because it's not obvious what the abstraction and implementation stands for. One would think that it's about things like interfaces and concrete classes that implement those interfaces, but in reality, it's not that at all. Also, a lot of examples explaining this pattern involved desktop user‑interface elements, like windows and buttons of different styles. Most people don't work on desktop UIs nowadays, and so it's hard to relate to such examples. In this course, you will see a fully‑fledged example of the bridge pattern in a typical enterprise‑level application, an online movie theater. We will take one aspect of that theater purchasing of movie licenses, and we'll see how a naive approach to modeling this aspect leads the over‑complicated code. We will then apply the bridge design pattern to simplify it. Along the way, I will provide a definition of the pattern that, in my opinion, better reflects its intent. Finally, a closer to the end of this course, I will show an alternative implementation of the bridge pattern that uses composition instead of inheritance. The source code is available in exercise files as before and after versions. You can also clone it on GitHub. Use this link to navigate to the repository. If you want to follow along with the course, roll back the repository to the commit marked as initial, that's the state of the project we have now. We will develop it from there.

Sample Application Introduction
The sample application we'll be working on is an online movie theater. It consists of just one entity, MovieLicense, which represents a movie purchased by a customer. In terms of implementation, it's a base abstract class that contains the title of the purchased movie, the time of the purchase, and two abstract methods that return the price of the license, and when this license expires. There are also two concrete classes that inherit from the MovieLicense, TwoDaysLicense and LifeLongLicense. They represent, respectively, a licence of that lasts for only two days and the license that never expires. Here's the actual code of the project. The MovieLicense‑base class with the two fields that it accepts in the constructor and two abstract methods. Note that in a real‑world project, you would probably want to use a movie class here instead of a string movie title, but for our demo project, a simple string is enough. The two concrete classes implement the abstract methods. The TwoDaysLicense costs $4, and it expires in, as you might have guessed, 2 days. On the other hand, the LifeLongLicense costs $8 and never expires. The application itself is a simple console app. Here's its program class. In it, we create one TwoDaysLicense and one LifeLongLicense, and then print their details, where we show the title of the movie, the price, and the duration this license is good for. And let me scroll down just to show you the rest of the class. If I run the application, here's how the information about these licenses is displayed. Alright, then set the current state of the project, and it's pretty straightforward. We have a small class hierarchy that models of the problem domain quite well. To best understand the bridge pattern, we need to see what challenges it helps us to overcome. For that, we we'll start introducing new requirements to our application, and we'll try to implement them using a naive approach. We will then discuss the drawbacks of that approach, and we'll see how we can refactor it using the bridge pattern.

A New Requirement: Discounts
Let's say that we received a new requirement. We need to introduce discounts to our system. There will be 2 types of discounts, a 10% military discount and the 20% senior discount, meaning that both the TwoDays and LifeLongLicenses maybe 10 or 20% cheaper, depending on the type of the discount. How can we implement this requirement? Well, one way to do so is to continue expanding our class hierarchy. We can add two more sub classes to each of the concrete classes, like you can see on this diagram. Here's how it would look in our code. Creating a class deriving from the TwoDays license, renaming it to military license, making it public, and implementing missing members, which are just the constructor here. To implement a discount, we will override the GetPrice method. We will multiply it by 0.9, which means that the price will be 10% cheaper. This class will inherit the TwoDays expiration period from the base class. That's one additional sub class of the TwoDays branch. Let's add another one. I am renaming it to SeniorTwoDaysLicense and changing the multiplayer to 0.8, which corresponds to 20% discount. And we will also do the same with a LifeLongLicense branch, creating a sub close, cold MilitaryLifeLongLicense aiding a constructor. And just like in the previous branch, I'm overriding the price to include a 10% discount. Similarly, I'm adding a senior LifeLongLicense and changing the discount to 20%. Let's make sure we did everything correctly. Let's create an instance of the MilitaryLifeLongLicense, a SeniorTwoDaysLicense, and try to print them. Running the application, and here they are. This one is a MilitaryLifeLongLicense, which is 10% cheaper than a regular LifeLongLicense. And this is a SeniorTwoDaysLicense, it's 20% cheaper than its regular analog. Alright, let's review thisthese implementation.

Recap: The Naive Approach
In the previous demo, we introduced the new Discounts feature using the naive approach by extending the older existing class hierarchy. We have added four additional classes, a military and senior variation for the TwoDaysLicense and another two variations for the LifeLongLicense. The issue with this implementation is that it leads to exponential growth of the class hierarchy. In the beginning, we had only two concrete classes. Now, after the addition of the Discounts feature, the number has increased to six. And that's just with a couple of discounts variations, military and senior. Imagine what would happen if we need to introduce five types of discounts instead of two. The number of concrete classes will rise to 12, and that with just 2 types of license, two days and lifelong. If we add just 1 more such type, the number will change from 12 to 18, and it will grow bigger and bigger with each additional variation. In other words, it will grow exponentially. Moreover, additional features will also contribute to the exponential growth. For example, let's say that we want to introduce special offers and extend the duration of our TwoDaysLicenses by an additional two days. To do this, we'll need to introduce even more classes, like the one you can see here, and they will have to inherit from all the older existing subclasses of the TwoDaysLicense. I'm showing you this class just as an example of how this feature can be implemented in our existing class hierarchy. We will not be adding all the variations of that special offer subclass. Another problem with this implementation is that we are duplicating the application's business logic. Here you can see the two variations of the military license. The knowledge of how to calculate the military discount is present in both of them, which violates the don't repeat yourself principle. The same is true for the senior licenses. The knowledge of what constitutes a senior discount is also duplicated there. So, how to fix this? This is where the bridge pattern comes into play. According to this pattern, we need to split the class hierarchy in two. Let's see how this can be done.

Applying the Bridge Pattern
To apply the bridge pattern and simplify our over‑complicated class hierarchy, we will introduce a separate class hierarchy called Discount, and we will move all discount‑related functionality to that hierarchy. Here's our sample project again. We are going to replace all these subclasses with a new class hierarchy. For that, I'm creating a new public abstract class, Discount. It will have a single abstract method, GetDiscount. Note that its return type is integer, not decimal. We will be using percentages here, and we'll later convert them into a multiplier, creating a draft class, and renaming it to NoDiscount. This will be our default option for licenses with no discounts. Hence, it returns 0 as the discount percentage. Adding another class for military discounts, implementing the GetDiscount method, its discount will be 10%. And finally, the SeniorDiscount class. Its discount is going to be 20%. And I can shorten this code a little bit by using expression‑bodied methods. This one, too, and the last one. Good. Now we will accept the base abstract Discount class in the MovieLicense constructor and save it to a private field. Let me make this field read‑only. Okay, note that we could pass a null here instead of the null Discount class for licenses without discounts. But it's better to use a null object design pattern whenever you can, so that you don't handle a special use case of a null value. The null Discount class is an example of that null object pattern. It does nothing and only serves as a stop value to satisfy the license's constructor signature. After we introduced the Discount as a separate field, we can use it when calculating the price of the license. For that, I'm creating another non‑abstract GetPrice method and renaming the abstract one to GetPriceCore. The non‑abstract method will use the abstract one behind the scenes. It will first get the discount value from the discount instance, then use it to calculate the multiplier, and then multiply the base price by that multiplier. This refactoring has broken our subclasses, so let's fix them. I'm adding a Discount instance to the constructor, and we're naming the GetPrice method to GetPriceCore. And, of course, we don't need to keep this method public, we can make it protected. Let's copy this additional parameter to the LifeLongLicense and also rename the GetPrice method and make it protected. We can now remove these two classes, and these two as well. As for this class, I'll comment it for now. We'll get back to it later in this module. And let me also shorten the implementation of the two subclasses. Using expression‑bodied methods here, too, we're good. We still have compilation errors at this time in the Program class. These two licenses should go without any discounts, so I'm creating a noDiscount instance and passing it to these two constructors. As for these two licenses, one of them should have a military discount and the other one senior. Removing the word military, passing the discount instead, and the same for the senior discount. Good. Let's run the application to make sure we didn't break anything, and you can see you that everything is fine. The third license, which has a military discount, is still 10% cheaper, and the fourth senior license still has the 20% discount. Perfect.

Recap: Applying the Bridge Pattern
Let's review what we did in the previous demo. We have split our class hierarchy in two, one containing the initial functionality with the types of movie licenses, and the other one containing the types of discounts. The split allowed us to overcome both issues with a naive implementation. Let's review what those issues were. First, our code now doesn't violate the DRY principal. All the business rules with regards to how to calculate the discounts are located in one place, which is the respective classes or the discount hierarchy. Second, we drastically simplified our code. Note that in our particular case, the number of classes remained roughly the same, five concrete classes in the new version, as opposed to six and that we had in the naive implementation. But that's just because the number of licenses and discount variations isn't that large. We currently have 2 types of licences and 3 types of discounts, which gave us 2 x 3 equals 6 concrete classes in the naive implementation. If we had, let's say, 5 types of licences and 5 types of discounts, the naive implementation would require 25 concrete classes in total, as opposed to 10 classes in the new implementation that follows the bridge pattern. And that's what this pattern is all about. It allows you to replace complexity multiplication with complexity addition, and thus bring the exponential growth of that complexity under control. In other words, it helps you to avoid complexity explosion. Complexity is a function of coupling, which is the number of connections between different aspects of your code. The larger that number, the higher the complexity. In our case, we have two such aspects, the types of licences and the types of discounts. In the naive implementation, each variation of one aspect connected to each variation of the other aspect, which resulted in the multiplication of the number of connection. During the refactoring towards the bridge pattern, we grouped all the variations of each aspect, such that they are only connected to their base class. And then we introduced another connection between the base classes themselves. What we did is we isolated these two aspects from each other and therefore achieved high cohesion among elements of each aspect and loose coupling between the aspects of themselves. We have replaced connection multiplication with connection addition. The introduction of new aspects or new variations of the existing aspects will not lead to exponential growth of complexity anymore. That's, by the way, where the name of the bridge pattern originates from. This connection between the movie license and discount‑based classes acts as a kind of bridge that links the two aspects together. I mentioned earlier that I don't like the official definition of the bridge pattern. The Gang of Four, in their book, defined its purpose as to decouple an abstraction from its implementation so that the two can vary independently. If we apply these definition to our example, the movie license‑based class becomes a abstraction, and the discount, the implementation. It's true that they can now vary independently, but these two classes have nothing to do with abstractions or implementations. They represent two aspects of our application, and each of them serves their own purpose. Neither of them is an implementation of the other. In my opinion, a better way to define the purpose of the bridge pattern is this. It is to split a class hierarchy through composition to reduce coupling. That's exactly what we did in our sample application. We have split the movie license class hierarchy into two hierarchies. We did that using composition. The movie license‑base class now contains a reference to the discount base class. The result of the split was the reduction in coupling. The movie license‑base class now couples to the discount‑base class, but the sub classes don't couple to each other anymore.

The Alternative Implementation
There is an alternative implementation of the bridge pattern. To best describe it, we need to stand back and take a look at another example. This is an Order class with two states: PaymentStatus and DeliveryStatus. The PaymentStatus can be AwaitingPayment, Paid or PaymentFailed, while DeliveryStatus can be NotShipped, Shipped or Delivered. Does this class look similar to the current version of our application? It indeed does. These two statuses also represent different aspects of the order, like the movie license and the discount in our sample project. In fact, we could also come up with a naive implementation of this Order class by combining the payment and delivery statuses into a giant enumeration, like this. As you can see, its elements now represent all possible combinations of the two statuses and exhibit the same drawbacks our naive implementation had, namely, the number of statuses will grow exponentially with addition of new payment and delivery states. This is a perfect analogy for the bridge pattern. This splitting of the status enumeration in two enumerations, like splitting of the MovieLicense class hierarchy in two hierarchies, also prevents the uncontrollable growth of complexity. The difference is that here, we deal with composition rather than inheritance. In fact, we don't need to stop with inheritance, either, in our sample project. We can refactor toward composition as well. Let's see how we can do that. We can replace this whole class hierarchy with an enumeration. Its name is also going to be Discount. The options will be None to emulate the NoDiscount class, Military and Senior, and I can comment the Discount classes. Now we need to move this logic to the MovieLicense class. For that, I'm adding a new method, GetDiscount. It will go through all possible types of discounts and return us the appropriate number. Generating the cases is going to be 0 for None, 10 for Military and 20 for Senior. Also, the latest version of C# has a nice feature where we can transform switch statements into switch expressions. Much better. And using this method in place of the method from the Discount class. That was a good first step, but we don't have to stop here either. We can transform the MovieLicense class hierarchy into an enumeration as well. Look at these two subclasses. They are essentially the types of the movie licenses that are available in our application, and we can represent them as such with a new license type enumeration. There will be two options here: TwoDays and Lifelong. We now need to inject this enumeration into the MovieLicense's constructor, like we did with the Discount, saving it to a private field and making it read only. Good. After we introduced this new enumeration, we can move this logic to the MovieLicense class as well. For that, we'll re‑purpose these two abstract methods. I'm making the GetPriceCore method private, and depending on the license type, the method will either return the price of $4 if it's a two days license or $8 if it's lifelong and throw in an exception if we cannot recognize the type. This is a good approach because it allows us to fail fast if we add a new license type and forget to process it. And let me rename this method to GetBasePrice, meaning a price without discounts. We'll do the same for the GetExpirationDate, copying the switch expression, the TwoDays license, and LifeLong. Now we can comment these subclasses. We don't need them anymore. Let's fix all the compilation errors we got as a result of our refactoring. There's no Discount class anymore. Instead, we should use the new enumeration. There is no TwoDays license class, either. I'm replacing it with the MovieLicense class and the class type enumeration. And, of course, there is a compilation error because I forgot to make this class non abstract and make its constructor public. Now it compiles good. Doing the same for the LifeLong license, noDiscount and the LicenseType. Removing these two discounts, changing the type, the discount. Good. And finally, the last one. Let's run the application to make sure everything is still working, and you can see that it indeed is. The military lifelong license is still 10% cheaper than the same license without the discount, and the senior license is still 20% cheaper. One last thing. For some reason, ReSharper reports a compilation error here, even though there is no compilation errors, in fact. Let me fix this by explicitly converting the DateTime result into a nullable DateTime. Good. And we can now remove all these subclasses. Perfect. Let's review what we've done here.

Recap: The Alternative Implementation
In the previous demo, we replaced the two class hierarchies with two enumerations and moved all the business logic from those hierarchies into the MovieLicenseBase class. This is essentially an alternative implementation of the bridge pattern. One could argue that it's not a bridge pattern anymore, which is debatable. But even if so, it's a natural extension of the bridge pattern. There is an important guideline. You should prefer composition over inheritance, and that's exactly what we did. We moved away from inheritance to composition. The reason why you should favor composition over inheritance is because it's more flexible. It's easier to modify when needed. With composition, it's easier to change behavior on the fly by injecting different parts of that behavior into the movie license. Inheritance is more rigid because most languages do not allow you to derive from more than one type. Moreover, composition is easier to understand because it's more natural to see various components of domain classes at a glance than to try to make sense of the class hierarchy. Of course, sometimes inheritance is more appropriate than composition, but in most cases, such as the one I showed in the sample project, composition works better.

New Requirement: Special Offers
And just to illustrate how easily extendable this solution with composition is let's introduce back this requirement that we briefly looked at at the beginning of this module, special offers. This is the class and that provided that functionality for us. It added two days on top of any ExpirationDate that is not null. This is going to be another enumeration. I'm calling it SpecialOffer. It can be either none or TwoDaysExtension. To introduce this requirement, we need to just inject it into the movie license, like the other two enumerations. Saving it to a private field, and let me move down a bit. Good. Now, to take into account the SpecialOffer field, we need to modify this ExpirationDate method. I'm extracting the existing code to private method that I'm calling GetBaseExpirationDate and introducing another method that would return the SpecialOffer extension. Here, depending on the SpecialOffer field, either returning no extension or TwoDaysExtension, and throwing an exception if the enum value is unknown. Now saving the BaseExpirationDate to a variable, getting the extension, and returning the based date plus that extension as the resulting ExpirationDate. This modification has broken our program class. Let me add a default value here just so that I don't have to fix all the existing licences. Good. It fixed the completion errors. Adding a new license, the TwoDaysExtension, and printing that license. Let's run the application. Very good, here it is, our new license. It's the same as the previous one, but instead of two days, it has the total of four days in it. I can now go to the command.code and delete it. Perfect.

Summary
In the previous demo, you saw how easy it is to extend the solution that uses composition instead of inheritance. All we needed to do to introduce the new special offers functionality is add a new enumeration and inject it to the MovieLicense class, along with everything else. Moreover, our code has remained simple and easy to understand. These three enumerations, LicenseType, Discount, and SpecialOffer, represent three different aspects of the MovieLicense domain class. You can view them as three dimensions that are loosely coupled with each other. We could go even further and use the enumeration pattern instead of the plane enum values, but that's outside the scope of this course. Alright, let's review what you have learned in this course. The Gang of Four, in their Design Patterns book, defined the purpose of the bridge pattern as to decouple an abstraction from its implementation, so that the two can vary independently. But I think a better way to define it would be as to split a class hierarchy through composition to reduce coupling. That's exactly what the bridge pattern is four. It allows you to split an over‑complicated class hierarchy into two or more smaller, loosely‑coupled hierarchies that are easier to understand and maintain. It's a way to prevent the combinatorial explosion of the number of classes in the ever‑growing class hierarchy. But you don't have to stop there either. You can reduce code complexity even further by switching from inheritance to composition. The composition will also help you to make your code more flexible. Be sure to subscribe to my blog where I will be posting announcements about future courses. This is the short link for you to do so. Also, here are my Twitter handler and blog. This is Vladimir Khorikov. Thank you for listening.