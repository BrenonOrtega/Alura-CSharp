Course Overview
(Music) Hi everyone. My name is Filip Ekberg, and welcome to my C# Design Patterns course, covering the Chain of Responsibility pattern. I'm a principal consultant and CEO at a consultant agency operating out of Gothenburg in Sweden. I started this company a few years ago, focusing on building fast, powerful, and easy-to-maintain solutions. This course is for those of you that want to learn how the chain of responsibility pattern works and how to implement that in your C# applications. We will cover everything that you need to know to master this pattern. This includes what the chain of responsibility pattern is and its characteristics, understanding the benefits and tradeoffs when using the chain of responsibility pattern, how to implement the chain of responsibility pattern in new and existing solutions, as well as identifying and leveraging existing implementations. By the end of this course, you will feel comfortable with implementing the chain of responsibility pattern in your applications. This will allow you to build extensible, more robust, and testable applications. Before beginning the course, you should be familiar with the C# syntax and how to build and run .NET applications. No other prior knowledge is necessary. I hope you'll join me on this journey to learn all about working with this very powerful C# design pattern, with the Chain of Responsibility Pattern course, here at Pluralsight.

Chain of Responsibility Pattern
Introduction
Welcome to a C# Design Patterns course. My name is Filip Ekberg, and I will guide you through understanding the chain of responsibility pattern. This behavioral design pattern will drastically change the way that you build software, so stay tuned for learning all about this amazing pattern, which you will most definitely be able to leverage in any type of application that you're building. The primary goal of this course is for you to understand and learn how you can implement the chain of responsibility pattern in your applications. You will then be able to identify and leverage existing implementations of this pattern in different types of applications. You will most definitely find situations in your applications where this pattern has been applied, although you might have not known that this has been the chain of responsibility pattern. And as with any design pattern, it comes with benefits and tradeoffs. And after watching this course, you will know when it's appropriate and not to apply the chain of responsibility pattern in your applications. This pattern can most definitely be applied in any different type of application, and throughout the course we'll be looking at different situations of how we can apply this pattern. Before we look at the particular implementation details for this pattern, we need to talk about the characteristics. The chain of responsibility pattern is commonly identified by these three different things. We have a sender, which invokes something in the application, so we have a handler that runs through a chain of receivers, and the receiver itself can be something that handles that given command. And of course, this sounds very much like a standard process when we're building applications. If we translate this into something that we could be using in our applications, imagine the situation where we have a logger. The sender, which can be anything in our applications, calls Logger.Log. This invokes our handler, and the handler that we communicate with will have a list of concrete implementations of loggers. The chain of responsibility pattern allows us to execute one or many of the different handlers that we are appending to our chain of handlers. The receiver itself can be something like a console logger, a file logger or a database logger. The receiver contains the logic to decide if it should act upon the request or not. The handler will make sure that each receiver gets the request passed into it. The receiver then decides if it should act on that given request or not. Even though the request might not be processed by that particular receiver, the request will still be passed along the chain to the next receiver in line. So what's interesting with this architecture is that the sender doesn't have to know about the concrete implementation, and we can easily now extend our chain of loggers with more ways to handle how we want to log our messages. The sender often invokes this handler with a request. The request object contains all of the information that the handlers need in order for it to complete. With the file logger, that could be the message, as well as the logger severity. Then the logger takes care of invoking one or many of the handlers that we have in our chain of responsibility. So the chain of responsibility pattern is a very powerful, yet pretty simple pattern to implement in our applications. It boils down to allowing us to decouple our applications to make it more extensible and maintainable.

Chain of Responsibility: First Look
Let's now have a first look at how the chain of responsibility pattern can be applied in one of our applications. We are now inside Visual Studio. This particular application is a simple console application. That's because for the purpose of the demos, I want to keep them simple so it's easier for you to follow along when we change the application to apply the chain of responsibility pattern. So let's have a look at the main entry point of the application. This very simple application will allow us to process one of the users that we want to register in our system. We first of all will set up a new user. The user has a name, a social security number, the region of where this user is a citizen, and then finally we have a date of birth for that particular person. When we register a user in the system, I want to be able to validate that the user has met a few different criteria. So let's head in to our user processor and have a look at how we validate our current user. You'll see here that inside our user processor we have a social security number validator, and then inside our Register method, we validate the social security number. This is of course dependent on where the user is a citizen, because different countries and different regions have different types of social security numbers. And then we want to validate that the user is over 18 years, and then we want to validate the length of the name. The system that I'm building here doesn't support the Norwegian region, but even though I personally love Norwegians, I'm sorry my friends, but in this application if you have a citizenship in Norway, you won't be able to register for this system. So even though that this method here looks fairly simple, there's quite a few things happening in here, and this method here becomes a little bit fragile. So in order for us to take a little bit more of an object-oriented approach, we want to refactor this and apply the chain of responsibility pattern. The chain of responsibility pattern is a way for us to pretty much change the if, else if, and else idiom to a more object-oriented manner. So the first thing that we want to do is that we look at each of the different conditions and we break that out to a particular handler for that particular case. So in this case we'll have a handler that allows us to validate that our social security number is correct, we'll validate our age, we'll validate the name, and then we'll validate the region. So what we'll end up doing is that each of these different conditions will have its own hander. The handler will be in charge of validating that particular condition, and then call the next handler. If one of the handlers in the chain reaches a point of where it fails, it can either return a value or throw an exception. To do this, we'll simply add a few handlers to our applications, which will allow us to run through a chain of validation to allow us to check if the user can be registered or not. I'm going to add a new folder inside the business layer of my application and call it Handler. We will now then proceed to increase the way that we build our chain of handlers. The handler will implement this particular interface. We have an IHandler of T where T has to be a reference type. We can append more handlers to this particular handler, which will allow us to set up a chain of handlers. And then of course we will be able to handle this particular request. The interface here describes that we can now append handlers to each other, and then when we call Handle, what will happen is that the particular handler will run some logic and then invoke the next handler in line. So let's create the first abstract implementation of our handler. So the idea here now is that when we call Handle, it will run some logic and then it will execute the next handler in line. But the abstract handler doesn't have any logic to it, so it will only execute the next handler in the chain of responsibility. So how do we know what thing to execute next? Well, we need to introduce the next handler to execute. So now what happens here is that our abstract handler will simply execute the next handler in line. If we have a next handler, it will simply pass on the request to that particular handler. So when we create the concrete implementations of our handlers, that's when we will be using the request object to validate some particular data before calling the next handler in line. In order for us to be able to change the behavior of Handle in one of the subclasses, we also need to mark this as virtual. And then in SetNext, of course, what we're going to do here is set our next handler to whatever we pass into SetNext, and then we'll simply return next from this particular method. This will allow us to very fluently write a chain of handlers in our application. So now we have this abstract way of defining one of the handlers for our conditions. So now we want to create a handler that validates, for instance, the social security number, and if the social security number is correct, we can then proceed to execute the next handler in line. So let's go ahead and add some user validation handlers. I'll proceed to add a new folder to group my user validation handlers in. We will now add a handler for our social security number validation. Our SocialSecurityNumberValidatorHandler will inherit from our abstract implementation of a handler, and the particular request object that we are working with is a user. So now what happens here is that we can override our handle method to allow us to validate that our user has a correct social security number. Inside our handle method that we are now overriding, we now see that we get the user as a request. We get a request to handle one of our users. And in order for us to validate the social security number, we need our SocialSecurityNumberValidator. And if the social security number cannot be validated, we are going to throw an exception. So this handler will now be in charge of validating our social security number. When we get the request to handle this particular user, we will use the SocialSecurityNumberValidator, which is only existing inside this particular handler to validate that. If this validation fails, we can throw a business exception, which in this case is a UserValidationException. If we now manage to validate this social security number, we will proceed to the next handler. So this will now call base.Handle to then run the code inside our abstract handler, which will, in its turn, simply call the next handler. An alternative approach would be to have a non-abstract base handler which would be in charge of executing and visiting all of the different handlers that you've registered. In this scenario here, we can simply break the chain by discarding the call to base.Handle. Of course, we could call base.Handle in the top of the method, but it really depends on how you want to proceed. Do you want to run this last or first in the chain of handlers? So let's proceed to add handlers for the other different types of criteria for a particular user. We have an AgeValidationHandler that will now allow us to validate that the user is older than 18 years old. If the user is younger than 18 years, we're going to throw an exception. We're also going to have a NameValidationHandler, which will allow us to validate our name and tell us that if your name is only one character, your name is unlikely short, and I'm really sorry, my Norwegian friends, I didn't forget about the CitizenRegionValidatorHandler. So we now need to validate that the users that are trying to register in our system are not Norwegian. So now that we have the different user validations, we have a user validation for age, citizenship, name, and then social security number. How do we proceed to leverage these different handlers?

Chain of Responsibility: A Chain of Handlers
Let's go ahead and go to our user processor. Remember, the user processor is where we had this chain of if and else if and else blocks, and we want to refactor this to now leverage our new chain of handlers. We're just leveraging the chain of responsibility pattern. So let's simply get rid of all of this code, and the user processor now no longer has to know about the social security number validator. We will start off by creating our first handler. We've now created our SocialSecurityNumberValidatorHandler. And what we can do now is to very simply say that we want to append more handlers. So we can say that we want to set the next handler that handles a user, all it needs to do is to implement the IHandler of User interface. We can SetNext here to be the age validator, the name validator, as well as the citizen region validator. We've now created a chain of handlers, and in order for us to start invoking this chain, all that we need to do is to call handler.Handle, and we will pass the request that we want to handle, which in this case is our user. Remember, this will throw an exception if we couldn't validate our user. So let's simply wrap this in a try/catch block. So we've now refactored the code inside our user processor. What we achieved here is that the user processor now no longer has to know about the particular implementation details of how to validate our social security number, it doesn't need to know about the age validation, the name validation or the citizenship validation. What's also interesting here is that if we decide to remove the name validator, we can very simply just remove this handler and our code is now very much easier to maintain and write our tests for. We can make sure that we write unit tests for our particular handlers, and since they all have a single responsibility, it makes it so much easier for us to make sure that we have great code coverage. So now of course whoever is using the user processor still has the same approach, we only changed the implementation of our Register method, which in this case is our sender. We then have the handler, which is talking to our different types of receivers. So now if we step through the code here, we can see that we start off by running through our SocialSecurityNumberValidator. We then proceed to run the next handler inside our chain of handlers, which is our AgeValidationHandler. When the age is validated, we proceed to run the base class, Handle, which will then run the next in line, which will be validating our name. When the name is validated, of course we do the same thing by running Handle and then we run the CitizenRegionValidationHandler. We will then return up the chain to whoever called our chain of responsibilities. Then we return back to whoever is calling the method and our code is now more extensible, it's much more testable, and we make sure that we have an object-oriented approach to this if, else if, and else idiom. So exactly what did we achieve by changing this to using and leveraging the chain or responsibility pattern? We have now achieved a more extensible, object-oriented, and dynamic implementation. We can easily rearrange in what order the handlers operate. If validating the social security number is an expensive approach, it could be that it has to communicate with an external API. In Sweden, for instance, we have APIs that can validate the social security number, but they cost money to communicate with. So if we can get rid of a few different calls to that API by first validating the age, name, and citizenship, then maybe we could reduce the amount of calls to that particular API, and making this reorder is much more simple when we are applying the chain of responsibility pattern than restructuring the if and else if and else blocks. That not only feels more dangerous, it's also harder to test that single responsibility once coupled with other things. And of course, this is a much more cleaner approach with a single responsibility in mind when we are building these different methods. So decouple your code and achieve cleaner and a more extensible code base, although we did have to add a little bit more code in order for us to achieve this same thing as we did with our if, else if, and else idiom. But then again, this is an object-oriented approach, which will allow us to write more testable, maintainable, and clean code, and that is worth a whole lot when building software.

Example: Payment Processing
Let's now look at another example. I want to build a payment processing system. In this payment processing system, we have this idea of allowing us to pay our order using different payment systems. We could even extend this to allow us to do partial payments. Imagine that I can either pay with PayPal, invoice or credit card, or even in the future I could pay 50% using PayPal and then get 50% invoiced at any given time. In this case here, we iterate over all the different selected payments on our particular order, and then if the payment provider that we are currently handling is PayPal, invoice or credit card, we do certain different things. And now of course whenever you see if, else if, and an else block, you know that we can refactor this into leveraging the chain of responsibility pattern. So, of course, we're going to do exactly that. Our payment processing will now leverage the chain of responsibility pattern. Imagine that we are now receiving a completed purchase command or an event, depending on the type of application that we're building, and then we want to handle this. So we have a payment handler, which then has a chain of concrete implementations of these different payment handlers. In the previous demo we looked at, our abstract handler simply called the next handler in line, but this particular abstract implementation of a payment handler can do more things. We can, for instance, check if there's an amount due before invoking our particular payment provider, and then of course when the payment provider has completed its execution, we can call the next payment provider in line if there's still an amount due. If we have an amount due after there's no longer any payment providers in line, we're going to get a big exception telling us that you should probably go ahead and redo this order because the user didn't pay for the items. So we are now inside Visual Studio again, and we are looking at a console application. Remember, this could be any different type of application. Of course, the application doesn't even have to be C#. This pattern is applicable in any type of application, so now we want to build some payment processing. Add a business layer in my application. The business layer contains a few different payment processors. We have a CreditCardPaymentProcessor, an InvoicePaymentProcessor, and a PaypalPaymentProcessor. They all share this common interface. They allow us to finalize the payment of a particular order. So this is after the user has seen the PayPal screen or whenever the user has placed their order. This system only takes care of finalizing the payment for that particular request. So for instance, the InvoicePaymentProcessor could be in charge of creating the invoice and emailing that over to our particular user, although this course isn't in particular about building payment processors, and there's quite a few things that we could ask out of this code here. There's a lot of details missing in the implementation of creating the invoice and validating all of the things. But this is just a basic template of how we now are going to communicate with our system. When we finalize the order, if we are running through a payment processor and the invoice can be paid with that particular processor, we are going to append that as a finalized payment on that particular order. So, the way that we want to leverage this is by introducing a chain of responsibility. Looking at our program, what we're doing here is we are creating an order with two items. I am purchasing an Atomos Ninja V, as well as a Canon EOS R. I then proceed to add a PayPal payment of $1000, and then an invoice payment of $1797. And then what we do here is that we simply print the amount due and the shipping status, and then we do the same thing after we've handled the payment. Of course running this now, it tells us that the total amount due is $2797, and it's still waiting for payment. So we need to go ahead and implement the payment, and to do that we want to introduce the chain of responsibility pattern. I've gone ahead and added this folder called Handlers. I have the same interface for our IHandler of T where we are now capable of setting the next handler in our chain, as well as handling that particular request. Then I have my abstract PaymentHandler, which is a simple IHandler of an Order. Now we need to define the abstract way of handling a particular order. I mentioned earlier that one of the things that we need to do is validate that in case there are no more handlers to execute, which means that next is equal to null, and there's an amount due under the order, we probably have an exception that we want to throw back to the user. We also then potentially want to roll back the previous payments, but that's something that you can play around with yourself after watching this course. So let's go ahead and implement handle for our abstract PaymentHandler. So in the case of there being no more handlers to execute and we still have something to pay, we want to throw an exception. The next thing that we want to do is to check if there is still something that we need to pay on the order. So then if we still have something to pay and there is someone next in line, we can call that handler as well, although if there's nothing left to pay, we don't really have to call the next handler in line, we can simply change the status of our order. Of course, in a real-world scenario you would probably not change the shipping status on the order in this particular manner, you would probably add a record in your database to say that the status of the order has now changed so that someone else can take care of that. But for demo purposes and to keeping this very simple, this is what our abstract PaymentHandler is now doing. We can do this particular validation to check that we have a next handler, we can check if we still have an amount due and then call the next handler, otherwise we could tell the system that it's now ready for shipment. So now we have the abstract handler for how a payment should be processed. So what we now need to do is to introduce the concrete payment handlers. And I've prepared three different handlers. we have the PaypalHandler, the InvoiceHandler, and our CreditCardHandler. So let's go ahead and create the implementations for one of them, and then the others are fairly similar. The PaypalHandler will know how it processes the PayPal payment. It will know about the payment processor, it will inside handle make sure that we have a selected payment provider of PayPal on the order's selected payments. It will then leverage that particular PayPal payment processor to finalize our order, and then it will go ahead and call base.Handle. So now we have our PaypalHandler implemented. The code for the rest of them is fairly similar. The InvoiceHandler is no different. We have our InvoicePaymentProcessor, we check that we've selected an invoice as a part of our payment. We then proceed to call Finalize on our InvoicePaymentProcessor, and then go ahead and proceed and call the next one in line. And of course you might have guessed it. In this case here, the CreditCardHandler is pretty much the same implementation. The particular way that we handle the payments in this case here doesn't really matter. The important part here is that you get an understanding of the chain of responsibility. The way that we first tried to process the the request by introducing one handler, and then as we proceed to the next handler if we still have money to pay, it might run that handler as well. So now let's see how we can leverage this payment handler to pay for our particular order. We'll start off by creating our PaypalHandler because we need to create an instance of one of our concrete handlers to allow us to then append more handlers to it. So this here now created our PaypalHandler, we then set the next handler to be the CreditCardHandler, and then finally the last handler that can potentially handle your payment is the InvoiceHandler. And then, all that we need to do is to say that we want to handle our particular order. And now as we run the application, you'll notice here that we still have an amount due to pay. So for some reason, what happened here is that we didn't get our order paid in full. So let's have a look at the selected payments. We can see here that we are saying that we want to pay by both PayPal, as well as pay by invoice. The amounts that we have here add up to what we need to pay in the application, so how come it didn't invoke our invoice payment handler? If we have a look at the particular implementation, I did leave a bug in here. What I did here was that I returned from the handler if the order didn't have that particular payment selected. So this here is an interesting bug. This means that we broke off the chain, we returned back up the chain without proceeding to running the next one in line. So that's a little bit problematic. So instead what we need to do is that we need to change our handlers and only finalize the order if we have that particular payment selected. So why did I add this bug in the application? Well, it illustrates that you really need to make sure that you run the next handler in line, otherwise you might end up having issues in your applications that you might not have anticipated. Because in this case here, we didn't get an exception that the order wasn't paid in full, and it didn't proceed to run the next payment handlers in line. So let's go ahead and fix this in all of our different handlers, and then proceed to run the application again. And now as we run the application, we can see that we are no longer waiting for payment, but it did run through the entire chain of our handlers. It ended up running the invoice handler last, which reduced the amount to be paid to 0 and changed the status to ReadyForShipment. I proceeded into the payment handler and added this line here, which will tell us which payment handler it's currently executing. So if we run this again, we'll see here that it starts off running the PaypalHandler. It then runs the CreditCardHandler and then runs the InvoiceHandler, and then the amount due is reduced to 0. So this here illustrated how we very simply introduced a way for us to more easily express the way that we want to be able to process payments for an order. We can add more ways for us to pay an order. Imagine allowing us to introduce a bank transfer or cash payment, or other things like that. This makes the whole process of introducing new ways of handling a particular request much more simple than it would be if we looked back at the way that we solved this before. The way that we solved this by using the chain of responsibility pattern is much more convenient and allows us to create more extensible, maintainable, readable, and dynamic code. So again, we saw a great benefit of increasing the chain of responsibility pattern. Of course, by now you've probably identified one of the drawbacks of leveraging the chain of responsibility pattern. It does introduce a little bit more code. The code can be a little bit harder to debug, but it makes it so much easier for you write tests for it, it makes the code that you are building more extensible and dynamic, which means that you'll end up having a much better experience building your applications.

Example: Improving the Payment Processor
Let's now have a look at how we can improve our implementation of the chain of responsibility pattern. There are multiple different ways that we can go by implementing this pattern in our applications. We've been looking at one example of how to do this, now let's improve our payment processing to tweak our implementation a little bit. We're inside Visual Studio, and we are now looking at our abstract PaymentHandler. What we've done so far is having our receiver and handler being the same thing. What we want to do now is to separate the receiver and the handler and make sure that we have a payment handler that can have a list of our different receivers. Now that I've refactored the payment handler, instead of it being a linked list of IHandlers, we now have a list of receivers that takes care of processing our request, which in this case is going to be an order. In the constructor of our payment handler, we can take a list of receivers that this particular handler is taking care of. We can still have a SetNext method, which allows us to add more receivers to our list of handlers that could potentially handle our given request. Now the way that we process this chain of receivers is of course in the method handle. This now looks a little bit different from what we saw earlier. We still handle a given request, which in this case, of course, is still the order. In order for us to process the chain of receivers, we iterate over each receiver. We have the same check that we had earlier to check if we still have an amount due. If you do have an amount due, we pass the order down to that particular receiver to handle our request. The receiver can then of course decide if it should act or not on our given request. If we don't have an amount due in this case here, we're simply going to break out of the chain, and finally in our handler we're going to check if there's still an amount due after we've processed the entire chain. If we still have an amount to be paid, we're going to throw the same exception that we did earlier, otherwise we're going to mark our order as being ready for shipment. Now the interesting part here is that our concrete implementations of our handlers, which are now going to be our receivers, no longer have to inherit from this payment handler. So we've separated the handler from our receiver, and this of course means that each receiver is not in charge of making sure that we run the next receiver in line. The handler is now in charge of making sure that the request is passed down to each receiver, the receiver can then decide if it needs to act on this particular request or not. So how do we change our previously concrete implementations of the handlers to being an implementation of an IReceiver? The IReceiver interface is pretty much the same thing as our IHandler, although what we don't have here is our SetNext method. So now let's go ahead and implement this interface and change our concrete implementations of our previous handlers to implement this interface instead. We'll start off by refactoring our PaypalHandler. Instead of inheriting from our PaymentHandler, we're now going to implement the interface IReceiver of T. This means that we no longer need to override a method inside a base class because we are no longer inheriting from an abstract class. This also means that we don't have to call the base class in order to continue processing the chain. What's really interesting here is that our receiver no longer has to know that it's being executed through a chain of responsibility pattern. This makes our receiver even more separated than what we had previously. And once again, I want you to note here that even though we passed the request down to this particular handler, it doesn't have to act on its given request. A handler can act on a given request if it wants to or not. One or more handlers in the chain could decide to act on a given request. And in this case here, we only act on our particular request if we have a selected payment provider of PayPal on our order. The request will then go on in the chain and each handler that wants to process this request can do so accordingly. So let's do the same change to all of the different receivers. Let's now go ahead and go into our program where we previously used our concrete implementations of our handlers. The way that we now build up the chain of receivers and run them through our handler is by first creating our PaymentHandler. The PaymentHandler can take a list of receivers in the constructor, but we could also call SetNext in order for us to append more receivers if we so like to. Our PaymentHandler now has the capability of running a PayPal, Invoice, as well as a CreditCardHandler. They're passed into the constructor when we are creating our PaymentHandler, and then we can call handler.Handle in order for this to process this request and pass it down to each handler for each handler, or also known as the receiver, to act on this given request if you'd so like to. If we run the application, we see that we get the same result as we did earlier. It runs through our chain, processes the request using the receivers, and then when the process has completed, one or more of these different handlers acted on our given request and the order value left to be paid is now 0 and we can now shape our order to our customers. So the way that we refactored our payment handler, we now separated our receivers from our handler. Our handler now has a list of receivers, which it can use to process our given request. The PaymentHandler doesn't know anything about the concrete implementations of any of our different receivers, and our receivers, which in this case handles our PayPal payment, doesn't have to know that it's being executed through a chain of responsibility pattern. It no longer has to call base.Handle in order for it to continue processing the chain. If we want to break out of the chain, we can simply throw an exception in one of these handle methods, that'll bubble up to whoever is then executing our payment handler. So this here gives you an alternative approach to implementing the chain of responsibility pattern. We now separated our concerns even more than we had earlier, and our application just got a little bit better.

Existing Implementations: ILogger
Let's have a look at an existing implementation of the chain of responsibility pattern. A very common situation where this pattern is applicable is for a logger. So let's jump into Visual Studio and have a look at this ASP.NET Core application. We're inside our program where we are creating our host builder. This allows us to configure, for instance, things like our logging. We can proceed to say that we want to clear out all the registered logging providers and then start to append logging providers that we want to leverage in our application. You can see here that we can add console logging, we can add debug logging, which will write the logs out to our debug window, we can add event logs, which will add the logs depending on the severity to our Windows event log, and then of course if we use external logging providers, we can also introduce things like database logging or to various other types of systems that allows us to build powerful logging systems. So this here leverages the chain of responsibility pattern. In this case here, we are simply saying that we want to add a console logger, a debug logger, as well as logging to our event log. What happens now is that whenever we call logger.Log inside the application, it will now proceed to add this to our console, to debug, as well as adding this to our event log. So even though we might not know that this is leveraging the chain of responsibility pattern, internally this is built up by a list of loggers. If we are using the pattern that we did in our earlier demos where we were simply appending a next object to our chain of loggers, you could implement the chain of responsibility pattern in multiple different ways. The way that they've decided to build this using the loggers in .NET is by having a list of loggers. You can, of course, do it the way that we did it earlier in the demos where we apply a next handler to each handler itself, but in this case here they leverage a simple list of loggers and they iterate over this list to run one or many of these different handlers. So even though you might not have known that this is the chain of responsibility pattern, it's applied in a whole lot of different places to allow us to write much more extensible and sensible code.

Existing Implementations: ASP.NET Core Processing Chain
Another place where the chain of responsibility pattern is applied is inside the ASP.NET Core processing chain, also known as the middlewares. The ASP.NET Core middlewares allows us to chain middlewares together to allow us to handle certain different types of scenarios. This image here is taken from the Microsoft documents, and it illustrates how our first middleware might get a request, it does some processing or logic on that particular request, and then calls the next middleware in line, which in its turn has some logic and then calls another one, and then at the end returns back the chain, and then whoever's invoking the first middleware can then go ahead and take care of the response of all of this aggregation of whatever the middleware is put together, and return that back to the caller. And again, we're inside Visual Studio and we're looking at an ASP.NET Core application. If we scroll down to Configure here, we can see that we are using our application builder. Normally what you see in here is things like app.UseHttps, UseRouting, UseAuthorization, UseEndpoints, and so forth. There's a lot of different things that we can use with our application builder. But what I'm doing here is that I'm setting up three different middlewares. We're simply saying that I want to use this thing here that allows me to leverage the context and then also has a reference to the next handler. So just to illustrate how this works, I'm running the first handler, then I'm running the second handler, and then I'm running the third handler, and after each is done, we're going to go and proceed and add something back to the console to say that that particular middleware is done. As I run this here and call the endpoint that is hosting this ASP.NET Core website on, you'll see that it first runs the first handler, second one, third one, and then it's done with the third one, done with the second one, and then done with the first one. So this here executed a chain of different middlewares inside my ASP.NET Core application. So this illustrates how it's now leveraging the chain of responsibility pattern inside ASP.NET Core. And if you're building middlewares and if you're leveraging anything inside ASP.NET Core, at one point or another it is leveraging the chain of responsibility pattern. So again, you might not have known that this is the particular pattern, but it's a very powerful pattern and it's commonly applied in a lot of different types of applications.

Summary and Final Words
So throughout this course, we discovered the chain of responsibility pattern. We saw how we can easily change our application to make it more testable, maintainable, and honestly, more fun to work with. It decouples the sender and the receiver so we no longer had to know about the particular implementation details inside our particular sender or application to, for instance, finalize the payment in PayPal. I only need to know about the chain of handlers, but then how they are implemented and what kind of logic they are running through, I don't have to care about that at all. And what's interesting is that saw that one or many handlers can act on a given request. We saw how we can split up payments using different payment providers and allowing the users to pay for an order using PayPal or an invoice. We also saw we can leverage the built-in things in ASP.NET like the logger to allow us to write output to the console log, the event log in Windows, as well as a debug window. And one of the main goals of the chain of responsibility pattern is to allow us for a clean and single responsibility handler. We are now in a place where there's less code inside our handlers, so it means that it's easier for us to write tests for them and to make sure that they are working properly for our particular use case. The chain of responsibility pattern is really just an object-oriented way of expressing a chain of if, else if, and else statements, although I want to urge you not to go ahead and change all your if, else if, and else blocks to leveraging the chain of responsibility pattern. As you saw in the payment handler, it's still okay to use a statement, but in some situations it makes a lot more sense to break it out to have a single responsibility. And finally, we saw how easy we can extend and chain additional handlers together to, for instance, achieve something like they've done in ASP.NET Core. We can append multiple different middlewares to allow us to get a very powerful application. A middleware can handle the potential invocation of a controller, a middleware can handle to make sure that we are authorized. A middleware can take care of if there's an exception and we are running this on our local machine, display that particular exception to the user. So the chain of responsibility pattern allows us to write really powerful applications, making sure that we separate our different concerns, have single responsibility in our different parts of the applications, and write code that is more solid than the ways that we might have done this previously. I really hope you've enjoyed watching this course and that you will now be able to find situations where you could apply these chain of responsibility patterns in your applications. I urge you to play around with this yourself, extend the applications that we've been looking at, and let me know in the discussion how you go about that, and please do tell me if you find ways in your day-to-day work to apply this pattern to make your applications much more powerful, extensible, and testable. My name is Filip Ekberg, and thank you so much for watching this course.