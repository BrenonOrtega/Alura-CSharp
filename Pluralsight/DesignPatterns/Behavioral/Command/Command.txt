Course Overview
Course Overview
Hi everyone, my name is Filip Ekberg, and welcome to my C# Design Patterns course covering the command pattern. I am a principal consultant and CEO at a consultant agency operating out of Gothenburg in Sweden. I started the company a few years ago, and focus on building fast, powerful, and easy to maintain solutions. This course is for those of you that want to learn how the command pattern works, and how to implement that in your C# applications. We will cover everything that you need to know to master this pattern. This includes what the command pattern is, and its characteristics; understanding the benefits and tradeoffs when using the command pattern; how to implement the command pattern in new and existing solutions; as well as identifying and leveraging existing implementations. By the end of the course, you'll feel comfortable with implementing the command pattern in your applications. This will allow you to build reliable, more extensible, and testable applications. Before beginning the course, you should be familiar with the C# syntax, and how to build and run .NET applications. No other prior knowledge is necessary, so I really hope you'll join me on this journey to learn all about working with this very powerful design pattern, with the command patterns course, at Pluralsight.

Command Pattern
The Command Pattern
Welcome to a C# Design Patterns course. My name is Filip Ekberg, and in this course we're going to learn everything about the command pattern, a behavioral design pattern which can be applied in a lot of different types of applications. If you've been coding C# for a while, you might have already encountered this pattern. So this course will cover both understanding and implementing the command pattern, as well as identifying and leveraging existing implementations, and much like other patterns, the command pattern comes with benefits and tradeoffs, and we will be learning all about that as well. A command pattern can commonly be identified by these four different characteristics. We have the command itself, which holds the instructions and references to things that it needs in order for it to be executed. We have something called a receiver, which is what the command will execute, and we have an invoker. The invoker is what we use to execute the commands. It will also keep track of all our executed commands; and then finally, we have a client. The client decides which command to schedule for execution. If we translate these different things into what we might end up seeing in an application, the command could be something like an add to cart command. This command then communicates with our receiver, which in this case is our shopping cart, and then our invoker could be the shopping cart command manager. Although the command manager can be a lot more abstract than this, but we'll discover more about that later on in the course; and then finally, our client could be the button in our interface. You click the button, it tells the invoker to schedule a command for AddToCart, when the AddToCart command is executed, it talks to our shopping cart receiver. The command object contains all the data to process the request now or at a later time. This means that we could, for instance, execute the command right away once the client schedules that command, or we could schedule all the commands to be executed later on in the lifetime of our application; and also, imagine the possibility of storing all the commands that have been executed. Then we could replay the entire chain of commands. If we look at the AddToCartCommand, it will contain a few different things. It will contain a reference to the product that should be added to the cart. It will also need to know about the shopping cart, as well as a way to check the stock availability. So this means that a command contains all the pieces in order for the command to be able to be executed, as well as a way for us to check if the command can be executed or not, because if the stock runs out, that means that we can no longer execute the command because there's no longer any products to add to our shopping cart. As an example, we have this simple WPF application. It lists a lot of products, and we have our shopping cart. Now, every button in this application will in fact invoke a command. We have the AddToCartCommand which will add this to the shopping cart, we have the ChangeQuantityCommand which will allow us to change the quantity, and then of course we have all the other button commands as well. What's interesting with the command is that it will allow us to check if the command can be executed or not, and that's reflected in our interface here because the buttons for a few different products, as well as the increased quantity button in our shopping cart are disabled. That's because the products are no longer in stock, and then that's another example, the checkout button will only be green as long as there are items in our cart. So given that our command manager could keep track of commands that have been executed, that means that the command pattern can easily be leveraged to allow us to introduce undo or redo functionality. As an example, if our application crashes and we start it up again, then we might have a list of commands that we executed prior to the application crashing, we can then re-execute all the commands that we had prior to the application crashing, and we would end up in a pretty similar state that we had earlier in the application.

Implementing the Command Pattern
Let's now have a look at how we can implement the command pattern in a C# application, and remember, the command pattern can be leveraged across all the different types of C# applications. We are now inside Visual Studio 2019, and I'm looking at a console application. The code here for this console application would be possible to run on any different platform that supports .NET. So you don't have to worry about running the examples on Windows. Now this very simple application leverages to repositories. The repository pattern is a different pattern that we won't be covering in this course, but mainly, it allows us to now work with the data without having to worry about if it's in memory, or leveraging SQL Server, or anything like that. You see here that we have our shopping cart repository, as well as our products repository. These two data stores allow us to work with both the shopping cart, as well as all the products available in my system. The specific implementations of our repositories aren't really relevant to the course. All that we need to know is how to interact with our repository, but in this case here, the product repository keeps track of your different products. When we create a product repository, it sets up a few example products that we have available in our store, and then of course we can perform Add, DecreaseStock, IncreaseStock, get all of the different items that we have available, as well as getting the stock and finding a particular item, and this is all backed by an interface that we call the IProductRepository. We then go ahead and find a product called SM7B, which is a Shure microphone. We'll then proceed to add our product to our cart, increase the quantity a few times, and if we run the application, it'll now tell us that we have added five SM7Bs to our cart, and it'll tell us the total price. So our goal now is to refactor this into leveraging the command pattern, because I don't really want to interact with my repository like this in my application. I rather like to have a layer that takes care of my instructions of what to do, and then this instruction can be leveraged across different types of applications. So the first thing that we need to do is add our command interface. The command interface is simply the contract of how our command manager will interact with our command. So I'm going to go ahead and add this to our business layer in the application, and I will add both the interface of our command, as well as the concrete commands and the command manager inside my Commands folder in my business project. There are preexisting ICommand interfaces in the .NET framework, specifically, they're living inside System.Windows .Input, and you can leverage that in your applications. But in this case, I simply don't want to reference system.windows .input, so let's introduce our own interface for our command. Now our command will allow us to execute, check if it can be executed, as well as undoing the command itself. This here is now the contract of what we want our commands to look like in our applications, and if you want to learn more about working with interfaces in C#, there is a really good course on Pluralsight covering exactly how to do that. So now that we've defined how to interact with a command, let's introduce a command manager that allows us to execute concrete commands. Concrete commands is simply implementations of this given interface. We'll simply introduce something that we call a command manager because it doesn't have to be specific to working with our shopping cart, we could call it ShoppingCart CommandManager, but this will allow us to interact with any type of command. Remember that I said earlier that the CommandManager will keep track of both executing, checking if the command can be executed, as well as having a list or a stack of the commands that we have previously executed. So let's first introduce our stack of commands that we have executed in this session of our application. So why do we want to use a stack for this? Because we want to use a last in and a first out data structure, that allows us to then undo our commands in the correct order. The CommandManager will have two public ways of us to interacting with the manager. We will have an Invoke method that allows us to invoke our command. This will first have to check if the command can be executed. If it can be executed, we push this into our commands stack, and then execute the command. Then we will also want a way for us to undo all the commands in our stack. Okay, so the CommandManager now allows us to invoke a particular command. It puts it onto a stack when we want to execute the command, and then we also have a way for us to undo all the commands that we executed. You can play around with the CommandManager yourself. There are a few interesting things that you could try and implement on your own. For instance, you might want to execute your commands at a later time, or you might also want to be able to save all the commands that have previously been executed, and re-execute the entire list of commands when you rerun the application, although that's a little bit out of scope for this course. So now we have our CommandManager, now we need to introduce a few different concrete commands that allows us to interact with our shopping cart, as well as our products.

Implementing and Executing Concrete Commands
So, first of all, we'll add the AddToCartCommand. Our AddToCartCommand needs to implement CanExecute, Execute, as well as Undo, and remember that the command needs to contain all the information for it to be able to execute, and of course there are different implementations of the command pattern. In some implementations, the CanExecute, as well as the Execute method might take parameters, like in WPF for instance, it will pass a parameter to Execute and CanExecute. Although I'm a firm believer that the command itself should take all its parameters in the constructor to make it easier for you to execute these commands without having to rely on any external input as the command is being executed. That means that our AddToCartCommand needs to know about the product, the ShoppingCartRepository, as well as our products repository. I've now introduced the constructor in our AddToCartCommand. It takes on interface for our ShoppingCartRepository, as well as an interface for our productRepository, and what's interesting here is that our commit now doesn't work with any concrete implementations, except for the product, which is only a simple model, but although we work with are these interfaces, which means that depending on a situation, we might use different implementations for the shopping cart. So now we are pretty much ready for us to implement CanExecute, Execute, as well as Undo. We'll start off by implementing Execute. We simply want to check if the product is not null when we execute this command. If the product is null, we'll just return from the method, when we execute our AddToCartCommand, we want to make sure that we decrease the stock left, as well as adding this to our shopping cart, and you'll notice here that on our productRepository we have a method called DecreaseStockBy. It takes the ArticleId, as well as the amount that we want to decrease the stock by, and then we simply add this to our shopping cart, and now we have our execute method implemented for our AddToCartCommand. Let's also go ahead and implement our CanExecute method. We can execute the AddToCartCommand as long as the stock that we have available is greater than 0. The Execute and CanExecute methods are the two methods that you commonly see on the ICommand interface, but of course in some situations, you also have the Undo method. So let's implement this as well. So when we undo the AddToCartCommand, what we need to do is to put the items back where they belong, so increase the stock with the quantity that we have in our shopping cart, and then we simply remove all of those lineItems from our shopping cart. So now we have a complete implementation of our AddToCartCommand, although in order for us to convert our code that we have in our console application, there's one more concrete command that we need in our application. We need a way for us to increase or decrease the amount that we have in our shopping cart. So I'm going to add a command called ChangeQuantityCommand. The ChangeQuantityCommand will be used for both increasing, as well as decreasing the amount of products in our shopping cart. Therefore, our ChangeQuantityCommand will have this enumeration of which type of operation that we want to perform. You'll see that the constructor for our ChangeQuantityCommand take the type of operation, the two different repositories, as well as the product that we want to add to our cart. When we execute our command, we simply check, are we decreasing or increasing the amount of items in our cart, and then of course if we add something to the shopping cart, we'll remove an item from our stock, and we can execute the ChangeQuantityCommand as long as when we're decreasing the amount in our shopping cart, the available quantity in our cart isn't 0, as well as then when we are adding something to the shopping cart, we have items available in our restore to add to our shopping cart, and of course, we have the Undo operation implemented as well. Now if we go back to our program, we want to get rid of the parts that are interacting with our shopping cart directly. We simply want to, instead use our new command manager, as well as the concrete commands that we have now introduced. So let's just comment that out for reference, we'll create two instances of our commands, we'll need to pass the shoppingCartRepository, the productRepository, as well as the given product that we want to add to our shopping cart; and now we want to introduce our increaseQuantityCommand as well. We want to be able to change the quantity of the amount of items that we have in our shopping cart. The operation for this will be increased. We'll have a reference to the shopping cart, to the productsRepository, now we want to have these executed through our CommandManager. So this here represents the conversion from directly invoking our shoppingCartRepository into using the commands with our CommandManager. Now when we call manager.Invoke, it'll execute the command and add it to the stack of commands that we have executed in our application. So if you run this here now, you'll see here that we still have added five SM7Bs to our shopping cart, the total is the same as we had earlier, so we can now get rid of all the direct interactions with our repository. What's of course very interesting here is that our console application now doesn't have to know anything about how to interact with our data store. It's up to the command to communicate with the receiver. So there's one final thing that I want to do in here, I want to undo all the commands that we just executed. So if we tell our CommandManager to simply undo everything that was just executed, and then we print our shopping cart, you'll see here that first we have five SM7Bs. We have the total price, and then when we print the total price again, as we undid everything that we added to the shopping cart, the price is now 0. This here illustrates how we can implement the command pattern in a C# application. Of course, this adds a little bit more complexity, and another layer to keep track of in our application, but now we've separated our concerns. The console application no longer has to know about how to interact with our repository, and with the CommandManager, we get the benefit in this case of also having the Undo method on our command. So now you know the fundamentals of introducing the command pattern in a C# application. Next up, we're going to look at an existing implementation in .NET, and how you can combine that with your own commands.

The Command Pattern in Action
Let's now look at the command pattern in action. We will have a look at an application that leverages an existing implementation of the command pattern, and then of course we will make sure that we can leverage the shopping cart commands that we introduced in the previous demo to allow us to not only leverage an existing command pattern implementation, but also combine that with our own. We're in Visual Studio 2019 again, and we're looking at pretty much the same solution. I have added one new project called the ShoppingCart.Windows, so this will be a WPF application, and the existing implementation of the command pattern will be leveraging the commands inside WPF, and then inside our ShoppingCart.Business layer, we have added two new commands. We have one called RemoveFromCartCommand, as well as a RemoveAllFromCartCommand. So let's just have a look at those implementations. The RemoveFromCartCommand will simply grab the lineItem from our shoppingCartRepository, increase the stock available in our store, and then remove all the items added to our shopping cart. What's interesting here is that you'll notice that I haven't implemented the Undo logic. The reason for that is because the command itself doesn't know how many items at this point was added to our shopping cart, we could of course, grab the lineItem .Quantity here, store that inside our command, and then for an Undo, we could add the same amount into our shopping cart. But you can play around with that yourself. The next command that I've added is RemoveAllFromCart. Of course, what this is going to do is that it's going to grab all our lineItems from our shopping cart. We'll then iterate over all of these items. We'll increase the stock again, and then we'll do pretty much the same thing that we did in our RemoveFromCartCommand. We have these two new commands that will allow us to interact even more with our shopping cart, and again the specific implementation of our shopping cart repository isn't really relevant to this demo, it's simply just allowing us to work with the products and the shopping cart. So now let's have a look at our ShoppingCart.Windows application. This project is a simple WPF application. We've defined the actions and some of the content that we want inside our views using something called a ViewModel, and then we bind this to our UI to allow us to have a separation of concerns. So for instance, we have something called the shopping cart ViewModel. The ViewModel contains all the information that we need in order for us to display the information and interact with our particular view. This here has a reference to our shopping cart, as well as our products. We have two commands called RemoveAllFromCart, as well as the CheckoutCommand. Then we have two collections, we have the Products, as well as the lineItems. So the Products is all the available products in our store, the lineItems are all the products that we have currently added to our cart, and this pattern is very common when you're working with things like WPF, Xamarin, or back in the day, even Silverlight. Now to first glance, you'll notice that the ICommand that we leverage here is coming from System.Windows .Input, and if we have a look at this ICommand interface, you'll see that it has two things that we are very familiar with, it's the Execute method, as well as CanExecute, and remember earlier I said that some implementations leverages a parameter passed to the Execute and CanExecute method, we won't be using that in this course, but you can play around with that yourself; and then there's this EventHandler that tell us if CanExecute has changed. So this here is very UI- specific, which is the reason for not using this in our business layer. So how do we combine this with our existing implementation of our concrete commands? Well the way that we do that is by introducing a concrete implementation for a command inside our WPF application. I call this the RelayCommand. It's a relay that allows us to execute something which we pass as an action to the constructor of our RelayCommand, as well as doing the same thing for a canExecute. So the implementation for our RelayCommand is very simple, we'll simply have our CanExecute, as well as our execute method, which simply call the corresponding actions and functions inside our concrete RelayCommand, and then we can use this together with our existing concrete implementations of commands that we have in our business layer. In this case here, I set up a RemoveAllFromCartCommand, with a reference to our shoppingCart and productRepository, and then inside our RelayCommand whenever that RelayCommand is executed, what I do is that I execute my removeAllFromCartCommand, as well as making sure that I refresh our UI. Again, this here shows that I wouldn't want to have all of this logic inside my concrete implementation that lives in a layer that's not UI-specific. So leveraging something like a RelayCommand in this case is a really nice way for us to combining something that works across different types of projects, like our implantation of the command and the CommandManager, with something like the command pattern implementation in WPF. Also notice here that I'm not in fact using our CommandManager, so I'm directly communicating with the commands, because right now I don't want any undo functionality or keeping track of which order the commands were executed in. Of course, we could introduce a CommandManager and use that as well, but you can play around with that yourself. So now how do we use this inside our UI? Although this isn't a course on how to build WPF applications, let's just simply have a quick look at how we leverage this command inside our application. Inside our WPF application, you can see that I have two buttons here, which simply references to commands inside my view model. It references the RemoveAllFromCartCommmand, as well as our CheckoutCommand. So far we haven't seen the AddToCart or ChangeQuantity commands. Those live inside our product view model. So we have our ICommand from System.Windows .Input for both the AddToCart, IncreaseQuantity, DecreaseQuantity, as well as our RemoveFromCartCommand. But again, these are only RelayCommands. So what we do here is that we set up our AddToCartCommand, the Increase and DecreaseQuantity commands, as well as our RemoveFromCartCommand, and these are all the concrete implementations that live inside our business layer, and then we leverage the RelayCommands to execute and check if these commands can be executed or not, and running this application will allow us to add product to the cart, and you'll notice here how it automatically simply disables the button whenever the CanExecute method returns false, because we cannot add more products to our shopping cart if the stock has run out. You'll notice here if I remove one of these items, it'll allow us to add it back to the cart again, and if we add five Shure SM7Bs, you'll see that the total price is the same as we had earlier in our console application. Under the hoods, WPF will leverage a command manager. It will make sure that whenever you press the button, it'll execute one of these commands. This here gives you an idea of an existing implementation in the real world. It illustrates how we can leverage the RelayCommand together with our own command pattern implementation inside our applications. Again, one of the drawbacks of using the command pattern is that it does add another layer in our applications, but now we have a complete separation of our UI, our ViewModel, as well as the command that's being executed. The goal is of course to have maintainable solutions, and what's interesting here is that if you want to introduce new functionality in your application, you can simply introduce a new command without breaking existing implementations, which of course is extremely important when building applications for our users. We want to make sure that we can extend the applications without breaking things along the way. So now you've seen not only how to implement the command pattern, but you've also seen how this is used in existing implementations like WPF, as well as how you can leverage an existing implementation with your custom implementation of a command pattern. I urge you to try and introduce the CommandManager in WPF, and introduce an undo button in your application, and maybe even do a redo button. So go ahead and play around with the command pattern, and extend it your liking.

Final Words
In this short course, we covered the command pattern. We looked at the command pattern characteristics, and identified that we now know that a command pattern consists of a command, the receiver, invoker, as well as the client. This of course gives us an understanding of how the command pattern works. We talked about what a command is, and the fact that the command contains all of the information that it needs in order for it to execute now or at a later time. We got an understanding of why and how it can make a crucial part of the application more robust, also making it more testable; because now we introduce a layer which contains these commands which are instructions for how to process certain data and instructions, and of course, the command pattern allows for separation of concern. We no longer have to tidily couple our application with for instance, our repositories or data layers. We can now identify existing implementations and adaptations. We of course also talked about how we can leverage the implementation and adaptation in WPF together with our own implementation of the command pattern; although one of the drawbacks of using the command pattern is of course that it could add unnecessary complexity. So for instance, if you're working with a very tiny application, it might not be completely necessary to involve the command pattern, but in larger line of business applications, it can make your life a whole lot easier. So this course has now given you an overview and understanding of how to use the command pattern, and how to apply that in your C# applications. Thank you so much for watching this course. I hope you'll be able to leverage all the information that you've learned about the command pattern, in your day-to-day work. My name is Filip Ekberg, and thanks again for watching this course.