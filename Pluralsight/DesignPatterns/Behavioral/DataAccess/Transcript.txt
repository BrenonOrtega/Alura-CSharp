Course Overview
[Autogenerated] Hi, everyone. My name is Philip Ekberg and welcome to my C# designed patterns Course covering the data access patterns. I'm a principal consultant and CEO at a consultant agency operating out of Gothenburg in Sweden. I started the company a few years ago, focusing on building fast, powerful and easy to maintain solutions. This course is for those of you that want to learn about the different data access patterns, how they're implemented using C# and best applied in your applications. This means that we're going to dig into repositories unit of work as well as Lacey loading. We will cover everything that you need to know in order to master these different patterns. This includes the characteristics of a repository unit of work and Lacey loading, understanding the benefits and trade offs when using these different data access patterns. How to implement these patterns in new and existing solutions, as well as identifying and leverage existing implementations. By the end of this course, you'll feel comfortable with implementing repositories unit of work and Lacey loading in your applications. This will allow you to build extensible more robust and testable applications before beginning this course. You should be familiar with the C# syntax and how to build and run .NET applications. No other prior knowledge is necessary. I hope you'll join me on this journey to learn all about working with these very powerful C# designed patterns with the data access patterns course as Pluralsight.

Repository Pattern in C#
Repository Pattern
[Autogenerated] welcome to this C# designed patterns. Course, My name is Filipek Berg and I will guide you through understanding the data access patterns. And also apply that in your applications. After completing this course, you will feel comfortable applying the repository pattern unit of work as well as Lacey loading in your applications. This will help you build maintainable testable as well as easy to work with applications. So join me in this course here on Pluralsight to learn everything that you need to know in order for you to apply the data access patterns in your C# applications. My name is Philip Ekberg, and welcome to this course in this module. We're going to introduce the repository pattern. This is an extremely common pattern to apply in front of your data axis. It will encapsulate the logic to communicate with your data layer so that the consumer off your repository don't have to worry about if you're using entity framework. If you're communicating with a file system, if you're using in hibernate or any other oh rms or ways to communicate with your database. So first off, let's look at an application that's not leveraging the repository pattern. Well, quickly notice that the application lacks test ability. And once we want to leverage the same data access somewhere else in the application, we'll have to duplicate our code, and that's not very good for maintain ability. So first off, let's talk about this type of application. This here uses a Web application as an example. We have our controller or what We also can call the consumer off our data access. We start off by trying to fetch some data from our data access layer, which then goes ahead and queries our database. The data access layer will then get all the data back to it. In this case, we're loading some orders, and then those orders are returned back to the consumer, which in this case is the controller in our web application. Now, of course, the repository pattern can be applied in any type off application. It doesn't have to be a Web application. It doesn't have to be a .NET application, although, of course, in this course we are applying the different data access patterns, leveraging C# so you can quickly see that this application, without leveraging the repository pattern, poses a few different problems, mainly it's not testable. How would we introduce a testing the application that's testing our controller? That would in fact have a side effect that would probably create things or delete things in our database? And that's not really something that we want to do in a normal unit test. So our current design of our code here poses a few different problems. First of all, the controller is now tightly coupled with the data access layer. This means that the controller has to know about the O. R M or the way that we work with our database. For example, in this case, it might know that we are leveraging entity framework and used the entity framework data context right out off our controller. And that's something that we want to avoid. And as we just mentioned, it is hard for us to write a test for this controller without introducing and side effects. And in some situations, we might want to extend our entities with domain specific behavior before they're returned back to the consumer. And that's also very hard when we are directly communicating with a data access layer out of our controller. So instead what we're going to do is that we're going to apply the repository pattern. Applying the repository pattern simply means that we introduce a layer that encapsulate our data access code. This means that our repository will know how to communicate with, for instance, entity framework and hibernate, or our file on disk or another SQL Server or other types off database is. This means that the controller can now leverage our repository to ask for data without having to worry about how that data is fetched from our data store. So, of course, the benefits of introducing the repository pattern is that the consumer, also known as the controller in this case, is now separated from our data axis. It's easy for us to write a test without having any side effects, because the controller consume plea replace our repository at runtime using, for instance, these strategy pattern we can also modify and extend entities inside the repository before they passed back to our consumer, and we'll talk more about that later on in the course when we introduce Lacey loading. Introducing this repository also now means that we have a share a ble abstraction, resulting in less duplication of code. If we have an order repository. That means that anyone in the application can now ask for orders without having to worry about communicating with our underlying data structure. And, of course, is also improves to maintain ability off our applications. A repository is simply an abstraction that encapsulate your data axis, making your code testable, reusable as well as maintainable.

The Example Application
[Autogenerated] Let's now jump into Visual Studio and have a look at how we can apply the repository pattern. We will look at an application that's not leveraging. Any of the data access patterns that we're talking about will gradually improve the application to apply the repository pattern unit of work as well as Lacey loading. You can easily follow along these demonstrations in this course, but downloading the exercise files from either Pluralsight or GitHub. Once you've extracted your exercise files, there's one voter for each module. If you run into any problems during the course, feel free to add a comment on the discussion board on the course page. The Module folder contains a start here, as well as a completed folder. The completed folder will contain the code that we're gonna end up with at the end of the particular module. So now that we're going to look at applying the repository pattern in our application, were going to going to the start here folder and start this solution? We can open this up in Visual Studio or in Visual Studio for Mac, depending on which operating system you're working on, I'm going to start off by cleaning and rebuilding the application this will proceed to download and restore the packages that the different projects are referencing. The application that we're going to work on is an internal ordering system for my company, even though that we're working with a Web application. That repository pattern can be applied in any type of different application. It doesn't matter if you're working in a console application, Windows forms, application SAML, an application or a web application. It really doesn't even matter that you're using C#. This pattern can be applied in any type of application that you're building. So we have three different projects. We have our web application, which contains our model views and controllers, and we have an infrastructure project which will contain the data access as well as services and our domain project. Contains are different domain models that represents entities that we're working on in this application. If we go into, for instance, our order controller, which handles the creation and retrieval of our orders, we can quickly see here that the order controller is tightly coupled with our data access. The order controller has a shopping context. Are shopping context is simply a DB context. This is leveraging entity framework core, which is outside of the scope of this course. The idea of the repository pattern is that we can apply this to encapsulate whatever data access layer that we're leveraging. This could be normal, SQL commands. It could be an hibernate, or in this case, we're leveraging entity framework. This context represents a list of customers, orders and products we're using SQLite, which means that anyone could run this application on any given system. SQLite allows us to create this database as a local file on our disk and entity framework, or will allow us to communicate with is SQLite database like any other type of database that you might have worked with in the past? Let's jump back to the order controller. While it's not necessary for you to understand web programming or how to work in a speed .NET or app .NET core. Essentially, these methods also know as the actions inside the controller, classes will eventually end up returning some data back to a user that request something over the web browser. We'll be working in these methods, and you don't have to care too much about that. This is a Web application. If we head down to our index action we can see the at it. Leverages are shopping context. It retrieve to the orders by leveraging entity framework. It's eagerly loading the line items as well and then also eagerly loading the product for each line item. Then we're simply saying that we want to retrieve all the orders that were placed yesterday or today. We also have a method inside our order controller class which take care off creating the orders for us. This here takes a create order model, which contains information that we want to map to our domain model before proceeding. To add that to our database. Now, at the bottom of this create method, you will see that we are directly talking to our shopping context. So again, our class here is tightly coupled with our data layer. It knows about entity framework and how to add things to the database. So this here is a little bit problematic because imagine that we now want to create a test for this particular action. What happens in reality is then that it's going to query our database, which is not necessarily what we want to do. Unit tests shouldn't have any side effects So if we write a test for our controller, we want to make sure that it doesn't create any rows in a real database. So this is where the repository pattern comes into play. What we want to do now is to decouple our order controller from the data axis. We simply want the order controller to work with something that's representing a way for us to retrieve in order without having to worry about the underlying data structure.

Introducing a Generic Repository
[Autogenerated] So let's jump into Visual Studio and start applying the repository pattern. So now we want to decouple our controller from the particular data axis. We don't want the shopping context or a DB context to exist inside our controller. Instead, we want to leverage the repository pattern. And in order for us to do that, we're first going to introduce the interface off a repository. And we'll do that in our infrastructure project. This interface will simply dictate the contract of a repository, and we're going to set up a generic interface. Normally, a repository is in charge of all the crowd operations, which is create, read, update and delete. Our repository is going to allow us to add an entity it's going to allow us to update on entity, and it's going to allow us to retrieve a particular entity. Based on the identify are I also want a way for us to retrieve all the items as well as finding a particular item based on some search criteria. This parameter passed to our fine function known as the predicate, will be an expression that will evaluate if a particular item should be returned or not from the underlying data store. And of course, we also want to be able to save the changes that we might have done to our different entities. So this here is the interface that our controller is now going to be working with instead of directly communicating with our data access layer, we're going to introduce a concrete implementation off this interface which are controller can use. So now we're ready to introduce a concrete implementation. So how do we know which repositories that we want to create in our application? Well, if we look at our Domaine models, which of these different domain models makes sense to have their own repositories? Of course, we want a way for us to work with a customer. So we need a customer repository. We don't really need a repository for the line items because the aggregate route, which is the order, will have a list off the line items. So we can process the line items through the order itself, so we only need a customer repository the order repository. Then, of course, we also need the product repository, so it's more than okay to introduce more than one repository in an application. In reality, though, a lot of these different repositories have the same type of code for retrieving, getting, finding and listing all the items. So how about we introduce a generic repository that introduces these base functionality that all of the different repositories can leverage? And then if we have particular implementations for other types of repositories, we can introduce that in a subclass. So we'll introduce a generic repository which is going to implement our interface, our repository of tea. And we also want to make sure that we only work with reference types. So we were going to say here that t here is required to be a class. So now we can proceed to implement this interface. In order for us to implement these methods, we, of course, need to work with our data context. So this is pretty much the only place in the application where we will know about our shopping context, and we're going to make sure that we pass our shopping context into the constructor off our repository. So now that we set up one of these repositories, we will know that we can work with our shopping context, which is our underlying data structure. It could as well have been the SQL Connection and SQL Command or in hibernate the consumer off our generic repository won't know the difference. So let's go ahead and implement the methods. We'll start off by implementing AD DS. In order for us to do that, we're going to use the context and we're simply going to say that we want to add a particular entity we're gonna add the entity that was passed into our ad method. But then the signature of adhere also request us to return the particular entity that we just created. So we can simply say that we want to return the entity that was just created through our shopping context. This is a pretty common and nice pattern. Next, we're going to go ahead and implement all So again, we're going to leverage our data context. This year will allow us to work with a set off our particular entity and we can simply say that we want to return that entire set as a list. Don't worry too much about the particular implementations in our methods. In our repositories, the demonstration application is leveraging entity, framework, core and understanding how to work with entity framework. Core is outside of the scope of this course. The important part is that we're now decoupling our consumer from how to work with our data context. Instead, we're going to work with our repositories that will take care of how to work with the underlying data structure. So your real world application might be leveraging the SQL commands SQL connections and hibernate or entity framework. And those different implementations would live in your repositories and then we can proceed to implement find. Now find here is going to be a little bit different than our all. What we also want to do is that we want to pass the predicate down to our queries able So this could be converting to a query that's running against SQL Server or, in our case, SQLite. So now we want to stay here that we have our queries real and we want to apply are predicated on this, and then we're simply going to return the result as a list off t. So now we have three more methods in our generic repository to implement. Finally, we have saved changes and this is simply going to leverage context dot save changes. Introducing this class here might seem a little tedious, but what's interesting here is that we now have a very generic way of communicating with our underlying data store. The consumer off our repository don't have to worry about if it's entity, framework and hibernate or SQLite. Now that we want to introduce a repository for our customer order and products we want to inherit from our generic repository. The sub classes off generic repository can add custom behavior to each of the methods before data is passed to the database or return to the caller so we could override each of the methods inside our generic repository to introduce this custom behavior in our concrete implementations off our repositories. In order for us to be able to override those methods, they all need to be marked as virtual. This just means that we have the capability off overriding that particular method, but we don't have to

Extending the Generic Repository
[Autogenerated] let's proceed to add on implementation for a particular entity that's based off our generic repository. We're going to start off with our product repository. This is going to inherit from our generic repository, and this particular repository will now work with our product entity. This means that we need to pass our shopping context into our product repository, which is then passed on to the base class, which is our generic repository. Now, we just out of the box got all the methods for adding updating, getting, finding and saving the changes for a product. So one of the things that I want to implement in our concrete implementations off our generic repository is I want to override how we update the products because I wanna make sure that we can first find the particular product and then simply change the values that we have approved to change in the repository. So you'll see here that we can override all of these different methods that we just introduced. We're gonna make sure that we call Base DOM update at the end off this method here just so we get the base functionality as well. So we're going to say that we want to find a product out of our data context that matches the product, IDE, that we passed on the entity that we passed into our update method on our product repository. And then we're going to proceed to allow to change the name as well as the price of the product. And, of course, we need to pass the correct entity that we just updated to the base class. There's nothing else that we really need to add into our product repository. But before we go ahead and refactor the entire application to use the repositories instead, I wanna make sure that we've introduced all of the repositories that we're going to need in this application. Next up, we're going to introduce the customer repository. And just as with our product repository, we're gonna pass the shopping context into the constructor off our customer repository, and then we're going to proceed to introduce our update method. And of course, we need to pass the correct entity that we just updated to the base class. Now, finally, we also want to introduce the order repository, the first method that we're going to override its our find method and the reason that we do this is because we want to make sure that whenever you find on order, we also want to make sure that we've eagerly loaded the line items and the product. So in this case, we're not gonna call the base class because looking for the same item twice is kind of unnecessary. So when we work with the orders, we also want to make sure that we include the line items. We also want to make sure that we include the product off our line item. So now what we've introduced here is a way for us to find a particular order include the line items for that order, which is a reference that the order has that we need to make sure that we include when were fetching the data. Then the line item itself has a product references, So we also want to make sure that we load the product. This means that when we have our order in memory, we have all the data available to us in order for us to successfully work with all the properties on our order and later on in the course, we're gonna be looking at how we can Lacey, Load this data. And finally, we also want to override update as we've done with the other repositories. Since we might be updating our line items, we need to make sure that we also include the line items. Here is well, so now we've successfully introduce all our different repositories. All that's left now is to refactor the application to leverage our different repositories.

Consuming a Repository
[Autogenerated] we have the interface that represents the way that we communicate with a repository. Our controller can use this in order free to know how to grab data without having to care about how the data is represented. If we're using in hibernate entity framework or storing this to a file on disk, the consumer no longer has to know anything about the underlying data structure. We then introduce the generic repository that allows us to generically work with our data context to reduce the amount of duplication of code inside our concrete implementations off our repositories. So now let's go ahead and go to our Web application and refactor this to make use of our repositories. We're going to proceed to go into our order controller, just browsing the code here. We can see the at the dependency with shopping context makes use of fetching all the orders. It gets a list of the products and it allows us to create a new order. So now let's proceed to decouple the application from our data context. Going to get trade off our data context. Instead, we are going to work with our IRA posit Torrey, we're going to introduce our order repository, but We're also leveraging the product, so we need the products repository as well. Now we can go ahead and get rid off the shopping context from our constructor as well. And now we're gonna leverage the repositories in our actions instead of directly leveraging our data context. So you'll see here that the wear clothes here contains a predicate. If we simply cut this out and remove this part here because this park looks very similar to what we have in our repository to find a particular list off orders just as simple as that we refactor our index action inside our controller to leverage the order repository instead of directly communicating with our data context. So that's one down. I know that we have to more methods before we're done with our order controller. Next up is our create action. More specifically, it's the page that's displaying our creation page that shows a list of products. So instead of leveraging our data context, we're gonna use the product repository and we're gonna fetch all the products. So now we want to create a particular order the first time that we used to date a context in this particular code block is when we add the particular entity to our data context and then call save changes. So we can simply refactor this part to leverage our order repository. And then, of course, we can use the order repository to make sure that we say the changes to our database. So what's now interesting with our order controller is that we now work with updating and finding data in a abstract manner we don't care about If this is entity framework, we don't care if we're leveraging a file on disk. We're using our repository interface, which dictates the contract off what a concrete implementation often interface would look like. We, of course, also need to set the repositories to an instance off the concrete implementations off a order repository as well as the product repository. And I'm gonna use dependency injection to do this for us. We're going to say that the order controller needs to have the order repository as well as Thebe products repository passed to the constructor. Now, if we create an instance ourselves off this order controller in, for instance, a test class we can pass whatever class we want as an IRA posit Torrey off order or off product as long as it matches the interface oven. Ira posit Ori. In order for us to get app .NET to inject this for us, we can go ahead and go to the startup file off this project. We're gonna go to startup CSS. What we're going to do here is that we're going to leverage the built in dependency injection. We're going to say that whenever you ask for a shopping context app .NET will just automatically inject this shopping context that we've specified here and we can do the same thing for our different repositories. So for a I repository off order, we're going to make sure that we pass in in order repository. And of course, for a product you guess it right? We're gonna pass a product repository. And finally, of course, if we ask for an IRA posit Torrey of customer, we're going to pass a customer repository, although we're not using the customer repository yet. So let's just add that before we run the application, we're gonna go into our customer controller. We're going to get rid off our shopping context. We're going to make sure that we inject an IRA posit torrey of customer into our constructor. Our methods inside our customer controller class will then be able to leverage this customer repository to access the data for the customer. Let's rebuild and run the application. And if we proceed to create an order with the do ______ attached we can, see here that it's now going to leverage our order repository. And if we step into adhere, this will take us to our generic repository because our order repository didn't override this particular method. We can see here that the entity that we pass into our ad method is in fact our order domain model. So with this particular pattern, we now made sure that we decoupled our controllers from the way that we work with our data axis. We don't have to worry about being tightly coupled to our data access layer. We can now work with this repository pattern in order for us to make sure that we have a common interface to communicate with data in our different places in our applications. Without those consumers having to worry about the underlying data structure, these e way that it communicates with a database, all of that can be handled inside a repository and again. You can apply these patterns and principles in console applications, in Web applications, in Windows applications in mobile applications or pretty much anything, just as with other patterns. One of the drawbacks off introducing their repository pattern is that it can add a little bit off complexity into the application. Introducing more layers isn't always going to make your applications better, but I personally think that the repository pattern as a lot of value in most types of applications.

Testing with a Fake Repository
[Autogenerated] One of the things that I promised is that the application is now more testable. When we apply the repository pattern, we encapsulate the data access code in a different class so that the controller in this case doesn't have to know about how to communicate with our underlying data structure. So when we create our controller inside a test we can just inject a different type of repository we can use a fake aura mocked version of our repository and simply mark away the communication with our underlying data structure. When our test is asking the controller to invoke the create order endpoint, this will in its turn go and talk to the fake repository and our tests can invalidate that. We've got a 200 okay back. It can also validate that the repository was invoked by checking the interactions against our fake repository. So now we can, jump back into Visual Studio and have a look at how we can apply a test for our controller, which will now leverage a fake version off our repository, which means that we won't have any side effects when invoking our controller. We cannot AD FS test project for .NET core to allow you to run this on any platform. This is going to test our web project. So I'm going to name this the same way that I named my project that I want to test and then apply tests at the end. And the test that we want to build is going to test our controller in order for us to create a fake instantiate OAuth our order repository. We have a few different options, but I'd like to use the package called Mock to allow me to create a mocked object. A mocking framework will allow us to create mocked objects which will allow us to create instances off our interfaces looking like real objects and we can say what's going to happen when we call certain methods and then make sure that particular method was called. So I'm simply going to install mock here into my testing project, and now we can proceed to write the test for our controller, and then we're going to follow, arrange, act and assert. And now we're going to set up our order repository as well as the product repository. Now we can create an instance of our order controller and we're gonna pass the actual mocked object off our order, Repository, that will make sure that the order controller now gets something that looks like our order repository with fake implementations for the different methods. And we're gonna do the same thing for our product repository. Now we have an instance of our order controller and what we can do now is that we can create the test data for creating an order. So now we're ready to act on this and we want to invoke our controller to call our create method with our create order model. And of course, this is the same method that would be called by a SP .NET MVC once it routes through the application and we ask for the result out of this particular action. Although what we're interested in here is that when we call our create action on our particular controller, we wanna make sure that it takes our model and passes that into the repository. The simplest test that we can do is to make sure and verify that our order repository was called upon and we can use mock for that to say that the ad method on our order repository must have been called once so we can say that we want our order repository and we want to verify that a particular method was called. We wanna make sure that the method add on our particular repository was called and we really don't care about the parameters that was passed to this method. So we can now say that at on the repository can be called with whatever order we don't really care. And then we can also say that this needs to be called at most once for this particular call. So now we're saying that we want to leverage the mocking framework not only to create a fake version of our repository, but we can also make sure that some of the methods on our particular repository recalled We could, of course, also introduce a class here that implements our I repository off in order and past that into our controller creation up here at the top. But I'd like to use a mocking framework like Mark because then I can say that for particular interactions with our marked objects, it either return some particular data or at the bottom here. I can say that I want to verify that a particular call on the repository actually happened this year now allows us to run a test without any side effects so we can go ahead and run this test here and we can see that all of our tests past this now means that we leverage the repository pattern to get rid off the coupling with our data access. And we can now write tests for our controllers without having to worry about the side effects. This is a great improvement to our application. We refactor done application that was coupled with the data access to leverage the repository pattern.

Summary
[Autogenerated] well done on completing this module. You now have the knowledge to apply the repository pattern inside your C# applications. This was the first of the data access patterns that we're going to cover in this course. We've talked about that. The repository pattern enables us to apply code for accessing data that can now be shared all over our applications. We no longer have to duplicate the code for communicating with our underlying data structure. The data access is encapsulated inside a repository, which means that the consumer in our case was a controller didn't have to know about how to talk to any framework. It only knows about the repository and that it's capable of retrieving data. It no longer has to know about the underlying data access and the code became more testable. We saw that we can simply introduce a test and inject a marked version or a fake repository into the creation of our controller we can. Then right tests as we were an application that's invoking our controller and our application to make sure that we're getting data flowing through the application as expected. And now that we have a repository in place, we can instantly intercept entities before they're sent back to our consumers we can AD DS tales to the customer or the order before it's sent back to the proper controller. So up next, we're gonna be talking about you need off work in C# instead of talking to the database for each time that we want to add something in our separate repositories, we're gonna be grouping the transactions together to make a little bit less of a chatty application. So stay tuned for that, and I'll see you in the next module.

Unit of Work Pattern in C#
Unit of Work Pattern
[Autogenerated] in this module will be covering unit of work pattern in C#. You're watching a C# designed patterns, course covering the different data access patterns. The unit of work pattern is a great addition to our repository pattern. What it allows us to do is to references multiple repositories inside our unit off work class. And when we want to commit data to our database, for instance, imagine that both the order repository as well as our customer repository want to create data at the same time. Instead of doing that in two transactions. We can, make sure that we save the data in one transaction to the database. So our unit of work class will make sure that we reduce the communication with our database. So, in essence, applying the unit of work pattern means that we just introduce a class that holds a reference to our different repositories. As an example of how we can apply the unit of work pattern in our application, imagine that we have this unit of work class. The unit of work class has a reference to our customer repository, the product repository as well as our order repository to make this work and be able to commit all the work in the same transaction to the same data context. Each of the repositories inside our unit of work need to share the same data context. And then as an example of how this can be applied in our application, the application request to create a customer, then to get the products when we request to get the products that actually needs to go down to the database to request the proper data out of our data store. So since we do that through the product repository, it knows that it needs to talk to the database. And then when we have all the products in our application, we can now go ahead and set up our order. We're gonna get the order repository out of our unit of work class and proceed to create the order using that repository. We will then ask our unit off work class to proceed to save the changes which will use the in our case, the data context to simply commit all the changes down to the database at the same time. So this here greatly reduces these amount of calls down to our database. When we apply the unit of work pattern in our application instead of having to talk to the database for each insert or update we can simply group that in one single transaction.

A Use Case for Unit of Work
[Autogenerated] the current state of our application actually wouldn't benefit off using the unit off work pattern. And, you know, introducing patterns just for the sake of introducing patterns isn't really the best approach. So we want to find somewhere in the application where which would make sense for us to leverage the unit of work pattern as the application _____. If we have a look at the current state off, the application and, for instance, create a new order. Now imagine the case where I want to add more orders to the same customer. If we create in order with the identical customer details, as we previously entered, and then proceed to have a look at the customers that have been created in our system. We can see here that we have to customers created with identical details. So on improvement to our application would be to head into our order controller and make sure that when we add orders to existing customers, we simply referenced that customer instead and potentially update the customer's address with the new details that we just added. So let's jump into Visual Studio and make that change. And, of course, let's first make the change without leveraging the unit off work pattern, and we'll see how easy it is for us to improve the application by introducing that pattern would have some code in place for updating both of our different entities in the current state of the application was simply initializer a new customer. Instead of doing that, let's try and find a customer with the same name. Obviously, in a real world scenario, you would probably want to find the customer based on something else. Otherwise, we're limiting are system to only have customers with unique names, and in order for us to fetch the customer, we need to leverage our customer repository. So first we want to proceed to add that to our order controller. And because we've already set this up with a S p .NET, we know that when a ASP.NET creates an instance off our order controller, it will now automatically mapped the I repository of customer to our customer repository. So let's go ahead and now leverage our customer repository in our create method. This year will now find all the customers with the same name, and we're just going to get the first one because you know, our system homely supports one customer with the same name. So now what we can do is that we can check if the customer that we try to load actually exist or not. Otherwise, we'll proceed to create a new instance of a customer. And as we said that as a reference type on our order, entity framework will then know that it needs to create a new role in the database for that particular new customer. So now we can say that if the customer that we loaded wasn't no we can proceed to update the customer details. And now that we've set the fields on our customer, we of course need to indicate to the customer repository that it needs to update our customer as well. And of course, we need to commit those changes which will end up being committed to our database. So if we don't have the customer, we wanna make sure that we create a new one. So now what's happening here is that we're trying to load the customer out of our customer repository. If we find the customer, we're gonna proceed to update the fields on the particular customer and save the changes. If we cannot find the customer. We're going to create a new customer with the particular details that we passed into our method. And then, of course, we set the customer on our order. We add the order to the order repository and we save the changes. Just a side note here. One of the things that I've set up in the startup file off this project is that it's going to delete the database every time that you rerun the application. This is to make it easier for you to follow along with the demos and at the same type of data that I add in my demonstrations. So we're gonna proceed to create a new order for a new customer. This here will, of course, at a new order to our system. If you want, you can go ahead and tweaked the application so that it clears thief form here and allows you to create any order. But if we simply submit the same type of details with one item added, we're going to run into a little bit of a problem. You'll see her that we get an exception. So let's run this with the d ______ attached and step through the code and see what happens. We can see here that it in fact finds our customer. We proceed to update the customer and save those changes. What's interesting here now is that we didn't get an exception up here at the top. So where is the problem in this code here? The problem lies in that we're now trying to create our order with the customer that we loaded from the database. So how come this doesn't work? Well, that really requires us to understand how entity framework core works. The problem here is that we have two repositories. Both of them are leveraging different data contexts. Well, in fact, they're leveraging the same type of data context. They're both using the shopping context, but they're both leveraging two different instances. We have multiple different ways to solve this. One option to just get this to work is to set only the customer ID, and it would figure that out itself when it's trying to reference that foreign key in the database. But I want to solve this properly, and I wanna make sure that I don't do to commits to my database because what's happening right now is that up here at the top. We are updating the customer through the customer repository, which will send one query to the database. And then we're trying to create the order, which is another query to the database. So let's do both of these in the same transaction. The way to do that is by introducing the unit of work pattern.

Applying Unit of Work
[Autogenerated] Let's now jump into Visual Studio and have a look at how we can change our application to leverage the unit off work pattern and introducing unit of work is rather simple. In our infrastructure project, I'm simply going to add a new filed call unit off work. It's a good idea for us to first specify the interface off a unit of work so we can use this in our test project later on. I'm gonna leave it up as an exercise for you to make this work with the testing project. If you re compile the entire solution now, you'll notice that you might have a problem inside the test project because you're no longer injecting all the parameters into your constructor off the order controller. But you can work around that and let me know in the discussion board on the website if you run into any problems. So now what we'll do is that will introduce the I unit of work interface. We talked about earlier that the unit of work really just encapsulate our different repositories. That is a part off this unit off work. It also allows us to save the changes for all of the different repositories that we've made changes to. So let's just proceed to add all the repositories from our application to make sure that all of them can work in one unit off work. So now we have all of the different repositories that exist in our application available in our unit of work. And of course, we also need the way to save the changes to all the repositories. So now we want to implement our interface, a unit off work. So we want to expose the customer repository, the order repository as well as our product repository. They were all going to leverage this same shopping context. So we need to store our shopping context inside our unit of work so that all of the different repositories can leverage the same instance off our data context. And then when someone requests, one of the repositories will create an instance off that if we haven't already done so, that means that we'll keep the instance that we create once you request the repository as a private field in our class and this particular pattern for creating the instance off our local field. Only when you're requesting that particular property it's called lazy initialization. This laser loading pattern is something that we're going to cover more in the next module. And what you can see here is that we were initializing our customer repository. Leveraging the shopping context that we have is a private field in our unit off work. So if we apply the same pattern to all the properties that exposed the repositories inside our unit of work, they will all share the same data context. Once you try to access one of these properties, they will initializer the private field and then return that value back to the color with its initializer repository. Now, are you network implements. All the retrievals off are different types of repositories that interface dictates Now. We also need to implement a way to save our changes. So how do you reckon that would commit the changes for all of our different repositories at the same time? Well, since they're all leveraging the same data context, if you know a little bit about entity, framework or entity framework or you'll probably already know that if we call context, not save changes that will commit the changes for all our different repositories that we've leveraged because internally, in our repositories, they're simply doing operations towards the same data context. And, of course, if you'd like to you, you can go ahead and change the application to only leverage the asynchronous principles on your data context and only expose a sync prints operations out of your repositories. But I don't want to confuse you with introducing the A sync Inouye keywords in the sync prints principles. You can check out my course getting started with a sync prints programming in .NET after watching this course, and then you can tweak the application to leverage these sync prints principles as well. So now we have our unit of work. Let's go ahead and change our order controller to leverage this class. Since I know that my order controller is working with more than one entity, I'm going to leverage my unit of work instead of including each repository separately. I'm instead going to inject my eye unit of work, so now we'll get a few compilation errors. But don't worry. This is really easy for us to fix. Remember that our unit of work will expose references to these different repositories, so look at that fixing the first compilation error was rather simple. We can proceed to fix the other ones as well. Now, when it comes to saving the changes, we really just want to do that. At the end of this method, we're going to commit all the changes that were doing inside this particular method at the same time to avoid being too chatty with our database. So now we're accessing the order repository, the customer repository and the product repository out of our unit off work. And then we're telling our uniforms here at the bottom to save all the changes. This will then, of course, perceived to commit the transaction and save the potential changes to our database. In our case, we might be creating or updating a customer at the same time as we are creating a new order. The order can be associate ID with either a new or an existing customer. And, of course, to get this injected properly into our controller, let's just quickly head over to our startup file and let's add our unit of work to our dependency injector as well. Now a ASP.NET will know how to create the unit of work. It will automatically inject our shopping context into the unit of work and then in our unit of work, will simply proceed to create our different repositories manually. If we now proceed to try and add the same customer twice we can see the at when we create an order and create the customer the first time this works, let's now see if it works. If we do this a second time and hopefully this will update the customer details we can see the at. We just have one customer, but we have multiple orders. So this here shows us that it didn't in fact create to customers. But it proceeded Load one of the customers that we had already created inside our database. Introducing this unit of work patterns in our application means that we can commit everything in one transaction. If we are creating a customer updating a customer at the same time as we are creating a new order, we don't have to do that twice and talk to the database and open to different connections. We can do everything in the same transaction and in high performance environments that can be really crucial to the performance off the application. At this point, we are only leveraging the unit of work patterns inside our order controller, because if we take a look at the customer controller, this controller don't leverage to different types of entities or repositories. So there's no need for us to inject the a unit of work into this class here because one of the problems with the unit of work is that from an outside perspective, we might not know which of the repositories in our unit of work that our controller or action or method that we're calling is leveraging in a really large solution. You might break it up and have multiple, different unit of works with only the repositories that makes sense to be changed together, because if you only have one large unit of work and you're passing that into a controller, you really have no clue what that particular controller or action or method is updating. So we saw here that the unit of work pattern is really powerful. It allows us to commit everything in one transaction and the code changes that we did inside the order controller. They are really minimal. We didn't really have to do a whole lot of changes to our solution. We got a lot of bang for the buck when introducing this pattern without a lot of effort.

Summary
[Autogenerated] in this module. We saw how we can apply the unit of work pattern in our application. We saw how we can group our repositories into a unit off work. This will greatly reduce the amount of calls to our database as we can commit the work in a single front section. We've now applied the repository pattern, the unit of work pattern. And we are now ready to introduce the final data access pattern, which is Lacey loading. We're gonna be changing the entities behavior before it's passed back to our controller. We're gonna make sure that we can intercept calls to different properties. We're gonna load some data in runtime only when the consumer request that particular property. So stay tuned for that, and I'll see you in the next module.

Lazy Load Pattern in C#
Lazy Load Pattern
[Autogenerated] in this module. We're gonna be talking about the lacy load pattern in C#. You're watching a C# designed patterns, cores covering the different types, off data access patterns and have to apply that in C# applications. We've already been covering the repository pattern as well as unit off work. Now we're going to improve the application and apply some Lacey loading. We want to make sure that our applications are as fast as they possibly can be. Sometimes this means that we want to avoid load data that's very rarely used, so we don't want to eagerly load data in the application. But rather, we want to apply these Lacey load principles to make sure that we can load things, for instance, from third parties or from a database only when someone requests that particular property and Lacey load patterns come in four different flavors. We have Lacey initialization, virtual proxies, Valley holders and ghost objects. And, of course, we're gonna be covering these different flavors off the lacy load patterns in this module. We want the customers in the application to have a profile picture, but we only want to retrieve the profile picture for this particular customer as we are accessing that particular property

Lazy Initialization
[Autogenerated] The whole idea with lacy initialization is that we only proceed to initializer our backing field to a exposed property the first time someone tries to access that particular property. We saw this earlier in the course when we did this inside our unit off work class, we lazily initialized our different repositories in the unit or for class. Now we can apply the same principle inside our application, but instead of lazily just initializing a particular class, we're going to fetch some data that could potentially be a little bit more often expensive operation. So, as an example of that, let's first look at how we can introduce a profile service to load a profile picture for one of our customers based on the customer name to use lazy initialization. We simply check if our profile picture has been initialized. If it's not initialized only once, we're gonna go off, for instance, in this case to talk to our profile picture service and get that for that particular person. This might go ahead and load that from a database. It might go ahead and load that off the web from a third-party, or it might load that from disk so the lazy initialization only loads the data when the value that we're trying to access is not all that we try to load the data. The problem with this approach is that the entity needs to know about how to load that particular data. Imagine if this is a database call. That means that our customer entity needs to know about how to communicate with the database. But before we introduce one of the other Lacey load patterns, which will fix his code smell, let's head into Visual Studio and see how we can apply lazy initialization in our application. And introducing this pattern is rather simple. First, we want to make sure that our customer can now have a profile picture. To do that, we'll simply just add the profile picture property to our customer. When we run the application, it will run through the migration's off the database and make sure that we get the profile picture column in our database as well. But we want to make sure that we can lower the profile picture if it hasn't already being initialized, and we want to make sure that we load that off a third-party service for the purpose of this demonstration, though I'm not gonna leverage any third-party libraries. But we're gonna fake that and introduce something called the Profile Picture services now because these I'll Azure initialization pattern requires us to know about the particular services inside our customer entity. We need to add our profile picture service to our domain project. In reality, what our profile Picture Service allows us to do is look for a profile picture based on some kind of look up. Could be the email address or the customer name, depending on the type of system that you're integrating with. Just to make it simple, I've added a simple picture off myself as a base 64-bit string, and I'm simply returning that as an array of bites. So now if we save this here and go into our customer entity, we now want to leverage lazy initialization to retrieve our profile picture. Only once, though, if it hasn't already been loaded. In order for us to do that, let's just convert these auto property into a property with the backing field. So before we go ahead and leverage our profile pictures, services we can, see here that if we have the particular data stored in our database entity framework would proceed to set this profile. Picture property wouldn't lose the data. But if someone requests our profile picture and it hasn't already been cashed in the database we want to proceed to loathe is from our profile picture services. The laser initialization pattern requires us to first check if we initialized the backing field of this property. If we haven't initializer profile picture, we'll proceed to low that off the service. Now this here will just simply fetch the data out of our profile pictures services. There are countless of things that we would potentially want to improve here. We would like to handle potential errors and so forth, but to keep it simple, let's just focus on the lazy initialization pattern. Now, once we've loaded the profile picture out of our service, we've set that to our local backing field. And now we can return this value back to whoever is calling our profile picture. What's great here with this pattern is that we are now only loading the data from our profile picture service. The first time someone requests the profile picture off our customer. So to make sure that this works. Let's set a break point in our getter and let's make sure that we used to profile picture somewhere in the application. Preferably. We used the profile picture when we're listing our customers. So we'll go into the web project and we'll go to our customer UI. So we cannot take our bite array that we get out of our profile picture property on our customer. You know that will proceed to talk to the service and load that we then converted back to our base 64 string, and then we display that as a base 64 image on our website. So let's run this with the debug attached and see what happens. So we've started off at a clean slate, will proceed to create an order which will also create our customer and see what happens. And as we request to create the order, something seems to be triggering, requesting our profile picture, and therefore it's going to go ahead and requested profile picture out of our profile services. We're going to proceed to run our profile picture service and get the profile picture for the name Philip Ec Berg. What's interesting here is that if we check the call stack we can see here that this originated from our order controller, where we request to create a new order in our system. Because what this is doing is that it also creating our customer. And when entity framework asks for that particular property, it's gonna go ahead and call the getter on our profile picture property. This means that when you save this order with the associated customer, this will proceed to call our profile picture service. So if we simply release the do ______ now and go back to our application to then request all the customers, we can see here that we're now inside our profile picture property again, If we hovered the private value off our profile picture we can see here that this value was loaded by entity framework. So this value was cashed in our database, and this might be a lot of data that you don't want to pull out of your database all the time. So what happened here is that we got a cache for our profile picture, but we're still eagerly loading our profile picture from our database. In fact, I don't want this profile picture to show up in the database at all. I'm simply going to proceed to ignore this property when we're creating the model for this particular entity. So we'll proceed to go into our infrastructure project will go to the shopping context and then we're gonna override on model creating. I'm simply gonna add some code inside my shopping context again. This is energy framework specific. But we're gonna add that here just to prove a point and for our customer entity were simply going to ignore our profile picture. This just means that our data layer, which is Entity Framework, wouldn't care about the profile picture column in the database. It also wouldn't automatically create this column for us, as we've seen previously in this course. So that's exactly the type of behavior that we currently want in this application for that particular property. So now if you rerun the application and we proceed to at any order, this should no longer try to get our profile picture out of our customer entity. So then, if we try to listed customers, that's the first time we're gonna head into our customer entity and proceed to try load our profile picture. If we know However, the private field for our profile picture we can see the at this is in fact not initialized. So we're gonna proceed to initializer this by asking our profile picture service for the particular profile picture. The field is now initializer that we can return that back to the collar and we can display that on our website. This means that we can proceed to only load this profile picture when someone in the application requests it. Previously, when he cache this in the database as well, it proceeded to load this eagerly from the database, which means that we might get a larger memory footprint than we'd really like to. Introducing the lazy initialization pattern in the application means that we might not need to load data that were not necessarily using we can proceed to only load the data and only loaded once once the backing field is not initialized. The biggest problem with lazy initialization and coupling that inside our customer entity is that our entity now needs to know about things that it really shouldn't have to care about. Our customer entity now needs to know about our profile picture services, and I don't particularly like that coupling so up next, we're going to try and fix that

Value Holder
[Autogenerated] we want to improve our lazy initialization off our profile picture. Right now, our customer is tightly coupled with the way that we load the profile picture for that particular customer. The way that we can fix this and make this better is by introducing a value holder. That's an example of how we can use a value holder. Imagine, in this case here, we were now inside our customer repository. We've proceeded to load a customer from our data context, and now we want to specify how to load a profile picture for that particular customer. So when a consumer off our customer entity asks for the profile picture, that property will in fact go ahead and communicate with his profile picture value holder. So all that we're doing here is that we were now setting the profile picture value holder property to a new instance. Off a value holder. The value holder is injected with a value loader. This loader knows how to retrieve the profile picture for that particular customer. The benefit of this is that the customer entity no longer has to know about how to retrieve the data. We can make sure that our repository initializer as our I'll CFT and tells it how to retrieve the data. So let's now jump into Visual Studio and see how we can apply the value holder pattern. We're gonna start off by getting rid of the things that we don't like about the lazy initialization code that we added earlier. First of all, I really don't like that our profile picture service needs to live in our domain project. So I'm gonna proceed to move that across over to our infrastructure project. And we're going to remove that from our domain project because I reckon that our profile picture services really shouldn't live inside our domain project. This, of course, means that our customer can no longer leverage the profile pictures, services what it loads to profile picture. Because if we reference to infrastructure project inside our domain project, we would get a circular references. So how do we proceed to decouple this knowledge of how to load the poor full picture? We're gonna add something to our domain project, which is called a value holder. So at this point, the domain project still needs a way for it to know a little bit about Lacey loading and its capabilities but we're gonna get rid off the particular implementations off things like the profile services. So let's proceed to add a generic value holder to our application, I'm going to create an interface that will dictate what a value holder needs to contain the value holder needs away free to return the value back to the consumer off the value holder. So we're gonna specify way for us to get the value out of our value holder and our get value method could taken object as a parameter so that we have something to search for when we're trying to get this particular value. We then want to proceed to implement this interface with a generic class that we're gonna call Valley Holder Off T. And what our value holder is going to do is that it's going to leverage lazy initialization. So it's going to initializer a private field in our class only when that field is not initialized, and then we're going to proceed to leverage a value loader to load the particular value that this holder needs to hold. So now, if our value off type T here is null, we want to proceed to load the particular value for the parameter that we pass into get value. The value loader can be specified by either using a function creating other classes that we inject into our value loader. But personally, I like to use functions that returns the particular value based on the parameter. So we can introduce that and inject this into our constructor before we can proceed to set that inside our get value method. So we're going to specify that we can take a function into our value holder, which is gonna be our way of loading this particular value. This will take an object and return. The type of tea backed was now we can leverage this in the method that we call get value that we exposed to whoever is consuming our value holder. So the first time you call get value, we're gonna proceed to set our private value field to whatever we can get out off our value loader, and this is pretty much it for our value holder. Now we can proceed to change our customer to leverage this instead of leveraging lazy initialization. So really, what we're going to do is that we're going to replace the private backing field with our value holder. In reality, what we're going to do here is that we're going to expose on I value holder. When our particular customer is loaded through our repository, the repository will initialize the value holder and inject the correct value loader into that constructor. Now, whenever someone requests our profile picture, we're simply going to leverage the profile picture value holder to retrieve the correct data for that particular customer. The domain project doesn't know anything about the profile picture service. So now we need to go into our repository and make sure that we initializer our value holder before we return any data back to the consumers. So we're gonna do this inside our customer repository. But what we really want to do is that we want to override all the different methods that allows us to retrieve customers, because now we want to upend the value holder to the customer instantiate before we return that to whoever is consuming our repository. So we can start off by overriding all we can say here that we're going to leverage our generic repository to retrieve all our customers. But then, for each customer that we're going to select, we're going to append a profile picture value holder this year will now be a new instance off a valley holder of bite array. And here we are going to introduce our anonymous method that will leverage our profile picture services. And the constructor needs a function that takes the parameter and then returns a bi tary. So what we're doing now is that we're simply saying that we have our profile picture value holder for each customer. We were initializing that to a new value holder that knows how to retrieve the profile picture for that particular customer. You can pause the video at this point and try to implement this yourself for the rest of the methods. There's one more thing that we need to do before we run this application. We need to go into our shopping context and ignore our new value holder property. So now, with a d ______ attached inside our value holder, we can proceed to debug the application and see what's gonna happen as we create our order. Of course, it doesn't go into our value holder or our profile services, but as we go to the customers and list all the customers in the system that's going to proceed and go into our value holder for each of our different customers. We have one instance of these value holder per customer. While this implementation here is not thread safe this year. Now, decoupled our profile pictures services from our customer entity. Now, before we proceed to talk about the other types of Lacey load patterns, we can improve this a little bit more and leverage a built in type called Lacey Off T. If we go to our customer entity and instead of using our I value holder off bite we can instead used the lacy class, which is a generic class that allows us to lazily retrieved data using this value holder pattern as well. The difference between Lacey Off T and our value holder is that Lacey f t will be thread safe, and this here exposes a way for us to, for instance, retrieve the value or check if the value has already been created. And, of course, this requires us to change the way that we initializer our profile picture value holder. Instead of creating a new value holder, we're gonna be creating a new Lacey off bite array, and this here doesn't take a parameter, but instead we can leverage the customer that we're currently processing and pass that into the particular profile service. There were no leveraging and just as that we refactor the application to use it built in value Holder. But now we understand how the value holder pattern works and how it's implemented internally. So this here gave you another way of introducing a lacy load pattern in your application. The benefit of this approach is that we were no longer coupled to the way that we were loading our data before the data is passed back to the consumer off the repository, we're gonna hook on one of these value holders so that one of the properties on our entity config use of that value holder and lazily load the data as the consumer requests that

Virtual Proxies
[Autogenerated] Another approach is to use something called a virtual proxy. This is simply introducing a class that inherits from our base entity. This means that we now need to mark our properties as virtual that we want to be able to override. Because this principle requires us to override the default behavior off how to access that property. In this case here, the repository will map our entity before it's returned back to the consumer to this customer proxy. This will allow the proxy to intercept the calls to the property and load the data one necessary. This is a commonly applied pattern in things like entity framework. It will apply these proxies to make sure that you can retrieve more data as you try to load that from your different entities. Imagine that you have your order class and the order has a reference to a customer. Then entity framework can automatically set up so that the customer on that order is a virtual proxy. And only when you retrieve the customer or requests the customer, it will proceed to query the database. Now we're inside Visual Studio again, and we're going to improve the application by removing our value holder and reducing the amount of knowledge that the customer needs to have about how things are loaded. So in reality, all that we want is a way for us to retrieve the profile picture, and we can leverage something like the virtual proxy to then return a proxy class from our repository to set this for us. The only change that we're going to make to our customer class now is that we're going to allow proxy classes to override the default behavior off our different properties inside our entity. To do that, we need to mark all of the properties that we want to be able to change the behavior off before they return back to the consumer. Were going to mark those as virtual? What this now lets us do is to override the behavior off how we access and set these different properties. Now. Something to keep in mind is that if you always want to lazily load data and never have that stored in your database, you need to ignore that, for instance, in your data context. But that's not something that your entity or domain models need to care about. That's only something that your data access layer needs to worry about. So now, before this is returned to a consumer, I want to leverage something called a proxy class. This means that I'm going to extend my customer and changed the behavior off when we retrieve a profile picture. So to do that, we're going to go over to our infrastructure project because I want to minimize these changes that I make to my domain project in terms of how things are loaded from a database or how those proxy classes work. So we're gonna keep that in our infrastructure project. I'm going to proceed to add a folder in here called Lacey. We're gonna put things like our proxies, ghost objects and potentially custom implementations off value holders. Now I want to introduce a proxy for my customer proxy classes simply inherit from the model or entity that we want to customize behavior for. So we're gonna inherit from our customer that lives in our domain project. Then we're going to proceed to override the functionality for our profile picture, because the profile picture is what we want to lazily load. Of course, we could proceed to override any off the different properties on our customer now, But let's just override profile picture for now. And guess what pattern we're going to leverage now if you get lazy initialization, you guessed right. So we're gonna start off by checking if the profile picture on the base class is null or not. Just a side note here. If you tend to remove based here and check if profile picture is null, this is gonna end up giving you a stack overflow because you have an endless recur shin. So don't do that. If this is not all, we're going to set the Valley to whatever we can get out off our profile picture services and we're gonna get the profile picture for the customer name and that we get out of our base class as well. And we cannot proceed to return the profile picture. So this year introduced a proxy clause for our customer. So now whenever we get a customer proxy back to the consumer, the consumer doesn't have to know that this is a customer proxy. All that the consumer is doing is that it's requesting the profile picture. Since our repository will intercept this and change the customer to a customer proxy we know how to retrieve the profile picture for that particular customer. So let's now map the customer to a customer proxy inside our repository. Since we pretty much want to map the customer to a proxy for all the different retrievals off a customer, I'm gonna introduce a method here at the bottom that allows us to map our entity to the proxy class. So this method is simply going to take a customer and returning customer proxy. This means that we can now pass in a customer entity and get the proxy clause returned. Remember that our customer proxy inherits from a customer. So wherever we return a customer, we could just as will return this as a customer proxy. So let's proceed to change these, select for our all up here at the top and simply map this to a customer proxy. So what we're doing now is that we're simply saying that for all our customers that we retrieve out of our SATA context, we want to select that and map the customer to a customer proxy because customer proxy inherits from customer. This will work just fine before we can run. The application was simply need to remove the code that's now going to cause a compilation error because we no longer leverage our profile picture value holder. So if we now said a break point inside our customer proxy and run the application we can see here that the profile picture on our base class is not initialized. So we're going to proceed to use the profile picture service again and said the profile picture of his customer. But what's really interesting here is that we're no inside our customer proxy. We released the do ______ and the picture still shows up on the website without having to do any other changes. So everywhere else in the application everything that's using our customer repository and retrieving all of the customers still think they work towards a customer. But in fact, they're working with our proxy classes. I mentioned earlier that this is heavily used within things like entity framework. We can head into our shopping context and we can apply, use Lacey loading proxies or we're configuring our data context. And now, for instance, if we set a break point inside our order controller when we're retrieving all the orders, we'll see something rather interesting. We can See here that this is returning in order proxy. In reality, what this means is that it's going to lazy load things like the customer or the order line items. So this here just automatically introduced the behavior for things in the database and entities that are referenced on our order. Automatically, we didn't have to eagerly low data, but this Lacey load pattern allows us to now get proxies back from our repository. So if we now proceed to request a customer, for instance, or the line items on the order, that would go ahead and query the database for that particular data. So this year just automatically introduced the lacy load pattern on our data layer. So we have great flexibility in our applications where we want to introduce these different patterns and practices.

Ghost Objects
[Autogenerated] Finally, we have something called a ghost object. Now the ghost object is our entire entity in a partial state. And only when you request one of the other properties than the IDE, for instance, it will proceed to load all the data from the underlying data structure. This pattern is a little bit more chatty. It's not used as often as the other lazy load principles you can choose with ghost object if you want to load the entire entity once who acts is one of the properties or if you simply want to load that particular property that you're trying to access. So just as with our virtual proxy, the ghost object will inherit from our customer entity, it will do so to be able to overwrite all of the virtual properties on our customer to make sure that we only load those when we're accessing those particular properties. Now, for the final time in this course, we're going to jump into Visual Studio and have a look at applying a ghost object. So let's proceed to introduce a ghost object so the ghost object will be our customer in a partial state, and in our situation, the partial state is only going to include our customer ID. But it's important, though, that you try to create the database to get the customer IDE out of the database. So you make sure that the actual customer exists. So the first thing that will do is that we were going to introduce this ghost object that represents a customer in a partial state. The ghost object is similar, but not necessarily equal to a customer proxy. The ghost object will know if it's a ghost if it's loaded or if it's currently loading the data for that particular entity. But as this will be a customer in a partial state, we can just simply inherit from our customer to make sure that we have access to the different properties off our customer in order for us to not have to duplicate and code in our application, and I still want to profile picture to be loaded for a particular customer once we request that property. What I'm going to do here is that I'm going to inherit from our customer proxy so we can leverage to of these Lacey load patterns at the same time. The first thing that we need to keep track of is the state of our ghost object. Let's just at an enum to our application that keeps track of the load status off our ghost object. One of these objects can be a ghost. It can be loading and it can be fully loaded. So now, of course, the goats customer needs to keep track off its internal status. It's also good practice to introduce a publicly exposed property that allows you to check if this is a ghost object or if it's been successfully loaded. Now, when we act as one of the properties inside our ghost object, we need a way for us to load the rest of the data for this partially loaded entity. So we're gonna leverage a pattern that we've seen previously where we're going to inject the loader into the constructor off our ghost customer. We know that this is gonna be loaded out of the database, so I know that it's going to return the customer entity or potentially a subclass of that. We're going to store this function inside our ghost customer. So whenever we access something that's not loaded, we can proceed to load the rest of the data for this customer. Of course, we need to set the initial state of our ghost customer, which is gonna be that this is in a ghost state. So just by looking at this now, it doesn't do anything in particular. Everything is still going to be loaded from the database, and the ghost customer doesn't override any particular behavior. So we want to make sure that we can override all the properties on our customer. We've already made all the properties on our customer virtual so we can proceed to override the default behavior off, accessing and setting the data for these different properties. Now that we access the name property, we want to load the rest of our customer. We want to load that from the database, and then we want to map the result to the different properties of our class. But since we need to do the same type of code for all our different properties, let's introduce a method that allows us to simply load the data. First, Let's introduce a method that we call load that simply does all of that force so we don't have to repeat ourselves. The first thing that load is going to do is check that we're still in a ghost state. If this is still a ghost object, we're gonna proceed to say that we're loading the data following this pattern here, we'll make sure that we don't try to load the same data from the database twice. Then we're gonna proceed to load the customer, and we're gonna use to function that we passed into the constructor off our ghost object. We can then proceed to map the properties from the result on the customer to everything that we have on our base class. This means that our ghost object is no longer in a partial state. So now if we go back, up to our name property we can, see here that we now call load. And once we've loaded all the data, we want to return the data that we just loaded for that particular property back to the consumer off his property. And of course, we really want to do the same thing in our center. We want to first load the data just to make sure that the customer is no longer in a partial state. So now we have our ghost customer. It inherits from our customer proxy which will allow us to retrieve the profile picture. We have a way for us to override properties to allow us to low data only when we access that particular property. And I'd recommend that you pause the video and implement this functionality for all of the rest of the properties inside this class. All that's left to do now is to head over to the customer repository and make sure that we return a ghost customer whenever we retrieve a particular customer in the system. So to do that, we're going to over I get in our customer repository, we're going to proceed to only load the customer IDE out of the database, which makes sure that this customer actually exists. So now we've selected the customer IDE for a customer in the database. If this here fails, it'll throw an exception because it couldn't find a single item in the database. And then we're going to proceed to create a new ghost customer. As you know, this here takes the function to load the rest of the data and to load all the data out of our database. For the particular customer, we can simply leverage our generic repository. So we'll call the base functionality off, get for the same IDE that we passed into this particular method and to make this look like a real customer in a partial state, I'm going to set the customer IDE to whatever we loaded out of the database. If we now said a break point inside our ghost customer class and we rerun the application, the current status of our object is that we are in a ghost state. This means that we're now going to proceed to try to load the data. And of course, this is going to load the entire customer, and we now have a full state off our customer. It, of course, then goes ahead and loads are profile picture as well, and the application works as expected. The consumer off our customer repository don't know about this particular ghost object. He doesn't know that it inherits from the customer proxy, which in its turn inherits from the customer. So leveraging these different patterns gives us great flexibility. We can use these different lazy load patterns together, and we can create a lot of very specific functionality inside our classes to make sure that the applications that we write behaves fast in the way that we expect them to. We could, of course, make sure that we only load the name from the database if we query that particular property. But doing one call for each property that you try to access on a normal entity like the customer doesn't really make any sense and probably doesn't make your application a lot better, although leveraging these different Lacey load principles will make your application very flexible.

Final Words
[Autogenerated] this module covered how to apply Lacey load principles in your applications. We saw that we can. Make sure that we only load necessary data in depending on the situation that you're in. You have different patterns that can be applied in your particular situation. Lay CFT provides great flexibility, and it's very easy to use. And most are EMS, like entity frameworks and and hibernate comes with lacy loading built in. Thank you so much for watching this course. We've been covering the different data access patterns and how to apply that in C#. We've looked at introducing the repository pattern unit of work as well as Lacey loading. Not only will this allow you to apply these principles yourself, but you can now also identify where these patterns and principles have been applied in current applications or in packages that you leverage as well. So thank you so much for watching this course. This has been one of the C# designed patterns courses. My name is Filipek Berg and I will be here to answer any of your questions in regards to the data access patterns