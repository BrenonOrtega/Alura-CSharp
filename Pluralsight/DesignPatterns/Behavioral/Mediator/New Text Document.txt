Course Overview
Hi everyone. My name is Steve Michelotti. Welcome to my course, C# Design patterns: Mediator. I am a software engineer and technologist, and I work at Microsoft. If you're a C# developer who wants to learn more about design patterns, then you're in the right place. The mediator pattern provides a way to encapsulate interaction and communication between multiple objects and to do this with loose coupling regardless what type of application you're building. In this course, I'm going to cover everything you'll need to be extremely productive implementing mediator patterns in C# on day one. Some of the major topics that we will cover include understanding what the mediator pattern is and why we care about it, implementing your own mediator patterns, multiple variations you might encounter with the mediator pattern, and even more modern implementations of the pattern with the mediate are open source library. By the end of this course, you'll be familiar not only with all the basics of the mediator pattern, but also several variations on the pattern. Before beginning this course, you should feel comfortable with C# and have some basic experience with introductory data structures. I hope you'll join me on this journey to learn how to use the mediator pattern with C# Design Patterns: Mediator course, on Pluralsight.

Mediator Pattern
The Mediator Pattern
Hi, this is Steve Michelotti. Welcome to my course on the mediator design pattern using C#. Expanding your knowledge to include the canonical design patterns in object‑oriented programming will be a beneficial tool in your toolbox as you progress through your journey as a developer. I'll start out with a conceptual overview of the mediator pattern itself, what it is, and why we'd want to use it. We'll then jump quickly into code, and I'll show you a simple structural example first, followed by an implementation of a more real world example. After we implement the structural example, I'm going to show you multiple examples of a mediator pattern in practice so you get better depth on the various contexts in which you might observe the mediator pattern in the real world. Okay, first things first. What is the mediator pattern? Why do we care? What is this useful for? A mediator pattern encapsulates how objects interact and communicate with each other. This pattern promotes loose coupling of objects to avoid an ugly dependency graph. The mediator pattern enables objects to avoid referring directly to each other by encapsulating communication in a central mediator object. Imagine we had 10 or 100 or even a 1 million objects that each needs to communicate with each of the other objects. If each of these objects had to refer and communicate to all other objects, this will get ugly in a hurry. We'd have to keep track of all object references across all objects and keep them in sync at all times. Not an easy task. But with the mediator pattern, we create a central mediator object. This single object has the sole responsibility for maintaining the references to the objects in our network, and I'm using the term network conceptually here. And it is also responsible for relaying any messages or communication between and to these objects. You can think of a mediator sort of like a communication hub. A mediator pattern commonly consists of these four components, a mediator, a concrete mediator, a colleague, and one or more concrete colleagues. The mediator defines the communication between colleagues, and it's typically an abstract‑based class, meaning it can't be instantiated directly, but must have another concrete class inherited. The concrete mediator inherits from the base mediator and implements the communication that was essentially defined by the contract or base methods in the mediator. A colleague is typically an abstract base class that represents a related collection of objects. It references only its mediator and communicates with it. You can think of this as bidirectional between the mediator and the colleague. The concrete colleagues are simply different types of sub‑classes that inherit from the abstract colleague base class and defines specific behavior. Just one more thing I want to interject here. What you see here is a very close match to the canonical mediator pattern originally defined in the Gang of Four book. But remember, patterns can have many different variations. Patterns are just guide rails, not prescriptive implementation rules that are set in stone. So, for example, you could define a class to be some sort of mediator and another class to be some sort of colleague without the need for the mediator and colleague objects having to inherit from an abstract base class. And you'd have no problem convincing me that that's a valid mediator pattern. Remember, these are just patterns, not strict implementation rules. Many different implementations are acceptable. And remember, one of the main benefits of the mediator pattern is the ability to encapsulate object interaction with loose coupling between objects. Now that you have solid background context for the mediator pattern, let's start diving into code.

Implementing the Mediator Pattern
It's time to build our first Mediator, and we're going to start out with a somewhat contrived Structural example before diving into some real‑world examples. Here I have a simple .NET Core 3.0 console application in Visual Studio 2019 with nothing added except the default Program.cs. Let's create a folder called Structural. And if anyone wonders how I created that folder, I'm using the Add New File Visual Studio extension, which allows me to create folders and new files very quickly without having to do a bunch of right‑clicking, so you'll see me use that several times during the course. Let's now add a file called Mediator.cs to that new folder, and in here I'm going to add a method called Send. This is just an abstract method, and we have to make the class abstract as well. Now it wants us to add a class for Colleagues, so let's do that. Similarly, let's make this abstract. In here, you can see I've added a little bit of implementation. The first thing is that we have a constructor for the Colleague that takes in a mediator and sets that on line 15 to the protected member on line 11. Remember, you heard me mention before that the mediator knows about all the colleagues and each colleague knows about its single mediator. Then you're gonna see I have a Send method which will send messages to that mediator, and we have an abstract HandleNotification method at the bottom. Think of this as when we need to receive messages, so we have both Send and Receive. Let's add a concrete Colleague that inherits from this abstract Colleague class. We have Colleague1. Let's inherit from Colleague. We have a red squiggle because we need to implement a few things on the abstract class. First, let's generate that constructor. Second, we have to implement the abstract class itself. The shortcut I've been doing here is Ctrl+dot. So I'm going to do Implement Abstract Class. And then we have to provide some implementation in HandleNotification, and very simple here, I'm just putting a Console.WriteLine that Colleague1 has handled the notification. Let's create Colleague2 that does the exact same thing, except we'll just change the method slightly. I'm gonna copy and paste to make that happen. So just copy and paste Colleague1 to Colleague2, change the message, and we'll move that to its own file. Now let's implement the ConcreteMediator. We're going to inherit from the abstract Mediator. Let's implement the abstract class. Basically, we have to implement the Send method. Before we do that, let's make sure we have references to Colleagues. Now I'm doing this in a pretty structural and mechanical way, I'm just explicitly referring to Colleague1 and Colleague2. We'll see some different ways we can do that in a few minutes, but for right now I'm making it super explicit. Now let's implement the Send method. What we can see here is that to send a message, if it's Colleague1 sending it, the Mediator says, send it to Colleague2, we'll let them handle the notification. The HandleNotification when we invoke that is essentially Colleague2 receiving it. Similarly, if it's not Colleague1, that must mean it's Colleague2, so we'll let Colleague1 handle it. It's like them sending messages to each other. Now let's go back to our Program.cs to use all this. Let's instantiate the ConcreteMediator. Then we have to have some new Colleagues. I'm just going to instantiate them directly, c1 and c2, notice we're passing the mediator into each Colleague. But we also have to make sure the mediator knows about the Colleagues. So you can see here is where we're setting up sort of the bidirectional references, so to speak. With that in place, we can send messages. So, for example, c1 can send a message and c2 can send messages. Let's go ahead and run this now, and you can see Colleague2 receives a notification message, the message was, Hello, World from c1, and c1 receives a message, hi there, which was from c2. This Structural example was really close to the original pattern that was introduced many years ago, but there are alternatives to consider that we'll examine next.

Alternative Considerations
An important thing to keep in mind, and you've heard me mention this before, is that these are patterns, not prescriptive code examples that can only have one true correct implementation. You'll see slight variations in the patterns, and it's important to be able to identify them as different variations that can have their own pros and cons. Let's change our initial implementation a little bit. Now, one thing about our original implementation was that the concrete mediator had explicit references to Colleague1 and 2. Well, this is great if we want to be super clear on what the colleagues are, but it's not so good if we're not sure how many colleagues we might have. What if we have 10 or 100? I don't necessarily want to add 100 properties for that. So we're going to add a Register method to the mediator and provide an alternate way to set up those bidirectional references. In a base Colleague class, I'm going to comment out this constructor. Before I comment it out, I copied it to my clipboard. Rather than just deleting the constructor, I'm going to leave it in there, comment it out, so for the people that download the course code samples, they'll be able to recreate everything I've done. Now the reason I copied it is because I actually want to create an explicit method here and just rename it. We're going to make this internal, and we're just going to call it SetMediator. So basically doing the same thing, but not a requirement of the constructor anymore. Then for Colleague1 and 2, we can comment out the constructor. Now back in the ConcreteMediator, we're going to comment out these two explicit references, and I'm going to replace it with a list of colleagues. Now we're going to add a method to register new colleagues. Now we have one place where we can set up the bidirectional references. We're going to call that SetMediator method that we just created and add it to the list of colleagues. Now let's scroll down to this Send method and let's comment out the original implementation. Again, normally I would delete it, but I'm just commenting it out because I want you to be able to recreate all my code. We just need to send the notification to all colleagues who aren't the current colleague. And we can just do this with one line of code. So we're still invoking the handle notification. What's happening here is we're saying where it's not the current colleague that is sending the message, find all the other colleagues, essentially foreach over all the other colleagues, and invoke the HandleNotification method. Now let's flip back to our Program.cs, we can comment out these two lines. We also don't need the mediator sent into the constructor anymore, and now we can just call the Register method. Let's run the code to make sure it all still runs exactly as it did before. And sure enough, behavior is exactly the same. This has made things maybe a little bit more elegant, but we haven't necessarily saved any lines of code, but it does give the colleagues control as to if and when they register themselves with a mediator. Let's look at a slight variation where we delegate not only the establishing of the bidirectional references to the mediator, but also the creation of the colleagues. So back in the CreateMediator class, we already have the Register method. Let's add a new method called CreateColleague. Now notice we're using generics where T is some type of Colleague object, and we're saying T has a default constructor, which enables us to do this. So we are delegating the instantiation of that colleague to this method. Now we can invoke the SetMediator, and we can, of course, also add it to the collection of colleagues, and let's return it. Now when we go back to Program.cs. We can comment out all of this, and let's see what we can do to replace it. Now we just have two lines of code. One will create the Colleagues c1, we're telling it what type we want to create, it encapsulates all in one place the creation and the setting up of the bidirectional communication. Let's run this again to make sure the behaviors are the same. And sure enough, it is. Remember, these are just patterns. There's multiple ways to do things. In reality, you're going to see different variations of this pattern across different code bases, so it's good to be aware of some potential variations you might see.

Mediator Example - Chat App
Now that we've looked at a mechanical structural example, let's use a paradigm that's a little more real world. Let's revisit the diagram I showed in the beginning when we were looking at the structure of the Mediator pattern, but now you can see we've got some real‑world constructs here. The Chatroom will be the abstract base Mediator, and the TeamChatroom will inherit from it and be where we implement the primary code. The Chatroom has a reference to all team members in the chat, and the team members are the colleagues. We can have different types of colleagues. The Developer and the Testers are all concrete colleagues. They inherit from the TeamMember base object and represent different types of team members or, in this case, different types of colleagues. Here I am back in Visual Studio. We're going to take this code and we're going to set it aside. I'm going to use the Extract method, and we're just going to set it aside into its own method. Again, I'm not going to delete it because for the people that download the course samples, I want them to be able to recreate a whole course. But let's collapse it, and we'll set it aside so it won't be a distractor for our next example. Let's make a new folder called ChatApp and let's add a class to it called Chatroom.cs. Let's make this abstract because it's our abstract Mediator, and let's add some base methods. We'll register a new TeamMember, and Send will be sending chat messages. Let's add the class for TeamMember. Let's make this one abstract. This is our abstract colleague. We're just going to add a constructor that sets the name of a TeamMember, and then that's a read‑only property for name on line. 16. Now let's use a similar technique we used in the last structural example, where we'll essentially use a setter method to set the Mediator, which is a Chatroom for this colleague. And this Chatroom member, doesn't exist yet, so let's generate it. You can see it generated it and put it on line. 11. Now we need the Send and Receive methods. Send will just be sending a message to the mediator, in this case a Chatroom, and Receive will be like receiving a chat message. Now that we've implemented our abstract base classes, let's go implement our concrete classes, starting with our concrete Mediator. Let's inherit from Chatroom. Let's implement the abstract class. Let's add a private list of team members. Let's implement the Register method next. Once again, you'll see the bidirectional references being set up, similar to what we did before. Now we'll put code into the Send method. Simple loop over the members, invoking the Receive method of each one, sending in a message. Let's also add a convenience method to register multiple team members at once. So instead of just one Register method, which we can see on line. 13, what I'm doing here on line 24 is, I have a RegisterMembers method, which takes any number of team members, loops over them, and invokes the Register method that's on line. 13. Now let's add a concrete colleague. Let's start by adding a Developer team member. This will inherit from TeamMember. Let's generate the constructor and override the Receive method. And let's put some code in here for the Developer. We're just saying the name of the developer receiving the message. You can see I'm using the nameof operator there just to show that it is a developer and they've received it. And then we'll just maintain the call to the base class Receive, which simply outputs the message. Let's copy and paste this entire class and make a Tester team member. So this class is called Tester. I've renamed the constructor for Tester. In the nameof operator on line 30 we've added Tester. And let's add this to its own cs file. Now back in Program.cs, let's put the code in for our initial chat. Now, just put in a bunch of code here, so let's walk through this one by one. First off, let's revolve the namespace to get rid of the red squiggles. On line 11 I've instantiated a new chat room. Lines. 13 through 17, I'm creating five team members. The first three are developers, Steve, Justin, and Jenna. And the last two are testers, Kim and Julia. And then on line 18 I call the RegisterMembers method, where I can send in any arbitrary number of team members. That's the convenience method that just allows us a view that with one line of code. Then Steve says, Hey, everyone we're going to be deploying at 2pm. today. And Kim response, Ok, thanks for letting us know. Let's run the app. And sure enough, you can see the first five lines, all five team members have received the message from Steve saying, hey, everyone, we're deploying. And then we have another five lines where all five team members receive the message from Kim saying, okay, thanks for letting us know. Now let's say we want to be able to only send to sub‑team members. For example, let's say we just want to send to the developers, or just sent to the testers. I'm going to come back into the base class here for Chatroom.cs and add a SendTo method. This looks a lot like the Send method, but notice that we have a generic type constraint of T, where T must be a TeamMember. So we're either going to send to developers or send to testers. Back in TeamChatroom, let's implement this. We're going to copy the line 21 from Send, and we're going to paste it right here. But the difference is that we only want to send this to the type that's being requested, either developers or testers. So we're going to use the ofType operator. I should say the ofType method, and I'm going to call ToList on it, just so we can keep using that for each method, which only exists on generic list. And let's make sure the TeamMember class has this as well. So we're just having a SendTo method on the TeamMember, which sends along to the chatroom.SendTo method. We just pass it along to the Mediator, which is the chatroom. Back in the Program.cs., let's see how we can use this. And on line 24 you can see that Steve is just sending a message to his other developers to say, Make sure you execute your unit tests before checking in! Let's run it and see what happens. And sure enough, you can see right at the bottom there, only three lines, the three developers have received the message from Steve saying, Make sure you run your unit tests. Again, this is just to show you some different examples to bring the concepts home. In the real world, you potentially might see some different variations.

Mediator Example - Location Proximity
In our last more real‑world example, I showed a lightweight chat application with the C# Console App. But I certainly don't want to give you the impression that the mediator pattern is only good for chat applications. Let's look at another example where we want colleague objects to communicate their position to each other. This example will be a little more advanced since you're now familiar with the mediator concepts. I'll use a C# Windows Forms application on .NET Core 3, and it will be a slightly generic example, but you'll see how you can apply to different domains. Now I'm actually going to collapse this project here and add a whole new project to the existing solution. We're going to make this a Windows Form App with .NET Core, which now supports Windows Forms. And we have Form1. And you noticed I named that MarkerPositions. We're going to have markers that are the colleagues that need to communicate their position to each other. When one marker is on the move, it'll communicate its position in real time to the other markers. These markers could be vehicles in traffic, airplanes in an air traffic control situation, or a team of people that want to communicate their GPS position to other team members. This will be just a simple example to illustrate the concept. Let's start out by adding a class called MarkerMediator. We're going to dispense with the formality of creating abstract‑based classes and jump right to a concrete mediator. Now I know I just added a lot of code here, but you're actually going to be already very familiar with almost all of it. Line 11, we have a list of markers. Those are the colleagues. We have a CreateMarker method, which, similar to what you saw before, will encapsulate the creation of new markers and setting up the bidirectional references. And we also have a Send method where we're sending the point, that's the location, and which marker is sending it. It's going to loop over all markers, get all markers except for the current one, and invoke the ReceiveLocation method. Let's get rid of some of these red squiggles, starting out with Point. Let's resolve the namespace, System.Drawing. Now the other red squiggles are for the Marker class that doesn't exist yet, so let's create that. I'm actually going to have this inherit from the Label control, which is in the System.Windows.Forms namespace. This is just for convenience of the demo. Now I have a bunch of code to implement here, so let's walk through it step by step. First thing is, you've seen this before. We have a SetMediator method, which sets a private mediator reference. That member is on line 12. This is the constructor for the marker. We're just sending some initial text and some alignment. We're also setting up a couple of event handlers for MouseDown and MouseMove because I'm going to be dragging this marker on the screen. So let's go implement MouseDown and MouseMove next. Let's resolve the namespace for Point. On MouseDown, we need to capture the position of the mouse that is dragging the current marker. In fact, let's move line 28, that member for mouseDownLocation, up to the top just to make it consistent with our other code. So in the MouseDown, that's going to essentially start the dragging operation. We check to see if is it the left mouse button dragging? Yes, set the point. Now let's implement MouseMove. In the MouseMove, we're going to make sure that while we're dragging, the position of the marker is in sync with the dragging mouse. We're going to continuously send the location to the mediator. So line 43 and 44, we're just setting the left and the top. And before that, line 42, we're just showing the text is going to be the XY coordinates of the location. But then on line 45, this is where we make the call to the mediator.Send, very similar to what you've seen us do before. The final step is we need to implement the ReceiveLocation method for the marker so that it can receive location notifications from other markers that are moving. So if we look at the code that I just put in here in the ReceiveLocation, line 51 calculates the distance. The CalcDistance method is actually a local function, which is a relatively new feature that was added in C# 7. CalcDistance is literally just the formula for distance that we've been using since middle school and high school. XY coordinates, we're squaring them, meaning power of 2, and we're taking the square root of that. Once we calculate the distance, we do a check. If the distance is less than 100 and the BackColor is not already red, make it red. Also if the distance is greater than 100 and is not already green, make it green. Now this is coming along pretty well at this point. So now we just need to implement the actual form. Our mediator and our colleagues are basically complete. I'm going to flip over here to the form, and the form is going to host the mediator. So we've got the MarkerMediator, and we're also going to add a button. Notice I've called it addButton. When we click it, it's just going to add a new marker. Let's add some code in here to theForm1 constructor. Now the code I just added, I'm just sending some basic properties of that addButton. We're instantiating it. We're adding a click handler. We just set the text of the button to say Add Marker. And we're just docking it to the bottom of the form and adding this addButton to the control itself. So nothing that interesting here, just setting up the button. So the last thing is we need to implement this OnAddClick handler. And we just make a call to the mediator.CreateMarker. At this point, m is the variable for the marker, and we're adding it to the form itself. At this point, it's already got the bidirectional references set up between itself and the mediator. Every time we click this button, a new marker will be added that's already registered with the mediator. And like I said, we'll add it to the form. Now we've added a lot of code here. Let's go run it and see it in action. Let's make sure to set this as my startup project, and now we can run it. Okay, here's my form. It doesn't look like much so far. You can see we have our Add Marker button that's docked to the bottom. Let's go ahead and click it. And when I do that, we have a marker that's added to the top saying Drag me. I can drag it around. And as I drag it, you can see the X and the Y coordinate is changing. Now let's add another marker or another colleague. Now as I drag this one, we can see that if it's more than 100 away, the first one turned green. As I get closer, it turns red. Faraway green, closer red. You can see we can move it all around the screen. It's getting those instant notifications. So let's move that about right here. Let's keep it green. Let's add another marker. Now they are both turning. So we can see red, green, depending on where it is. Both of these other colleagues are getting real‑time notifications as this is being dragged around the screen. So let's leave this one right here, let's say. Now they're both green. Let's add another marker. Sure enough, you can see all these colors changing. Let's leave it right here, and we can add one final marker. And as you can see, all of them are changing. All these colleagues are receiving real‑time notifications as this is being dragged around the screen to where this location is. This is just another conceptual example to demonstrate how you might incorporate a mediator pattern into different types of C# applications.

MediatR
In the last couple of years, there is an open source library that has risen in popularity in the C# world called MediatR by Jimmy Bogard. It describes itself as a simple, unambitious mediator implementation in .NET. At the time of this recording, the MediatR NuGet package has over 7 million downloads. This mediator library actually has quite a different implementation than the original Gang of Four mediator design pattern. But that's not a bad thing; in fact, that's a good thing. And it further illustrates the point I've tried to drive home multiple times, which is that design patterns are patterns that can take many different forms. If you were building a stateful chat application like the one we've done previously, this library is probably not the library you'd use to do that type of implementation. Where MediatR really shines is processing messages, both send and receive style messages, as well as broadcast or command style messages. And MediatR ensures that these messages are routed to the appropriate places. So you might think of it as a little more of an in‑memory messaging system. The MediatR library can be found here on GitHub, and, of course, on NuGet. The library has many features, and we could do an entire Pluralsight course on just this library, but that's out of scope for this course. The MediatR library is most commonly used in a vertical slices architecture, which I'll show momentarily. But for our purposes here, my goal is not to show you how to use the entire MediatR library, but just to give the most basic introduction, so you get some exposure to yet another flavor of the mediator pattern. Before diving into code, let me give a quick sneak peek as to what we'll build. We're going to use an ASP.NET Web API Controller, which has a mediator object provided by the MediatR library. The API Controller will pass a RequestQuery object into the mediator, and the mediator coordinates the logic of what to do next. Specifically, it will pick the correct handler that should be invoked for the current RequestQuery object. The handler will perform the primary business logic to process the request, and it'll return a response message object to the mediator, which the mediator will pass back to the API Controller to be returned. Let me show what I just described with a simple activity diagram. We have our API controller. It's going to have this RequestQuery object, think of it is just like an ID parameter. It's going to send this RequestQuery object to the mediator. The mediator decides which handler to invoke and sends this object onto that handler. The handler does the business logic it needs, creates the response objects it's supposed to create, and sends us back to the mediator. The mediator will then send it back to the API Controller. Let's go ahead and create this now. I'm going to add a new project to my existing solution, ASP.NET Core Web Application. Let's call this MediatRDemo. And we're just doing a simple Web API, so Web API project is the one we want. By default, this has a WeatherForecastController, which we're going to go ahead and delete. And the WeatherForecast object, we'll delete this as well. And we're going to add a few NuGet packages next. There it is, MediatR, 7 million downloads. I'm also going to install the Microsoft.DependencyInjection Library for it to make the dependency injection a little bit easier. I also want to install the EntityFrameworkCore.InMemory library. To make the demo simple, we won't use a real database; we'll use the in‑memory implementation for our database. I'm going to open the Startup class, and in ConfigureServices, which is where we traditionally add middleware, we'll add the middleware we need for MediatR Startup configuration. I'm going to resolve a namespace, so the AddMediatR, just think of it as adding the library to our current project. We don't need to get into all the details, because, again, it's beyond the scope of this course; this is just a gentle introduction. We're setting it up to use the in‑memory database. And ContactsContext is showing the red squiggle because we haven't created it yet. So let's go do that now. And notice I'm adding it to a data folder. Okay, let's have a quick look at the code I added. I'm calling this a ContactsContext. This is just the default Entity Framework DbContext. It's got a constructor on line 12, which takes DbContext options. On line 16, I simply have a DbSet of Contact objects, and then on line 18, I have the OnModelCreating method, and I'm just doing this to put some seed data in my in‑memory database. All of this is very standard Entity Framework code. If this is the first time you're seeing it, there are numerous Entity Framework courses on Pluralsight. For our purposes here, this is just to set up the demo. The other thing you'll notice is we have a Contact class, FirstName, LastName. In fact, you can see at the bottom there, Steve Michelotti, Bill Gates, Satya Nadella. If I scroll down, you can see I put that Contact object right there, Id, FirstName, LastName. If we go back to the Startup file, in the Configure method, I'm just going to put a little snippet of code right here to make sure that the seed data gets called on application startup, and you can see we have the Database.EnsureCreated method there on line 59. Let's just resolve the namespace here. Now it's time to add our actual API Controller. We'll just select Empty API Controller here, and we'll call this ContactsController. We're going to add a constructor and inject an IMediator object into the constructor. Let's generate this member, which I just did on line 15. And, by the way, since this is a one‑liner on the constructor, if we want, we could change the constructor to an expression‑bodied member. Now that we've got the initial constructor in place, I'm going to add a region here for nested classes. The first nested class is very simple. It's a query object that's an IRequest. Remember from the diagram, think of this as the input message, just as a simple property called Id. Query is an IRequest of Contact, so it's basically setting up that it's expecting this type of response object. Now let's actually put in the handler that handles the request. The contact handler is IRequestHandler of Query and Contact. Now that we've resolved our namespaces, our red squiggles go away. So this is where the business logic gets done. It handles a request. In this case, it looks up the data from the database and returns it. We could inject other behaviors here, maybe mapping to different objects, logging, whatever the case may be, this is just a simpler handler that's returning back the response object. Up at the top, we can actually put in our API method now, and what's happening here is we have a traditional API method, Get by id. You can see the query is the input getting it from the route. It just has that id property. And if I scroll over here a little bit, you'll see that it's just getting the mediator object right there on line 24, it's sending the query into the mediator object, the mediator delegates to the handler and returns the result object, which, because of this expression‑bodied member, just gets returned right back to the API. So the Contact result object gets returned. And this is an example of a vertical slice architecture where everything I need to handle this request is all present right here in the file. I don't have to go off to a huge repository class to find the method I need; it's all right here. Let's go ahead and run this real quick. And now we have to set this one as our startup project. And because this is an API app, we're just going to run this from Postman. I'll put the URL right here, api/contacts. Let's run it. And sure enough, the id of 1 was Steve Michelotti. If we change that to a 2, now you can see the result we got back is Bill Gates. Even though I said this was a basic example, I know there were a lot of moving parts here, so you may want to watch this clip multiple times. The main takeaway here is that the MediatR library provides a simple messaging interface to connect request handlers with the appropriate request and response objects. But remember, this library contains many other features, including the ability to handle commands and wiring different middleware behaviors, so I encourage you to explore it more on your own.

Final Words
We covered many aspects of the mediator pattern in this course. We started out with a conceptual overview of the mediator pattern, what it is, and why we'd want to use it. I talked about how the mediator pattern encapsulates interaction between objects. We then dove into code, and I showed a basic structural example of the pattern so you could solidify the concepts. And then we implemented a lightweight chat application for more real‑world concepts. It's important to be able to identify the mediator pattern when you see it and understand how it can apply to different examples. I showed different examples, including location proximity and the MediatR library. If you remember nothing else from this course, remember this. When you think of the mediator pattern, you should think of encapsulating object interaction between multiple colleague objects, and doing this with loose coupling so the colleague objects don't all have to know about each other. This concludes the course on the mediator pattern in C#. Thanks for watching. I hope you enjoyed the course. Deepening your knowledge of all design patterns can have tremendous benefits as you create your own code and consume code of others. I hope this course helps you along your journey. Happy coding.