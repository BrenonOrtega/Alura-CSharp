Course Overview
Hi everyone. My name is David Starr, and welcome to my course, C# Design Patterns: The Null Object, one in a series of patterns courses. Why would you want to learn this pattern? Well, because with this pattern, you can stop writing null checks. That's right, you heard me. Right far fewer null checks and do so safely. I'm a Principal Cloud Architect at Microsoft and have been a strong and consistent supporter of using design patterns where they make sense. I've been teaching design patterns at various levels for several years. You can find me on Twitter @ElegantCoder. This course is going to teach you the Null Object design pattern, when to use it, and how to do so appropriately. Some of the major topics we'll cover include the origins of null. Null checks are often all over our code base. Writing null checks is now a habit with full IDE support. And finally, we'll see how to eliminate the need for null checks using this pattern. By the end of this course, you'll have seen the Null Object in practice. And before the course, you should be familiar with basic C# or some other object‑oriented language. From here, you should feel comfortable diving in to other C# Design Pattern courses. And I hope you'll join me on this journey to learn the Null Object design pattern with the C# Patterns course, at Pluralsight.

Introduction
Overview
Hello, this is David Starr, and I've been running software for more years than I care to admit. One thing I've found is design patterns. They're helpful when talking with other developers about a solution and in solving problems I see in code again and again. A design pattern is essentially a known solution to a commonly recurring problem. In this short course, we're going to look at the null object design pattern and see how it can improve the code we write. First, we're going to start with the origins of null. Where did this irritating little bit of nothingness come from? And then look at the problem that we're going to try and solve around null. Now it may just seem an irritant, but it can have severe implications, and we're going to introduce the null object pattern as a way to deal with nulls and see how that pattern helps us resolve some of the problems in question. And then finally, using null objects in practice will let us see the null object pattern working in live code, of course,

Meet the Null Object Pattern
To even talk about nulls, we need to introduce Sir Tony Hoare, a very accomplished computer scientist whose contributions to the field are legendary. He's renowned for his invention of the Quicksort algorithm, but he contributed far more to computer science, like the addition of multiple languages. He created the null reference in 1965. It was during this activity of creating new languages that he decided to expose a location of null memory to the programmer, and the null reference was born. He refers to this as his billion‑dollar mistake, referencing the amount of money lost debugging, finding, and fixing null reference issues, costing staggering amounts of time and money. So what do nulls do to our code today? How many times do we write this code, particularly in view constructors for web applications, for example, or in controllers? A null check is practically a requirement when accepting nullable arguments into functions or constructors like this. Each null check increases a measure known a cyclomatic complexity, which is simply a measure of the number of logical branches in your code. Bigger numbers are bad. At this point, we've got a cyclomatic complexity score of 2, and we haven't even written anything useful yet. And how many times have we done this and seen it in our code? We have to be careful, right? What if an object property we depend on is null? What's our cyclomatic complexity score now? I'll leave that to the viewer to research for fun, but it's clear that our code complexity is rising, and we haven't even written anything truly useful yet. The program calling Person.Render may not know that the Person object needed for rendering has not been initialized. This is a recipe for a null reference exception to be thrown by the PersonView class or to implement some other horrific workaround. But what if there were a default implementation of the Person class? Let's call it NullPerson, and it was always used in place of a null person value instead of letting that value be null within the PersonView. In other words, PersonView can use the NullPerson type in its render method and not worry about getting a null reference exception. One way to implement a NullPerson is shown here through inheritance. Another way to structure the NullPerson would be for it to implement a common interface used by the Person class. The NullPerson would just provide a default implementation. Let's see this in a little code. Using the interface method of creating a NullPerson object just means that we're essentially going to return some default values that will not cause the null reference exception when it's referenced in code. The First and LastName properties will always return something. In this case, my name. This is why every time I think of a null object pattern, it makes me think it might instead be named default object pattern. Nevertheless, having the null object to use is only the first part of the story. The real goodness happens when our recipient of a person type can always depend on the person being non‑null. Now we don't need to perform any null checks, our code complexity score drops, our code comprehension increases, fewer lines of code are needed. Nirvana, right?

The Null Object Pattern in Code
Let's make this a little more tangible. The proof is in the pudding, so let's see null objects in action in real code. What we have here is an emulation of a typical MVC style pattern that you might see in a website. In our case, however, the views are not going to create web pages. They're just going to print straight out to the command line. Also, our scenario is simply that we have a learner browsing the Pluralsight website, and we want to get information about that learner so we can render information about them in the top right‑hand corner where one would normally click to get more information about their account. We start by instantiating a LearnerService, and then on that LearnerService we call GetCurrentLearner. We take that learner, pass it into our LernerView, and then ask that view to render. It's that simple. Let's go ahead and run it just to see what happens. Well, it ran really quickly, and we see that the User Name is David and the Courses Completed is 83. Now, how did all that come together? Let's first come up and look at what a learner is. Notice that this Learner type is implementing the ILearner interface. It does have a constructor, which takes an Id, UserName, and the number of courses this particular user has completed, and it makes those available via properties on the class. Let's have a look at the LearnerView. Remember that the LearnerView takes as its constructor argument a learner. And what's it going to do? Of course, we're going to check right away for nulls. We're going to check if the learner herself is null or if her username is null. Wouldn't it be great if we didn't have to do that? Finally, let's look at the LearnerService. The LearnerService has some comments that I'm using to represent code that would normally go out maybe to a JWT token and look a claim that has the user ID in it or by some other means look up the ID of the learner. In our case right now, the learnerId is 1. And that was David, as we saw earlier down at the bottom of the screen when we ran our code. The learner is calling GetLearner with the ID number from a repository. If that learner is null, it throws a NullReferenceException. So we've got three places in our code where we're throwing NullReferenceExceptions, and rightly so using our standard programming models. Let's go ahead and close this and look at our repo. Our repo is simply an internal class that builds up some learners in memory and allows us to retrieve them by passing in the right ID. If a learner exists, then we're going to return that learner. If that learner does not exist, your repository call returns null. Now, what happens when we change our learnerId to 2? Let's run that, and we can see that Julie has completed 72 courses. If the ID is 3, we're going to see that Scott has created 92 courses. But what if we've just got someone browsing the site who's not yet logged in? The lookup for the ID might, in this case, return a ‑1. And when we run with that ‑1, we're going to get a NullReferenceException, as one would imagine. So we can see that on our LearnerService class right here where the exception is being thrown. So what might we do instead? Well, what if we had a null object to return instead of throwing that NullReferenceException? Let's create one. Let's come up here to our ILearner interface and implement that interface with a new derived type that we'll refer to as NullLearner, which is a standard convention for this pattern. We can then come over to ILerner and implement the missing members. We'll take all of them for our ID. Of course, we're going to always return ‑1. For UserName, we're going to return something very identifiable. Let's call it Just Browsing. And then finally, for CoursesCompleted, since we don't know who this is, of course, the answer here is 0. Let's take our NullLearner class and move it to its own file. By convention, perfect. Now let's head back over to our LearnerService, and instead of throwing this null exception, we can return an instance of our new NullLearner type. And in theory, we'll be able to go over to our LearnerView, which receives this learner and take out the null checks. Let's see what happens when we run this code. We can see down below that the User Name is Just Browsing and Courses Completed is 0. This means that we got our null object back by default from our LearnerService. This is a very simple and standard implementation of a null object pattern. And you may be able to see by this time why I tend to think of this as a default object pattern. But again, nevertheless, null object pattern is the name, and people will know what you're talking about when you use it.

Summary
In this course, we looked at several concepts. Use null object to avoid null checks. This simplifies our code, makes it easier to read and write, and decreases complexity. Returned object is not null, meaning when we ask for something, we can be sure that what we're getting back isn't null. Use interface or inheritance as appropriate, or use one over the other as you prefer. Both techniques will typically give you the same outcome. Using the interface technique as we did in our code simply means that our code depth is shallower, thus less complex to read. And we get cleaner code, which is always a good thing. Thank you for exploring the null object pattern with me. I hope it helps you as it has for me in writing cleaner, more concise code.