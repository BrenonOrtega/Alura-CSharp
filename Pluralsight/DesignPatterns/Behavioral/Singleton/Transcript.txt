Hi everyone. My name is Steve Smith, aka @ardalis, and welcome to my course, C# Design Patterns: Singleton. I am an experienced .NET developer, architect, and trainer. My on‑site workshops and Pluralsight courses have helped thousands of developers and teams write better code faster. You'll find me online everywhere under the name @ardalis. Design patterns have fascinated me for years. They're like individual tools you can add to your toolkit as a software developer. They don't take long to introduce, but they can take a lot of practice to master. In this course, we are going to explore the singleton design pattern, one of the most well known, but also most often misused patterns. Some of the major topics that we will cover include what problem is the singleton pattern meant to solve? What are some different ways that we can implement the pattern, both good and bad? Why is the singleton pattern often referred to as an anti‑pattern? And what are some other ways we can achieve the same behavior without using the actual singleton pattern? By the end of this course, you'll be able to recognize situations where the singleton pattern makes sense and be able to apply it, or an alternative to it, with confidence. I hope you'll join me in learning about the singleton design pattern for C#, and I hope you'll continue exploring other design patterns as well, here on Pluralsight.

Applying the Singleton Pattern
Introduction
Hi there. I'm Steve Smith, aka @ardalis. You can find me online at ardalis.com or @ardalis on various social media networks. I also record short developer tips on my podcast, weeklydevtips.com. In this short course, we're going to introduce and learn to apply the singleton design pattern in C#. The singleton pattern is somewhat controversial, so in addition to showing how to use the standard pattern, we'll also look at alternative approaches to solve the same problem this pattern addresses. In this course, you'll learn what kinds of problems the singleton pattern is designed to solve. You'll see how it's structured and how it fits into your existing code base. You'll see how to apply the pattern in real code through a number of different examples, showing both good and bad approaches to the pattern. And when you're all done, you'll also be able to recognize several related patterns and alternatives to using this pattern, which is often considered to be an anti‑pattern. A singleton is a class that has been designed to only ever allow one instance of itself to be created. The class itself is responsible for enforcing this design requirement. Single instances of classes are often required to model some kind of shared resource, like the file system or a shared network resource, like a scanner or print spooler. Other times, while it might be logically acceptable for there to be more than one of an instance, the cost of creating the instance is so great that it's best to only incur the cost once. For performance reasons, the type should only ever be created one time. Also for performance reasons, it's often desirable to only incur the cost of creation when the instance is first requested. This is referred to as lazy instantiation or creation.

Singleton Structure and Features
In terms of structure, the singleton is pretty simple. It's just a single class with a private instance and a public static method that provides the only way to reference that instance. It must also have a private constructor. It will probably have other methods and properties too, of course. These are just the ones that are necessary in order to implement the pattern. The nature of the singleton pattern is that classes that implement it have at any time in the life of an application, either 0 or 1 instance. Singleton classes are created without parameters. If you need a variety of similar instances based on different parameters, you should probably take a look at the factory design patterns. We'll also look at how you can add singleton behavior to such classes using other approaches at the end of this course. For performance reasons, singleton instances are typically not created until something requests them. This is known as lazy instantiation and is the default behavior assumed by most implementations of this pattern. However, it is also possible to simply create the instance you need when the application starts and then use that instance for the life of the app. Singleton classes should have a single, private, parameterless constructor. Because of this, subclassing isn't allowed. To further enforce this intent, and to help optimize the JIT compiler, singleton classes should be marked as sealed. The only reference to the singleton should be in a private static field in the singleton class itself. The rest of the application references the instance of the class through a public static method the class exposes for this purpose.

Demo: Naïve Singleton
In this course, we'll look at several different implementations to implementing the singleton pattern, starting with a simple but deficient approach and working toward better versions. Let's look at a naive implementation first. The typical implementation of the singleton pattern looks something like this. You start with a sealed class. You add a private, parameterless constructor, making it impossible for the class to be instantiated anywhere else. Next, you create a private static field to hold the only instance. And finally, you add a static property to control access to this private static field. To ensure lazy instantiation, you only create the instance the first time it's requested, at which point it will be null. If you're using C# 8 or later, you can take advantage of nullable reference types to clean this up slightly. First, enable nullable either at the project or class level. Next, mark the private static instance as nullable. Then, replace the if check with a null coalescing assignment operator, like this. Recall that this operator will only evaluate the right side of the expression if the left side is null, so it's basically doing the same thing as the if check and assignment that we had before, but more succinctly. Note that we are logging in this class. We use these two log statements and a thread safe logger in the unit test of our code. Let's take a look at those tests. Our test is using xUnit in its ITestOutputHelper, which is being injected and will allow us to see the test output. Our first test checks to see that when we call SingletonInstance, it returns a non‑null singleton instance. You can see that this test is passing, and if we inspect the output from the log, you can see that the Instance property was called and then the constructor was invoked. The second test says that we only call the constructor once, even if we call Instance three times. So in this test, you can see there are three different assignments being made to Singleton.Instance, and we are confirming that there's only one instance of constructor and three counts of the word Instance inside of our log. Again, we can look at the log details to confirm this. First instance was called and the constructor was invoked, and then the next two times only the instance was called. Our third and final test checks that when we call the constructor multiple times in parallel, we get different behavior. So in this case, you can see that we are setting a delay inside the logger. This, in turn, will slow down construction of the singleton instance. We're doing some work to make sure that our parallelism here has a maximum degree of parallelism of 3, so we can run in 3 separate threads when we do this Parallel.ForEach. The Parallel.ForEach in the next block runs and uses that list of three strings to spin up three different threads, and they're going to process the Instances.Add command that adds that Singleton.Instance. When we're done, we assert that we have three counts of instance and more than one count of constructor. It won't necessarily always be two or three. Let's look at the output. In this case, you can see that the instance was called three times and the constructor was invoked three times. Now, why is this a passing test? This test is demonstrating that this implementation of singleton is naive in that it is not thread safe. We would prefer to have our singleton pattern not call the constructor more than once, even in a multi‑threaded environment. The biggest problem with the naive implementation is that it's not thread safe, meaning multiple threads could each enter the if block. The more concurrent threads and the longer it takes to create the class, the more likely multiple instances would be created. Depending on the nature of the class, this might just cause a minor performance impact, or it could introduce substantial problems in the application.

Demo: Thread Safe Singleton
Add thread safety, we'll add locking to the design. Let's look at a quick example. To get around the lack of thread safety, the simplest and most obvious approach is to add a lock. To do this, we create a new instance of an object to be used as a lock variable. We then lock on this padlock instance before performing the check to see if our singleton instance is null. This will successfully ensure that multiple threads will need to synchronize and enter this block of code one by one, ensuring we never have two threads creating the instance at the same time. This approach works, but it has negative performance impacts because every use of the Instance property will now incur the overhead of this lock. It's also worth noting here that if you use locks, always be sure to use a dedicated private instance variable, not a shared public or static value that could be used by another lock elsewhere in the application. Lock instances should be paired one for one with their lock statements. If you look at the test for this, we have some of the same tests as we had before. The most interesting one is the one that calls it multiple times in parallel. Note that this time we've modified the test so that our assertion on line 73 here expects there to be only one call of the constructor, even though we're making these calls in parallel. Looking at the test output, you can see that although Instance was called three times in parallel, the constructor was only invoked once because of our locking. Now let's look at a slightly better way to use locks. In the v3 folder of the demo, you'll find another implementation of singleton. In this version, you'll notice that we are actually checking to see if the instance is null twice, and then locking in between those two checks. This is known as double‑checked locking, or the double‑checked locking pattern. And what this will do is it will make sure that we only fetch the lock when the instance is null, and so that will only happen when the application starts up or when the first request is made to reference this instance. Using the double‑checked locking, we still get the same behavior, our tests still pass, I won't bother wasting your time showing them here, but the only difference is a performance one because now we aren't having to check the lock as often.

Analysis
Let's review. We added locking to enforce thread safety, ensuring only one thread at a time can enter the block in which we create the instance of the class. The first approach worked, but the lock applied to every GET request, even though it's only necessary when the instance hasn't yet been created, and that should only happen one time in the entire life of the application, so we're paying this price for the whole life of the application when we only need it once. The subsequent version is better since it uses double‑checked locking. However, it also has some issues in that it's complex, it's easy to get wrong, and it doesn't necessarily work with the ECMA common language interface specification, the CLI. Jon Skeet describes this concern in more detail at the link shown here. At the end of the day, neither of these locking style approaches work as well as the next ones that we'll see in a moment.

Static Constructors and Singletons
Another approach that doesn't involve locking is to leverage the C# feature of static type construction. C# static constructors run once per app domain, so they are a good tool to consider when it comes to implementing singleton behavior. They are called the first time any static member of a type is referenced. This provides us with some degree of lazy instantiation, although it's not perfect since any reference to any static member, not necessarily our singleton reference, will trigger constructor execution. Make sure you use an explicit static constructor to avoid issues with the C# compiler and beforefieldinit. Essentially, beforefieldinit is a hint the compiler uses to let it know static initializers can be called sooner, and this is the default if the type does not have an explicit static constructor. Adding an explicit static constructor avoids having beforefieldinit applied, which helps make our singleton behavior lazier.

Demo: Static Constructors and Singletons
We can improve performance and avoid locks by leveraging C# static constructors. Let's look at two more approaches, one improving on the other. The modifications to this version of the singleton pattern are pretty simple. First, we add the static initializer to instantiate the singleton right here on line 6 where the static readonly Singleton _instance is declared. Then, we add a static singleton constructor. This ensures that we will not mark this class as beforefieldinit, so it will make sure that it does not instantiate that singleton instance any earlier than possible. However, with this particular design, if we read from any other static field or member of this class, we are going to also initialize our singleton instance. So, the public static readonly string GREETING, if anything in the application references that, it will also result in the instantiation of our singleton. So it's not as lazy as we would like. We can fix this, though, it just requires a little bit of tricky code. This code, this final iteration, is coming from an article that Jon Skeet published on his website, which you can see here at the top of the source code. In this case, we still have a readonly string GREETING, but our static instance now is going to return a nested class and its instance field. If we look here at the nested class, it's the nested class that has a readonly Singleton _instance that it's sharing up to the singleton type that we've wrapped around it. And this type, when it is requested, will only have its initializer called the first time that it's called. Note that there are no other static fields on the nested class, and that's how we get around the issue of accidentally loading it too soon if some other static member on this class is called. Note that we would like to make it so that the only thing that could access that Singleton _instance field is the wrapping class, but we can't mark it as private, so the closest we can get is marking it internal. This is the final version of the singleton pattern that we're going to look at that only uses C# language features and does not leverage other types in the .NET Framework or other tooling that you could use.

Analysis
Let's review the static constructor approaches. They are thread safe, which is good. They don't require the use of locks, so they offer good performance characteristics both at application startup and throughout the life of the application. However, the best solution offered so far, the nested class approach, is fairly complex and non‑intuitive. It's not typically something you would just jump to as your first option when you're going to implement singleton behavior. Let's consider one more approach to implementing the pattern explicitly in our class, and then consider alternative approaches.

Lazy<T> and Singletons
We can also implement singleton behavior using Lazy<T>. Lazy<T> has been around for a while now. It was first introduced in .NET 4 in 2010. It's probably available in whatever version of .NET you're using. It provides a framework support for lazy initialization. When you create a Lazy<T> type, you specify the type and a function that returns an instance of the type. We can use this to implement the singleton pattern.

Demo: Lazy<T> Singleton
Let's look at an example of implementing the singleton pattern using Lazy<T>. To add singleton behavior to a class using Lazy<T>, we follow a similar approach to what we've seen already, but we don't need to worry about checking the instance for null. The Lazy<T> type handles this for us in a thread safe manner. The main difference between this version of the pattern and the original naive implementation is that the private static readonly field is of type Lazy<Singleton> rather than just Singleton. This field is initialized at construction to create a new Lazy<T> instance, and a lambda function is passed into the Lazy<T> constructor with the logic needed to create the singleton instance. The only other point to note is that in our static instance property, instead of just returning the _Instance field that we used previously, we now return the _lazy field's value property. This is guaranteed to never be null and for there to only be one instance of it since it's coming from a static field. When you look at this code compared to some of the other options that we've explored, I think that this provides a very easy‑to‑understand representation of the pattern, and if you do want to implement the singleton pattern in your class itself, this one is very widely supported and has all of the performance and thread safety characteristics that you would want.

Singletons are an Antipattern?
Although Singleton appears in the original Gang of Four book, Design Patterns, many considered the singleton design pattern to be an anti‑pattern. This is because their direct static use in code, as opposed to passing an interface that they implement, leads to tight coupling and difficult‑to‑test code. Classes that follow the pattern also fail to follow separation of concerns and the single responsibility principle because they're responsible for managing their instance lifetime in addition to whatever their real work is. You can learn more about these principles in my SOLID Principles of C# course. If you're going to implement more than one singleton, you're going to have to duplicate all of the logic required to enforce singleton behavior, which means you're also violating the don't repeat yourself, or DRY, principle in your code. Finally, there are other ways to achieve the same goal of the singleton. Some are better than others, but let's look at another common approach first, static classes.

Singletons vs. Static Classes
Recall that in C#, you can declare a class as static. The compiler will then ensure that the class definition only contains static members. Static classes and singletons are often confused with one another, and while they do share some similarities, there are quite a few differences as well. Singleton classes are actual class instances, which means they can implement interfaces. Static classes are just collections of static methods, functions, and until C# supports something like static interfaces, they cannot implement interfaces. Singleton interfaces can be passed as arguments to methods. Static classes cannot. This means singletons can use the strategy design pattern and dependency injection, while static classes cannot. Singleton instances can be assigned to variables, statics can't. Looking at the first three items, this means that Singleton instances can use polymorphism. Static classes cannot, they are purely procedural. Singleton instances also can have state. Static classes do not typically access any state aside from global state, again, because they're static. And finally, singleton classes can be serialized. They can be stored, transferred, transmitted over the wire. Static classes have no support for serialization.

Using Containers
Now, let's shift gears and talk about containers, often called inversion of control or dependency inversion containers, or IoC or DI containers. To be clear, these are factories on steroids that many modern frameworks use to allow widespread use of techniques like dependency injection. And just to be extra clear, they have nothing to do with Docker containers. .NET Core has built‑in support for these IoC or DI containers. You can configure your own or leverage their built‑in service collection. In applications that leverage containers and utilize dependency injection, classes will typically request their dependencies in their constructor. Ideally, all such classes in these applications should follow the explicit dependencies principle, which says that classes should not have any hidden dependencies. Hidden dependencies are only revealed at runtime. Explicit dependencies are exposed by the class's constructor, which lets developers who are trying to work with these classes know up front what they need to provide in order to use the class and its functionality. When you configure a container, you establish a mapping between abstractions and their implementations for this application. For instance, you might specify that for a given IEmailService, you might want to use an implementation type called LocalSMTPEmailService. Later, you might swap this out and instead decide to use a cloud‑based email provider. Making this change can be done solely in the mapping logic of the container without touching any other code in the application. The other job of such containers is to manage the lifetime of the types they create. That is, the container includes logic to determine whether to create a new instance or to reuse an existing instance whenever a request for a certain type is made. .NET has built‑in support for dependency injection and lifetime management. When you register a type and its implementation, you specify what lifetime should be used for that type. The most common lifetime is transient, which means a new instance of the type is provided any time a class requests that type as a dependency. You can also register types with scope dependency. You can define scopes in your application however you like, and any instance requested within that scope will be shared if it's requested again within that same scope. The first request will get a new instance, and all subsequent requests in that scope will get that same instance. In ASP.NET Core, every request that comes in is given its own scope and built‑in tools like EF Core are designed to use a scoped lifetime. Finally, you can specify a lifetime of singleton. Using this option, every request for that type will be given the same instance. This behaves just as if you had implemented the singleton pattern and exposed an Instance property, except it's much more flexible since it supports dependency injection. What's more, your individual classes don't need to be concerned with how to implement singleton behavior themselves, and you can easily adjust the lifetime if needed as your design involves. When specifying a singleton lifetime, you can let the instance be created the first time it's requested lazily, or you can create it up front and add the newly created instance to the service collection during application startup.

Demo: Singleton Behavior with Containers
Let's look at a quick demo showing how to manage singleton lifetime using the built‑in support for containers available in .NET Core. For this example, I'm going to use my CleanArchitecture.WorkerService template available on GitHub here. This repository is a solution template for building .NET Worker Service applications that leverage clean architecture, and it includes everything you need to get started, and it already has dependency injection and tests set up for you. While we're on GitHub, I also want to share the URL for all the samples we've looked at in this course. You can download the demos as a ZIP file from Pluralsight, but any updates or issues others have reported will appear in the repo first. You'll find everything from this course, as well as several other design patterns in my DesignPatternsInCSharp repository shown here. Now, let's have a look at how to configure a DI container in a .NET application that is not a web app. There are plenty of examples available online for doing this with ASP.NET Core applications, so I wanted to show how you can achieve this in any application you write. .NET provides a generic HostBuilder that includes a bunch of features like configuration and logging support. It also includes support for configuring the built‑in DI container that ships with .NET Core. You configure it as part of building the host, which this program does in its program.cs file shown here. The very first line inside of the public static void Main creates the host, and then from there we run that host after we do a little bit of setup. Now all the magic of creating the host is inside of the CreateHostBuilder static helper method. Let's take a look at that. Inside of CreateHostBuilder, we call Host.CreateDefaultBuilder, this is where some of those built‑in services get configured, and then we customize the dependency injection container by calling .ConfigureServices. Here, we are able to add any services that we require for our application. You can see that we're adding certain services as singletons, we are adding other things using helper methods, and if we scroll down, you'll see that there are other options for adding different types of services. So here at the bottom, as you saw in a slide previously, you can see how you can add things with a transient lifetime or a scoped lifetime, or even create a singleton with an instance that you create right here at the start of your application. That's all there is to it to use the built‑in IoC container inside of .NET. Once you have this set up, all the rest of your services can simply request the dependencies that they want, and they will be injected when they are created by the services collection.

Analysis
Remember, Singleton behavior doesn't need to be coupled to the object itself or require the singleton pattern, which simply means that the object itself must enforce singleton behavior. In systems that already use IoC containers and dependency injection, leveraging the container's ability to control object lifetime, including singleton lifetime, is probably the ideal approach. If in your situation it makes sense to implement the singleton pattern in C#, then the Lazy<T> approach shown earlier is probably the most elegant and easily understood approach to use and should work in any modern .NET application.

Demo: Singleton Testing Considerations
Before we wrap up, let's discuss some testing considerations as they relate to the singleton pattern. First, note that in our tests we are making use of both the singleton test helpers and the logger utility. Before each test, we reset the singleton and clear the logger. Then just to be safe, we assert at the start of the test that the singleton instance is in fact null. As you saw earlier, we're using the output from the logger to verify behavior in each test. Let's look at the logger to see how it's implemented. The most important feature of the logger, for the purpose of testing singletons, is that its log is a thread safe, concurrent queue. This eliminates issues with race conditions that, trust me, were present when I was using a simple list. The logger also supports a delay, which is used to force race conditions in some of the tests, as we saw earlier. The two test helpers that I'm using for the singleton tests use reflection to access the private static instance field used in most of the singleton implementations we've reviewed. This is necessary because our test framework, xUnit, doesn't provide a way to fully reset the app domain in which it's running. In fact, app domains aren't even really a thing in .NET Core, but the equivalent of the environment in which the tests are running. The only alternative that I could find was to isolate each test in its own test project, but that seemed overly cumbersome, so this approach was the best that I could come up with. These samples are all MIT open source licensed, so you're welcome to borrow from this code if you find it helpful in your own application development. Finally, let's look at some examples of how to use singletons that may impact testability. The best approach, if you can manage it, is to use dependency injection. Then, the class that's using the singleton has no idea it's using a singleton and just uses its local field anywhere it needs that class's behavior. The second best approach is to pass the singleton in as a method argument. It has the same benefit as passing it in as a constructor argument, but it often puts more work on the client of this code, which can't rely on a DI container to do the work of providing the instance that it needs. In both of these cases, it's best if you can inject an interface rather than a singleton type itself because the sealed singleton type will be more difficult to swap out in a unit test. The worst thing you can do in your code from a testability standpoint is call a singleton directly from its static instance property, and then call a method on that singleton instance that touches infrastructure, like a database or the file system. This will make all of the logic in that method, and potentially any method that calls it, more difficult to unit test. Any call to this method now will fail without the necessary infrastructure being in place, requiring that we write much more expensive integration tests to test this logic where previously a unit test would have easily tested the logic in this method. Note that this is also an example of the static cling code smell, which you can learn more about in my refactoring courses, here on Pluralsight.

Key Takeaways
Here are your key takeaways for this course. A singleton is designed to only ever have one instance created. The singleton pattern revolves around making the class itself responsible for enforcing this behavior. However, it's easy to get this pattern wrong when you're trying to implement it by hand. If you want to implement the pattern as written and have the class be responsible for enforcing its behavior, the Lazy<T> approach that we covered is one of the better ways to apply the pattern. There are many differences between singletons and static classes, the biggest one being that singletons are actually instances of classes. And finally, if you're working in a framework that supports dependency injection and IoC containers, they are usually the best place to manage the lifetime of the instances of your classes as opposed to putting that responsibility in the classes themselves. That's it for this course on the singleton design pattern in C#. I hope you've enjoyed it and that you'll continue your journey learning other design patterns here on Pluralsight. Don't forget to leave a rating, especially if you enjoyed the course, and if you have any questions, you can ask them in the Discussion tab or find me online at one of the links shown here. Thanks for watching, and I hope to have you in class again real soon.