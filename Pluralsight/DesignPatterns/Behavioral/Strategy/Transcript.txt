Course Overview
Hi everyone. My name is Filip Ekberg, and welcome to my C# Sharp Design Patterns course, covering the strategy pattern. I'm a principal consultant and CEO at a consulting agency operating out of Gothenburg in Sweden. I started this company a few years ago and focus on building fast, powerful, and easy-to-maintain solutions. This course is for those of you that want to learn how the strategy pattern works, which is one of the most common used patterns, and how to apply that in your C# applications. We will cover everything you need to know to master this pattern. This includes what the strategy pattern is and its characters, understanding the benefits and tradeoffs when using the strategy pattern, how to implement the strategy pattern in new and existing solutions, as well as identifying and leverage existing implementations. By the end of this course, you'll feel comfortable with implementing the strategy pattern in your applications. This will allow you to build extensible, more robust, and testable applications. Before beginning the course, you should be familiar with the C# syntax and how to build and run .NET applications. No other prior knowledge is necessary. I hope you'll join me on this journey to learn all about working with this very powerful C# design pattern with the Strategy Pattern course at Pluralsight.

Strategy Pattern
Introduction
Welcome to a C# Design Patterns course. My name is Filip Ekberg, and I will guide you through understanding the strategy pattern and how to apply that in your C# applications. The strategy pattern is probably one of the most common patterns that you will encounter. So it's crucially important that you understand how to apply it, how to identify it, and how to leverage that in your applications. So throughout this course, we'll be looking at understanding and implementing the strategy pattern. We'll be talking about identifying and leverage existing implementations be that in your applications, in the .NET framework, or in packages that you might bring in from, for instance, NuGet. And just as with any pattern, it's crucially important that we understand the benefits, as well as the tradeoffs. We really want to get a good understanding of where this fits in our applications and how to leverage the pattern in the best possible way. The strategy pattern can be identified by these three different characteristics. You have something identified as the context. The context simply has a reference to something that we call a strategy. A strategy is simply an interface that defines how to work with a given strategy. Then we have the particular strategy, which is simply a concrete implementation of that particular algorithm. This, of course, sounds fairly simple. And, honestly, the strategy pattern is probably one of the easier patterns to understand, and it's one of those patterns that are very commonly applied in applications even though you might not know that you just applied the strategy pattern. So in a real-world scenario if we translate our strategy pattern into something that we could find in our applications, the context could be the class that simply invokes an operation to get the total tax of an order. So the context simply specifies that it has an IStrategy, and we then set that particular instance at runtime. We can then call our strategy to get the tax for a particular order. Our interface simply exposes our GetTax for a particular order, and then our concrete implementation for different strategies can be how do we calculate the sales tax in Sweden or in the US. Calculating the sales tax in the US is very different from calculating our sales tax in Sweden. So it makes a lot of sense to decouple that from our particular context, and that's one of the main goals of any given pattern, to make your applications more extensible, easier to work with, and hopefully a little bit more testable. Another example of this is when our context, which in this case could be the order, has a reference to an IStrategy that allows us to create an invoice. Our IStrategy simply exposes the contract that allows us to call create invoice for a particular order. Then we have different types of strategies depending on how you want to deliver your order. You can get a PDF, you can get an email, or maybe you want to print this by leveraging a print-on-demand service. Depending on which type of invoice delivery our customer specified when they placed their order, we might decide on this particular concrete implementation for the strategy in runtime. So the context doesn't have to know anything about the PDF, email, or printing services. It simply needs to know that in runtime, we're going to get an IStrategy that allows us to simply create the invoice for our order. The crucial part here is that we can select an implementation at runtime based on the user input without having to extend the class. So the context that we talked about was our order. The order had a reference to a strategy for delivering an invoice. The order doesn't have to know if it needs to ship it, email, or save a PDF to disk. It simply needs to know that it has the capability of creating an invoice. This means that our order class is now decoupled from the particular implementation of how to create an invoice based on what the user selects.

Strategy Pattern: First look
Let's have a first look at how we can improve an application by introducing the strategy pattern. What type of application that you're using is not important in this case. In this particular example, I've leveraged a console application. That's just to make it easy for you to follow along and add a little bit of code on your own. So feel free to pause the video and add some code into the classes to try and follow along when we talk through the strategy pattern. Now in this console application, the idea here is that we are doing order processing. We have this sales system that will process an order. What we want to do is to calculate the tax on our particular order. Calculating the tax is different depending on where you live in the world. And later on in the course, we're also going to talk about creating the invoice depending on what type of invoice delivery our user selects. And then we want to ship the order. And depending on which shipping company our users want to leverage, we might have different APIs that we want to integrate with. And to avoid cluttering our order clause with a lot of implementation details for all of those different types of systems, we're going to leverage the strategy pattern. So let's go ahead and have a look at our program. We're simply setting up a new order, and we're saying that we're going to ship this order within Sweden because what's interesting with Sweden is that when you sell things within Sweden, you apply a certain tax rate. When you sell it outside of Sweden, you shouldn't apply any tax at all. So we need to take care of that when we are calculating the tax for our particular order. Then, of course, we add a few line items to our order. I add my own book, I add some consulting to build a website, and these are different types of items. So we have literature, which might have one tax rate, and we have services, which might have a different tax rate. And then at the end here, we simply want to print the total tax for our order to the console. So while this course isn't, in particular, about implementing tax calculations because that can be fairly complex, we're going to use this real-world scenario to see how we can apply the strategy pattern. Let's jump into our method here that calculates our tax on our order. You'll see here that the method GetTax will return a decimal. The first thing that we're going to check is if the destination country is Sweden or if it's the United States. If it's US, we're going to check if the destination is LA, New York, or New York City because they have different sales tax. Now, of course, the rates might not be correct. But again, this course isn't about the sales tax. It's about how to make this application a little bit more extensible and a lot easier to work with. So this here is interesting because now we have our GetTax method. The GetTax method has the information about how to do the particular computation for Sweden and the US. It's all grouped in here. So in order for us to make this a little bit better, we're going to leverage the strategy pattern. What that means is that our order will be our context. The order will simply hold a reference to a strategy that knows how to calculate this tax. And if we drilldown into the particular implementation for how to calculate the tax for Sweden, we might even want to make this better because in Sweden depending on which type of item you sell, you have different tax rates. That might be applicable to other countries as well. So there's a lot of improvements that we want to make in here, but we don't want to make this method more complex than it already is. And another drawback of coupling all the implementation details for the tax calculation is that it becomes a little bit harder to test each of these different calculations. So the first thing that we're going to do is that we're going to introduce our interface for a sales tax strategy. In our business layer, I'm going to add a new folder called Strategies. Now that I have my Strategies folder, what I'm going to do is that I'm going to add another subfolder where I'm going to group everything that has to do with our sales tax. And here I'm going to add the ISalesTaxStrategy, which will simply dictate the contract for our sales tax strategies. So now we've defined the contract for how to calculate our sales tax. So now we can add a concrete implementation for how to calculate the sales tax in Sweden, as well as how to calculate the sales tax in the US. So I'm going to add two more classes. I'm going to add my SwedenSalesTaxStrategy, as well as the UnitedStatesSalesTaxStrategy class. We'll start off by adding the SwedenSalesTaxStrategy, and this class will implement our interface ISalesTaxStrategy, which will require us to implement the method GetTaxFor a particular order. All that we're going to do in here is that we're pretty much going to copy everything that we had in our order for how to do this for Sweden. So pretty much what we want to do is copy all of the code that we have inside our if block here for when this particular destination is Sweden. Let's take this code out and add this to our SwedenSalesTaxStrategy. And, of course, since we're no longer inside the order, we need to leverage the order here when we are calling these different properties. So this here now implements a way for us to simply get the 25% sales tax across the board for anything that we sell in Sweden. We could, of course, still make sure that the destination or the origin is Sweden. But in this case here, we're going to trust that whoever's leveraging this strategy will only apply the strategy when the Swedish sales tax applies. Let's do the same thing for our US sales tax. Again, we're going to implement our ISalesTaxStrategy. We're going to go over to the order, and we're going to take all the code that we have inside our US block and add this to our new strategy. And just as that, we have now implemented a sales tax strategy for both Sweden, as well as the US. But now we need a way for us to leverage this. We've added the interface. We've added our concrete implementation of a strategy. We started breaking things out of the order. But now we need to make sure that we refactor our GetTax method in here to leverage one of these strategies. I mentioned earlier that we don't want the order itself or, in this case, it's also known as the context to know about the particular implementation. So all that we need to do inside our order is to expose the ISalesTaxStrategy interface to allow anyone to tell the order which type of strategy to use when applying the tax. So let's get rid of our code that we have in our GetTax method. We're going to expose an ISalesTaxStrategy. If we haven't specified a SalesTaxStrategy, what we're going to do is simply return 0 because then we are unable to calculate the particular tax. We could also throw an exception, which would probably be more accurate. But in this case, let's just return 0. And then what we're going to do down here at the bottom is to return the particular calculation that we're doing with our SalesTaxStrategy. We're going to call GetTaxFor. We could, of course, make sure that we only pass the line items. But in this case, I'm just going to pass the order because that makes it a little bit easier, and it was easier for us to do the first step of a refactoring. Whenever you refactor code, make sure that you start off with small pieces. We can then improve the application as we go on. Now if we compile this, we don't have any compilation errors. Our GetTax method now leverages our ISalesTaxStrategy. But we haven't set this to anything yet, so we want to do that. We want to go over to our program, and we want to make sure that whenever we create this order, we want to also set our particular SalesTaxStrategy. So now what we've done here is that based on the destination of our order, we are setting the SalesTaxStrategy. Based on what the user selects, we leverage this behavioral design pattern to set the particular strategy for how to calculate the sales tax. So now if we run the application, the total sales tax is 50 Swedish kroners. Although I know that depending on if it's literature or if it's a service, we have different tax rates. So in order for us to improve that and make this a little bit better, what we can do is now head over to our SwedenSalesTaxStrategy and fix this. I refactored this method to take into account to calculate the total tax for each line item in my order. Food has the tax rate of 6%, literature 8%, and service and hardware is a 25% tax rate. And then we return the totalTax back. And if we then rerun the application. we can now see that the totalTax is 33 kroners. The big benefit for refactoring all of the Swedish sales tax computation into this particular strategy is that it was very simple for me to refactor this to leverage different tax rates based on the item types. It also means that I can more easily write tests for this particular strategy to take into account that other countries weren't affected by this change. I know that the change that I made here is only going to affect orders from and to Sweden. That means that I can be sure that my test for the USASalesTaxStrategy shouldn't fail. So we're able to change the strategy for a particular country without affecting anything else. And, of course, as with other design patterns, the whole purpose of introducing patterns is to make our applications easier to work with, as well as easier to maintain and easier to write tests for. And we've proven all of those points by introducing the strategy pattern. So what did we achieve by refactoring our application to leverage the strategy pattern. We certainly got a more extensible object- oriented and dynamic implementation. This, of course, means that we can now easily add new strategies without affecting existing ones. It also means that our application now has a cleaner approach where everything has a single responsibility in mind. The strategy is only responsible of calculating the tax for that particular country. The order simply leverages our interface to request computation based on the strategy that someone set on that context. So decouple your code and achieve cleaner and a more extensible code base. In our application of a tax calculation, we took this code that was coupled into our order that is potentially pretty difficult for us to test. We refactored the tax calculation to leverage the strategy pattern. We were simply setting the strategy property to our particular concrete implementation of that strategy. And then, of course, we leverage our strategy inside our particular method in the context, which in this case is the order. So by now, you probably understand that when I say that the strategy pattern is one of the most common ones that we encounter, it's because it pretty much covers every case that you expose an interface where anyone can set the interface to a different concrete implementation to change the behavior or strategy of how to perform a particular computation. This pattern is extremely powerful and something that makes our applications a lot more fun to work with.

Strategy Pattern: An Alternative Approach
Up until now, we saw that we can expose a property on our particular order. The strategy pattern also allows to take an alternative approach in order for us to leverage a particular concrete implementation of a strategy. So we're inside Visual Studio, and we're going to look at an alternative approach to setting our strategy. So far, we set it to the exposed property on our context. The alternative approach is to simply pass this into the GetTax method. This means, of course, that we can leverage the strategy pattern for anything that takes an interface. We'll add the strategy as an optional parameter to our GetTax method. If we don't pass the strategy to the method, we're going to use the one that's been set on our particular context. Then we simply refactor the method to leverage the strategy that's either the one that we passed into the method or the one that's set on the context. So this alternative approach gives us an idea that whenever we take an interface in a method, we are pretty much leveraging the strategy pattern. So you're not required to name your strategies with the suffix of strategy. So, again, as you see here, this is extremely powerful and allows us to change the way that the order calculates our sales tax and, based on a behavior in the application, we can at runtime decide on the strategy that we want to leverage for this particular sales tax, which means that this is an extremely powerful pattern. And it's really something that you're going to see a lot throughout your development in C#.

Example: Creating an Invoice
We're now going to look at another example of how to leverage our strategy pattern. We will implement a way for us in our application to choose if we want to create an invoice that's sent over email, stored as a plaintext file on disk, or that's leveraging a print-on-demand service. All of those different scenarios requires us to do different types of implementations. And doing that in the order class and extending that class with that particular logic isn't really something that's going to hold up in the long term. We are inside Visual Studio again, and we are looking at our console application. But you can, of course, apply this pattern in any type of application that allows you to set an interface or a function pointer or any way of replacing a particular algorithm at runtime. So now what we want to do is that we want to allow our application to send invoices. And I want to be able to send an invoice over email, and also I want to be able to call a print-on-demand service that will ship my invoice over normal snail mail. And then, of course, I also want to store this on a file on my disk. So what we're going to do is that we're going to add another section in our Strategies folder. What's interesting here is that we started off with refactoring our sales tax calculation into leveraging the strategy pattern. Now in the application, I don't have any invoicing added. So I'll start off by introducing the strategy pattern because frankly 6 months from now, we might want to add new ways of shipping invoices or change the way of how our invoices are currently being delivered. So introducing the strategy pattern from the start for this particular new feature makes it easier for us to extend this as we go on. So now first off what we do is just like what we did with the sales tax strategy. We start off by the interface, which will expose how we leverage this in the application. Our InvoiceStrategy tells us that we can now generate an invoice based on a particular order. This method doesn't return anything because either it sends an email, calls an API, or writes something to our filesystem. You could, of course, have whichever signature you want. But in this case here, this makes sense for our particular strategy that we've chosen now. So now I want to add a few different strategies. What's interesting with all of my different strategies is that most of them are going to leverage the same base functionality. So what I'll do is that I'm going to add an abstract base class that allows me to create the basic implementation of our InvoiceStrategy. This abstract class is going to implement our interface. But we want to require that whoever's inheriting from our InvoiceStrategy needs to implement the Generate method. So we're going to mark this as abstract. Now whoever's inheriting from our InvoiceStrategy will be required to override the Generate method, which still means that all of them are going to implement the interface for an IInvoiceStrategy. Now the shared functionality that I want across all my different invoice strategies is a way for me to represent our invoice as a string. So for this course, the implementation of how to generate a text invoice isn't really important. All that we are doing is that we are setting the invoice date. We are adding all the items. We are retrieving the tax from our order, and then we are printing out the total at the end. What's interesting, of course, is that order.GetTax will leverage another strategy. So this here is an aggregation of all the data that I want to be displayed in my particular invoice. Now this makes it easier for us to add the concrete implementations of the other different types of strategies for how to ship an invoice. Let's add emailing, file, as well as a print-on-demand invoicing strategy. We'll start off by adding the EmailInvoiceStrategy. Our EmailInvoiceStrategy will simply send an email with our text representation of an invoice. You can see here that I can choose either to implement our IInvoiceStrategy, or I'm going to inherit from our InvoiceStrategy base class. This will, of course, require us to implement the method Generate. So we're going to do just that. We're then going to get the body for our email. I'm going to call GenerateTextInvoice, which lives in our base class. Based on the order, we now have the body for our particular email. And then I'm going to leverage SendGrid to send this email. Now the particular implementation details for how to send an email and leveraging the SMTP client and all of that isn't really important in terms of the strategy pattern. But I find it more interesting when we run some live code that will send me an email, and we see that this, in fact, works. So you'll see here that we have the SmtpClient. We then set the body of our message, and then we send the email. So now we have the capability of sending the invoices on email. Now I also want the capability of saving this as a text file. This course, of course, be saving this as a PDF for the particular user to then download later on. The same thing applies to the FileInvoiceStrategy. We inherit from the base class InvoiceStrategy, which will allow us to call GenerateTaxInvoice. We're going to open a StreamWriter to a particular file on my disk. We're going to get the text representation for this invoice from the order. And then we're going to flush this out and write this to our disk. The last capability that I want is for us to be able to call a print-on-demand service to generate a paper invoice. With the PrintOnDemandInvoiceStrategy what I'm going to do here is not leverage our base class because I'm not going to get a text representation to pass to this particular print-on-demand service. The API that I'm invoking is purely fictional. Pluralsight, at this time, doesn't have a print-on-demand service. But I'm leveraging the HttpClient. The idea here is to serialize my order to a particular object. This would, in most cases, be a completely different model. But this just proves the point of how to use this. We then post this onto our /print-on-demand. We pass the content as StringContent, and then hopefully this will end up in our user's mailbox. What's of course very interesting here with the invoicing strategy is that I've now added an email invoicing strategy, which leverages the SmtpClient. We have the FileInvoiceStrategy, which leverages a normal StreamWriter. And then we have our print-on-demand InvoiceStrategy, which leverages an API. We could, of course, have another one that persists this into a database. So the strategy for how to deliver the invoice can be very different depending on what the end user decides when they place the order. But since we are now leveraging the InvoiceStrategy, this means that our application is now extensible. And it's very easy for us to add new strategies of how to store the invoices or how to send them off to the user. Maybe someone wants them sent by an SMS, and then we can then add an integration with one of the SMS providers. If we had all this code inside our particular order class, this would've been purely terrible to maintain. As we continue refactoring the application, we might find that we want to keep our order much cleaner. And the usage of the strategies might fit more in something like an order service. This would then mean that our order service would become the context. It would leverage our data model, which would probably be the order. And the service layer could then communicate with our different strategies. But you can play around with this yourself and improve the way that you might leverage different patterns to create a very nice solution. We could, of course, leverage other patterns to make the kind of the same approach, but I reckon that this gives us the cleanest way possible to decouple the particular concrete implementations for these different strategies. Now let's leverage this inside our order and make sure that we can invoke one or two of them. Just as we did with our SalesTaxStrategy, we're now going to expose an invoicing strategy. We're only go to send an invoice when we finalize our particular order. So now we're going to expose a new method from our particular order to allow us to finalize it. When we are finalizing the order, we want to check if we have any selected payments that is of the type invoice, as well as still having an amount due to pay and that the shipping status is waiting for payment. If that's the case, we are going to leverage our InvoiceStrategy and generate an invoice for this particular order. Then we're going to set the ShippingStatus to ReadyForShipment. If we still have an amount due when we don't have an invoice, we are going to set an exception to tell us that we are unable to finalize this particular order. Now we can call FinalizeOrder. If we set one of the strategies for how to deliver an invoice, we should be able to either get a file, an email, or maybe capture the API call. Before we can finalize the order, we also want to set the particular strategy for how to deliver an invoice. This also, of course, requires us to have an invoice payment set on our particular order. So now when we run the application, this should generate a file on disk. And you'll notice here that indeed we did get a file created on our disk. I promise that I didn't create this myself. We can see that the tax amounts are exactly the same. It lists the items that we are purchasing with his order. Let's test one of the other ones. Let's test the email strategy as well. And when we look at that, indeed this did give me an email. So now we successfully added a way for us to send an invoice to our user depending on the way that they want this to be delivered. We can set the different invoice strategies depending on how we want this delivered to our end users. And inside our order, we know nothing about the particular implementation of the different strategies. The context, in this case, doesn't have to know anything more than simply how to invoke that particular implementation by leveraging the interface. Since these different strategies all implement the same interface, we can easily replace the concrete implementations in runtime. So, again, this shows us that it's making our application a lot more extensible. I guess the drawback as with any other pattern is that this could add a little bit more complexity to our applications. As with any pattern and practice in any programming language, you have to be cautious about the code that you're adding. Make sure that the code makes your application easier to work with and that it doesn't get in your way

Example: Using Different Shipping Providers
In this example, we're going to look at leveraging different shipping providers. When the order is finalized, we want to make sure that we can ship the order. And, of course, the user can, depending on where they live, choose different shipping providers. So let's jump into Visual Studio and have a look at how we can implement this using the strategy pattern. So again, we're looking at our application. Our application is now evolving into becoming something that's pretty good. We have a good architecture in the application, and we're making sure that we are breaking out dependencies and decoupling the different parts of our applications. Of course we can probably leverage more patterns in order for us to decouple our order. But that's outside of the scope of this course. So now we are leveraging the strategy pattern, and we're making sure that we can replace functionality in runtime based on decisions of our users. This behavioral design pattern is extremely powerful and allows us to create extensible and testable applications. And being extensible means that I can now add more strategies in our applications without affecting existing implementations. I can add an SMS invoicing strategy without affecting email, file, or print-on-demand. What we want to add now is a way for us to work with different shipping providers. We might support shipping providers, like DHL, FedEx, the United States Postal Service, UPS, and the Swedish Postal Service depending on if your order is being sent within Sweden or not. And all these different requirements and policies and validations need to live in our strategies in order for us to not clutter the application with logic where it shouldn't live. So we're now going to add a new section for our strategies. We're going to add our shipping strategy for our particular order. And as we've done previously, we'll start off with the interface. This gives us the premise of how to implement our concrete implementations. The shipping strategy simply takes the order, which should probably contain information about how this order is going to be shipped. So we might select that we want to leverage DHL, FedEx, UPS, the Swedish Postal Service, or the US Postal Service, and then each concrete implementation of our strategy will take care of communicating with that different API. So what's interesting is that this strategy will simply communicate with APIs while the sales tax was a way for us to replace computation at runtime, and the invoicing strategy was more about persisting the particular invoice. Now our shipping strategy will invoke different types of APIs. So we're going to go ahead and add the strategies for our different shipping providers. And what you'll notice here is that, for instance, with our DHL shipping provider, we simply implement the interface IShippingStrategy. It takes the order. It creates an HttpClient because most of these APIs are most likely over HTTP. But I'm not going to add an implementation for this here. Instead, I'm simply going to print to the console that this here is being shipped with DHL. And of course, the same goes for FedEx. We simply take the order, and we say that we ship this with FedEx, but we don't have the particular integration with the FedEx API. And honestly, I don't even know if all of these different shipping providers have public APIs. I would expect that they do, but that's really outside of the scope for this course. And then we have the implementation for our Swedish Postal Service, also known as PostNord. This here will allow us to ship our order using the Swedish Postal Service. Same goes for USPS, as well as UPS. So now we have all of these different shipping strategies. We can make sure that we validate that this order can be shipped with this particular strategy. Maybe UPS requires us to also pass the weight of the particular order. Then we could make sure that we have this and that we summarize the weight of each line item and passed this to the API, while other APIs might not require that. So we can be very particular about the implementation for the different strategies within this little scope that now doesn't have to require us to extend our particular order with this concrete implementation. What we do want to extend our order with is our IShippingStrategy. We need our context, which is the order, to know that we have an IShippingStrategy that you can leverage so that the order can say that it wants to ship this particular order using one of our strategies. Now that our order has a ShippingStrategy, we can leverage this when we finalize the order. So after we've sent the invoice, and we know that there's no longer anything left to pay, we can say that we want to ship the order. And now if we go into our program, the idea here, of course, is that when we call FinalizeOrder, this will automatically be marked as being shipped as long as we set the ShippingStrategy. So on our particular order, we are now setting the different strategies based on some user input. So I've made some changes to the program. I've made sure that we can require the user to first specify our origin country, the destination, choosing one of the shipping providers, choosing a delivery option for how they want the invoice to be delivered. And based on that, we then extract a strategy for each different type of strategy that our order supports. So for the origin or the destination, we choose a SalesTaxStrategy. For the invoicing strategy, we choose one based on the invoiceOption, and the same goes for the ShippingStrategy. We choose one based on the provider. And if we check these different implementations, so now we are making sure that if the origin is Sweden, we use and apply the SwedenSalesTaxStrategy. If it's USA, we apply the USAStateSalesTaxStrategy. Otherwise, we'll simply return unsupported region. For the ShippingStrategy, we simply say that if the provider is 1, 2, 3, 4, or 5, we return that particular strategy. So we either have the Swedish Postal Service, DHL, USPS, FedEx, or UPS. And the same goes for our invoicing strategy. We can use email, file, or print-on-demand. So if we run the application and say that we're going to send this from Sweden to Sweden, we're going to select that we want to leverage the Swedish Postal Service, PostNord, and then we're going to choose that we want to deliver this as a file. We can see here that it's now telling us that the total tax is 25 kroners. The order is now shipped with PostNord. And this also generated a file telling us that we now have a new invoice. So as this application grew throughout our course, we saw that we can refactor existing code in the application to apply a strategy pattern for different types of calculations, like when we calculated the tax. We can replace the algorithm that calculates the tax based on the different countries easily when we apply the strategy pattern. And for new functionality, it makes it a whole lot easier if we start off with the interface and look at how we want to expose the shared functionality. And then we can simply work with these different strategies for how to implement different things. If we work with persisting data or if we're working with API calls, the strategy pattern is extremely beneficial. Imagine running tests for this. We could simply replace the strategy for creating an invoice or shipping with a mocked version of that strategy to make sure that our entire order was processed accordingly. So now you've seen how you can apply the strategy pattern in your applications, how you can refactor an application to leverage this pattern and make it more extensible, as well as decoupling your code to make it more maintainable.

Existing Implementations: Array.Sort
Let's have a look at an existing implementation in .NET. This will give you an idea of where this is applied in a different scenario. We're inside Visual Studio again, and what we're looking at is a collection of orders. They're all being shipped from different origins, and I want to make sure that we can sort this array of orders depending on different criteria. The user that's looking at the orders might want to sort them depending on the origin, destination, the total amount, and so forth. If we run the application, we can see that we have an order for Sweden, US, Sweden, US, and then Singapore. We don't want to sort this and then we print the array again. But since we're not doing any sorting, this will be the same structure as we see at the top. So in order for us to sort this array, we can leverage Array.Sort. What's interesting with Array.Sort is that it will do the sorting in place, and it takes a few different overrides. We can pass an IComparer, which will override the way that it compares the different elements. If the order doesn't implement an interface to make itself comparable to another order, Array.Sort requires us to pass this particular strategy of how to compare two different orders with each other. So we're going to pass our orders collection here. And then what I've gone ahead and done is that I've implemented two different comparers. I have one that will allow us to compare the order amount. The particular implementation of an IComparer isn't really important. What's important here is that we leverage the interface IComparer of an order. Then we have an OrderOriginComparer, which will simply compare the first letter of where our order is originating from. Alright, so then we can pass one of these different comparers. If we now run the application, you'll see that it sorted our array. It now made sure that Singapore is on the top. We're only sorting by the first letter in this case. We could, of course, compare every character if they're the same and so forth. But to keep it simple, we're simply sorting by the first letter. And then we can also say that we want to replace this IComparer with a different type of strategy for how we want to compare two orders to each other. So we can use the OrderAmountComparer. and I don't have any items on my order, so they will all be in the same sequence as they were at the top. But what this illustrates is that whenever we can pass an interface that allows us to override functionality like with this comparer here, we can pass a strategy for how two things are compared to each other. In our previous examples, we looked at how we can replace computation, API calls, or persisting something. So in essence, the strategy pattern allows us to replace functionality at runtime based on behaviors of our users. And even though we don't see any naming of a strategy here, this here is, in fact, leveraging the strategy pattern. So whenever you can inject an interface to allow change of behavior, you are leveraging the strategy pattern, which is why this is one of the most commonly used patterns that you will encounter.

Summary and Final Words
This course has been packed with information about how to leverage, implement, and understand the strategy pattern. This is, of course, one of the most commonly used patterns. The premise, of course, is that whenever we find an interface that will allow us to change some behavior, we can inject our own implementation and make sure that we provide the strategy for how to solve that particular problem. We saw that we can decouple the context and the concrete implementations. We refactored an application to leverage the strategy pattern. This makes sure that we can now have an application that is more testable, maintainable, and honestly, as with any pattern that we apply, it makes it a lot more fun to work with as our applications don't end up in a mess of spaghetti code. It allows for a cleaner implementation in the context. Our order class, which we looked at, which was the context in this case, allowed us to now approach these different strategies in a much cleaner manner than when we had all the code inside that context. We saw that we can easily extend with additional strategies without affecting current implementations. If you want to add more shipping providers or more ways for delivering an invoice or new countries that have different tax calculations, you can simply add that to the project without affecting your currently implemented strategies. This makes it easier for you to develop new strategies, write tests for them, and make sure that they work before you add them or apply them in your applications. It does make testing a lot easier as you can now write mocked implementations that you can inject whenever you see one of these interfaces being exposed. Finally, we looked at identifying existing implementations and where you have used this pattern before. If you've been working with C# and .NET for a while, you've most likely leveraged interfaces. Whenever you leverage an interface, you can say that you leverage the strategy pattern because it allows you to replace the functionality at runtime. With that being said, thank you so much for taking the time to take this course. We've covered this amazing pattern and how to apply that in your applications. Hopefully by now, you get some ideas of how you can refactor your applications, and this will take your development experience to a whole new level. My name is Filip Ekberg, and thank you so much for taking this course.