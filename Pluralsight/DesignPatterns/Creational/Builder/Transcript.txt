Course Overview
Hi everyone. My name is Harrison Ferrone, and I'd like to welcome you to the C# Design Patterns: Builder course. I'm a software developer and instructional author at my own little corner of the world, Paradigm Shift Development. Most days you can find me working with C# in Unity, doing a bit of freelance iOS development or editing technical content for the Ray Wenderlich website. Now design patterns have been around for more than 25 years, and in that time they've helped many a software developer get his or her head around a difficult problem with their tried and true techniques. This course is a jumping off point into the builder design pattern in the C# language, so you don't need any prior experience with them to get rolling. Some of the major topics that we'll cover include: defining a class object, adding a builder interface, creating a concrete builder class, implementing a director, and understanding real‑world examples and implications. By the end of this course, you'll be comfortable with identifying and analyzing practical use cases for the builder design pattern, and be ready to bring the code and skills you've learned into your own C# projects. Since this is an intermediate course, you should be familiar with the C# programming language and know your way around Visual Studio, either on Mac or Windows. The beginner‑level C# Fundamentals course in our library can quickly get you up to speed if you're just starting out or if you need a refresher. I hope you'll join me on this journey into software design with the C# Design Patterns: Builder course, at Pluralsight.

Implementing the Builder Pattern
The Builder Pattern Explained
All right, folks, welcome to the course. Over the next few clips, we're going to be discussing the theory and application of the builder design pattern. This is going to include setting up a base object class, adding a builder interface, creating a concrete builder class, implementing a director, updating to a Fluent Builder variation, and reviewing use cases and applications. Before we get into that, let's take a few minutes and talk about the pattern itself. As you might already know, design patterns are classified into three different categories: creational, structural, and behavioral, as outlined by the Gang of Four's famous text on elements of reusable object‑oriented software. Now the builder pattern falls into the creational category of design patterns because, well, it deals with creating objects. More specifically, the builder pattern aims to "separate the construction of a complex object from its representation so that the same construction process can create different representations." In more accessible language, the builder pattern removes any and all construction or initialization code from an object class and abstracts it out to an interface. Any specific representations of that base class are then created as concrete classes implementing that interface, effectively constructing themselves from the blueprint provided. The cool part in this process is that the concrete classes don't deal with instantiating themselves. That's up to the director class, which controls where and with what data the concrete classes are actually created. I find that visuals can help out a lot when learning a new design topic, so let's take a look at this UML pattern diagram. The product on the right side is the complex object we're trying to construct, but in this design pattern, it doesn't have any initialization logic. The builder is the interface that defines how the pieces of the complex object are created. The concrete builder instances construct the complex object according to the builder interface blueprint. An important note, each concrete builder is in charge of keeping track of the representation of the complex object it creates, and retrieving that object when queried. Finally, the director class handles the actual call to construct the complex object using the concrete builder. Now fair warning, the builder pattern is not seen too often in production code because its proper use case scenarios are not super common. We will talk about this in more detail at the end of the course and throughout, but I just wanted to throw this in here at the beginning so you don't run off and start changing all of your object creation logic to the builder pattern in all the excitement. So, in summary, the builder pattern is useful when the creation of a complex object needs to be separate from its parts and their assembly. This is going to allow different representations to be created and finer control over how they're put together.

Creating a Builder Interface
With the basic theory under our belts, it's time to take a look at the starter project that I've included in the exercise files. Go ahead and open up the Solution in the Visual Studio, and you'll see the default Program.cs file along with an InventoryReport class. If you open that one up, you'll see a FurnitureItem class with several public fields and a class constructor. Below FurnitureItem, I've set up an InventoryReport class, which is the complex object we'll be building with the builder pattern throughout the course. This class has three string fields that will hold our report info, separated into sections, and a Debug method that's going to help us see our output in the console. There's no constructor in this class because we'll be setting up these values one by one in the concrete builder representations. Essentially, what we're going to do is feed a list of items into a concrete InventoryBuilder class, which will be in charge of configuring and returning an InventoryReport. If you take a look at the Program.cs file, you'll see that I've already created a list of furniture items so we don't have to spend time writing them out later on. With that done, we're ready to start creating our interface. And yes, I am going to include all the builder pattern code in one file because it's easier to reference for teaching purposes. You being the good programmer that you no doubt are, should, of course, separate these into separate files. The builder interface we want to create needs to blueprint out the construction of each section of our report. So I'm going to go down underneath InventoryReport, and I'm going to declare a new public interface, and this is going to be called IFurnitureInventoryBuilder. Since we have three sections, we're going to have three methods here. We'll start with AddTitle, AddDimensions, and AddLogistics. Since the whole point of the builder pattern is to separate out an object's construction from its representation, the builder interface needs to be general enough to apply to all the different kinds of concrete builder classes that might be created in the future. In this case, the builder interface could be applied to monthly, quarterly, or even yearly concrete Report Builder classes with no issue. The last thing we'll add here is returning the built item once we've finished constructing it. In the traditional design pattern, each concrete builder class would be in charge of implementing its own method to do this. But our case is general enough that we can add it into the interface here, and I think it makes it a little cleaner. So this is going to return us an InventoryReport object, and we'll call this GetDailyReport. If your scenario requires a less generic implementation, by all means, leave it out of your builder interface. Just remember to add it into every concrete class without exception. Before we move on to our actual concrete builder class, I do want to point out that our interface has effectively broken up the product construction into individual steps. This should give you a hint as to how much more control you have over how an object is put together using this pattern and the possibilities for error handling and sequential computation at each step of the way.

Implementing Concrete Builders
At this point, we've got the pieces we need to declare our first and only concrete builder class, which in our example, is going to represent a daily inventory report. This class is going to need to implement our builder interface that we just set up, so we'll go underneath that and declare a new class. I'm going to call this DailyReportBuilder and have it conform to IFurnitureInventoryBuilder. This class does need to keep track of the item it's building, so the first thing we need is a private variable to keep track of said item. So I'll say private InventoryReport, and we'll call this _report. Now, I know that Visual Studio is yelling at us right now because we haven't properly implemented the interface yet, but I do want to do something to keep our report tracking clean and safe, and that's to declare a Reset method. So we'll say public void Reset. And all we're going to do in here is make sure that our report is instantiated with a new InventoryReport object. You won't see this done in every builder pattern example you might come across, but in my mind, it's essential defensive programming for this scenario. Let's do one more thing before taking care of the interface, and that's declaring our class constructor and calling Reset to make sure that our item is a new instance every time our class is constructed. So we'll say public DailyReportBuilder, and we'll just call Reset, and save. This is going to ensure that a blank product item comes with each new concrete builder instance. With that done, we can stub out the builder interface methods and finally get rid of these errors. We'll say public void AddTitle, public void AddDimensions, public void AddLogistics, and finally, public InventoryReport GetDailyReport. Here, when we return the built report to the client or calling code, the concrete builder should be set up to immediately start building a new report object. This isn't a must have, but like the Reset method itself, I find it's a good way of doing things. So let's create a new InventoryReport to hold the return product. I'll call this finishedReport and I'll set it to our built item. I'm going to call Reset, and then I'm just going to return our finished report. Now that our errors are resolved and the report item can be returned once it's completed, we can configure the report sections one by one. In many simple examples you'll come across, each piece of a concrete builder class is usually hard coded inside its interface method. To try this out, let's go into AddTitle and just set the string ourselves. So we'll say _report and we're going to set the TitleSection string and this is just going to be a little header. This is just going to say Daily Inventory Report. We are going to give it two line breaks so that we can distinguish it in the console. While this approach is fine for examples, in most real‑world cases you'll no doubt need data from outside the concrete builder, which can be done in a number of ways, the most common being passing data in through the class constructor or adding method parameters to your interface methods. Both of which we'll demonstrate here so you know what your options are. First, let's add a private field to the top of our DailyReportBuilder, and this is going to hold a list of all our furniture items that we'll pass in through our constructor. So we'll say private IEnumerable. This is going to be of type FurnitureItem. We'll call this _items, and in our class constructor we'll add an argument. It's going to take in an IEnumerable of type FurnitureItem called items. And after we Reset everything, we're just going to set our private items to our constructor items. Now, we can go ahead and fill in our AddDimensions section by creating a join string, and that's going to print out all of our data from each furniture item on a new line. So we'll say report.DimensionsSection. This is going to be equal to string, we'll used the Join method, and we're going to join by a NewLine and by _items.Select. We actually need a using directive to use that, so we'll go to the top of the file and say using System.Linq. Back down in AddDimensions we'll try this again. There it is, Select. We'll just say each item is product, and we're going to do this on a new line so that it's a little clearer. This is going to be an interpolated string. We'll just say Product is going to be equal to product.Name. Price, we'll do the same thing. I'm just keeping these on separate lines, just so it's a little more readable. Of course, you can just put it all in a single string if you like. But we'll do Height as product.Height, put in Width, and finally we'll put in its Weight. Now that we've used our passed in data from the constructor, let's try the second method of getting data into our concrete builder and update AddLogistics to take in a date. We'll say this is of type DateTime, we'll just call this dateTime. And this one's pretty easy, we'll set report.LogisticsSection to an interpolated string again, and we'll say Report generated on our passed in dateTime. One thing I will point out here before moving on is the order that the build steps are executed, which is completely under your control. When an object is built, you don't have to call the interface methods in the order they're declared in the actual interface. So keep that in mind when you have a scenario where data or computations need to be executed in a specific order while building a complex object.

Adding a Director Class
Before we jump into the director class, I do want to point out that I forgot to update our AddLogistics method signature in the IFurnitureInventoryBuilder, so go ahead and do that now if you didn't already catch that mistake, and save. Now, the director class only has one job, and that's to execute the object's build steps in a predetermined sequence. You'll see director classes in some builder implementations and not in others because you can technically call those build steps directly from any concrete builder class. However, this isn't as cleanly abstracted as having a director take care of it, so we're going to declare one at the bottom of our file. We'll say public class InventoryBuildDirector, and we'll save that off. Since the director needs to know about the concrete builder class it's assembling, let's put in a private variable to store that builder. We'll say private, it's going to be of type IFurnitureInventoryBuilder, and we'll call it _builder. Now we are going to inject and set this inside the class constructor, so let's do that now. We'll say public InventoryBuildDirector, and it's going to take in our builder interface type and we'll call this concreteBuilder. Now all we need to do is set our private builder to concreteBuilder. Now we can declare any number of public methods to build out different versions of a product. But for this example, we're going to stick with building a complete report. So we'll have a public method, it's not going to return anything, and it's going to be called BuildCompleteReport. Inside here, we're going to take our builder, we're going to call AddTitle, then we're going to be calling AddDimensions, and finally AddLogistics. And for the date, we're going to say DateTime.Now. It's important to note here that if you construct a partial item that is not calling all the builder interface steps, the uninitialized values will be set to their default. This can cause problems if you're using lists or other types that will throw an initialization error. With that all set up, let's go into our main method inside Program underneath our items list. And we're going to create an instance of our concrete class. So we'll say var, I'm going to call this inventoryBuilder, it's going to be a new DailyReportBuilder, and it's looking for an IEnumerable collection of furniture items. So I'm just going to feed it items. Now we can set up a director class. We'll say var director. This is going to be a new instance of our InventoryBuildDirector. And we need to supply it with a concrete builder, which we've just initialized. And we'll save. Now for the magic, we're going to have the director build the item, and then we're just going to debug it out. So we'll say, director.BuildCompleteReport, and now we're going to query this from the concrete builder class, and we're going to store it, directorReport. And we'll say inventoryBuilder.GetDailyReport, and we'll just Console.WriteLine and we'll debug this out. We'll say directorReport.Debug. Before we do this, I did notice that I forgot a closing parentheses at the bottom, or end, of our AddDimensions section. So go ahead and add that in, save, and run. When our console boots up we'll see a complete report printed out with a title, a list of all the furniture items we passed into the constructor, and the current date and time we passed in to AddLogistics. Perfect. You've now successfully implemented a basic builder pattern. So congrats! In the next clip, we're going to take a look at a popular variant of the builder pattern called the Fluent Builder. So let's keep rolling.

Using a Fluent Builder
If you're not familiar with the concept of a Fluent Builder, don't worry. You've likely come into contact with it more times than you might think. For instance, if you look back at the Debug method in InventoryReport, you'll see that we initialized and configured a string builder in a very efficient manner. After initialization, we're able to tack on as many configurations as we like with methods like AppendLine, then return the entire modified string with the ToString method. This variant of the builder pattern is often chosen for its sensible syntax, allowing you to initialize a concrete builder instance, fire off the build steps, and finally return the item all in one go. Now, making this work with our current code isn't all that difficult. All we need to do is have each of our builder interface methods return an object of its own type. So instead of void in all these cases, we're going to say IFurnitureInventoryBuilder. Since GetDailyReport is the last, or last build step, we're going to leave that one as is. Now all we need to do is update our implementations inside our concrete builder. So after AddTitle, after we set the TitleSection, we'll just say return this and we'll change the method signature. We'll do the same thing for AddDimensions and for AddLogistics. (Typing) This won't change anything in our Director class, so we don't need to modify any of this code. However, there are now two choices in front of us as to how we use the Fluent Builder. In most cases, you'll see this variation called directly from the concrete builder class, bypassing the director entirely. This is because the build steps and return item all happen in the same line and leaves the responsibility of building and returning the object with the concrete class where it should. Let's go into our main function. I'm going to comment out what we've done with our director, leaving the inventoryBuilder that we've established. And we're going to say var fluentReport, because that's what we're going to store the return built report. And we're going to call inventoryBuilder.AddTitle. And we can just append these directly, so we could just say AddDimensions, AddLogistics, pass in DateTime.Now, and finally build the report and return it with GetDailyReport. Now let's debug this out just to make sure that we get the same result as we had with the director. Say fluentReport.Debug. Let's save this off one last time and run our project. All right. Perfect. We've still got our Daily Inventory Report with each of our items and all their info printed out, and our report has been generated at the correct date and time. Just so you know, you could absolutely create another method here in the director class that executes the Interface method using the Fluent Builder syntax. However, you won't see this done too much because it's a lot of abstraction for abstraction's sake, and comes with very little to no additional added value. As with all things design pattern related, it's up to you to decide how to use it in your projects. Always choose the implementation that delivers the most bang for your code buck without adding unnecessary infrastructure. In the last clip, we'll discuss some common use cases and implications of the pattern itself and close out the course with some resources to take your design pattern game to the next level.

Use Cases and Implications
With our simple builder pattern example in working order, it's time to take stock of its implications and appearances in the wilds of real‑world development. First, as I've said before, this pattern isn't for everything. It's overkill for most classes where subclassing, refactoring, or abstracted interfaces or classes would be a better solution. However, if you find yourself looking at a class in your project that has an ever‑expanding and now bloated constructor that's performing a variety of computations before setting class fields, this is a good indication that the builder pattern can be helpful. On top of that, if you have a finite number of related classes that perform the same general function, but with different representations, this is also going to qualify for the builder pattern. Think of a text parsing scenario where you need to account for general functionality, but accommodate different kinds of text input and output, as described in the Gang of Four text. This is an excellent builder pattern scenario because there are a finite number of complex representations that need to share similar object building sequences. Let's move on to summarizing the builder pattern's implications because these are the real topics that I want you to come away from the course with. First, the builder pattern lets you vary a product's internal representation, meaning that the director doesn't have to know about how an object is built or its internal structure. Changing a product's internal structure is then as easy as creating a new concrete builder class. Second, the pattern isolates code for construction and representation, meaning that your code is going to be more modular and encapsulated as a result. Object creation code is written once in the concrete builders, then the director only has to choose which preset build sequence to use and reuse. Lastly, it gives you finer control over the construction process, giving the director complete control over each step of the build and its sequence. You'll only get a returned object when the director has finished calling the build sequence, which is a huge boon when you have error checking and computations involved in creating your complex object. As a last side note, if you've had experience with design patterns before this course, you probably noticed that the builder pattern shares similarities with the factory pattern. The important difference here to keep in mind is that the builder pattern is focused on object creation in sequential steps, while the factory pattern is concerned with families or groups of objects being created. In summary, we've learned where the builder pattern fits into the larger design pattern picture. How to create an object class and abstract out its constructor into an interface. How to create and configure concrete builder representations. The role of the director class and managing the overall build process. How variations of the pattern can be written to accommodate dependency injection, and the most common use cases and implications of using the pattern in real‑world projects. I hope you've come away with a real grasp of the builder pattern and how it can be applied to your personal projects in the future. If you're interested in more design patterns with C#, check out our other courses in the Pluralsight library. If you've enjoyed the course, which I hope you have, please leave a rating, and if you have any questions or just want to connect, feel free to drop me a line. As always, happy coding.