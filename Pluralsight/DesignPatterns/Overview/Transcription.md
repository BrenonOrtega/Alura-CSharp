Course Overview
Hi everyone. 
My name is Steve Smith, a.k.a ardalis, and welcome to my course, Design Patterns Overview. I'm an experienced .NET developer, architect, and trainer. 
My onsite workshops and Pluralsight courses have helped thousands of developers and teams write better code faster. You'll find me online under the name ardalis. Design patterns have fascinated me for years. They're like individual tools you can add to your toolkit as a software developer. They don't take long to introduce, but they can take a lot of practice to master. 
In this course, we are going to explore the concept of design patterns, which you should definitely start learning if you haven't already. Some of the major topics that we will cover include what are design patterns, and where do they come from? Why should you spend time learning them? 
How should you approach this large topic? 
And what are some good patterns to start with? By the end of this course, you'll understand how design patterns can help you be a more effective software developer, and you'll have a proven strategy for getting started to learn more about them. I hope you'll join me in learning about software design patterns, and I hope you'll continue diving more deeply into specific patterns here on Pluralsight.

Design Patterns Overview
Introducing Design Patterns
Hi there. I'm Steve Smith, a.k.a ardalis. You can find me online at ardalis.com or ardalis on various social media networks and YouTube. 
I also record short developer tips on my podcast at weeklydevtips.com. This course offers an introduction and overview of design patterns, a topic every software developer should strive to understand. By the end of this course, you'll understand what design patterns are, how they're discovered and defined, and, most importantly, how and when to apply them in your software. In this course, you're going to learn about the topic of design patterns. We're going to examine what the patterns are, where they come from, and also why should you bother to learn them? Then we'll look at some good ways to approach learning patterns, since there are quite a few of them, and many different approaches you might take to this. You'll learn when it makes sense to apply patterns, since it's very common for developers new to patterns to be a bit overzealous in their application. And finally, I'll introduce a few common design patterns and show how they can be combined with one another. According to the Wikipedia definition, a software design pattern is a general, reusable solution to a commonly occurring problem within a given context.

Design Pattern Origins
But let's start at the beginning. Where did design patterns come from? In 1977, design patterns are introduced in the context of city building by architect Christopher Alexander in his book. In 1987, Ward Cunningham and Kent Beck decide to leverage patterns as part of a client project, providing the client with a limited set of patterns to use. They're impressed by the results and present some of their findings at the OOPSLA conference in Orlando that year. Then, in 1991, Erich Gamma works on a Ph.D. thesis on pattern, which would later lead to his developing the Design Patterns book, along with three coauthors. A Pattern Language: Towns, Buildings, Construction in the timeless way of building is the book that was written by the architect Christopher Alexander in 1977. This is the first book to identify the concept of design patterns. It documented 253 different patterns in the context of cities, towns, and buildings. The book defined a way to describe patterns. It organized them into different groups based on characteristics, and it provided this large catalog of patterns about towns and their structures. Design Patterns: Elements of Reusable Object‑Oriented Software by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides was published in 1994, although, oddly, it was given a copyright of 1995. The book established a language for describing object‑oriented software design patterns. It, too, organized these patterns by their type. The types included creational, structural, and behavioral. And in this book, they detailed 23 individual design patterns. Since then, dozens of patterns have been identified and documented across many aspects of software development.

Why Learn Design Patterns?
Why should we spend time learning design patterns? Aren't they just used by architects and college professors? What use are they to me in my day‑to‑day job of actually building and shipping software application? Well, I'm so glad you asked. There are good reasons to learn design patterns. First, they help to avoid reinventing the wheel. Many of the problems you'll face in your career have been solved before. Learn to recognize them and the patterns that can be used to address them. Second, patterns come with names and associated constructs that allow communicating more clearly. Understanding the patterns your team uses is critical to communicating effectively with your team. Thirdly, patterns can help you to be more effective and to deliver better software. Often, difficult problems or duplicate code implementations can be solved elegantly using a design pattern. Knowing this, and even just knowing to look for a pattern if you don't know one offhand, can dramatically improve your ability to ship quality software. And, of course, all of these can help you improve and grow in your career. Today, most senior developers, and certainly every architect, should be familiar with the concept of design patterns and should know at least a few of them well enough to implement them without assistance. While nobody is fluent in every pattern, having some general and specific knowledge of patterns is sure to help you in your career. To illustrate how design patterns can help with communication, consider these two variations of a conversation that might occur between two team members during a code review. The first one says, we have some tight coupling to the database here. We can probably fix it if we apply some refactorings. Maybe we can start by extracting an interface. Then, we could extract a method that contains the persistence code. After that, we can take that method and put it into its own class that implements the interface we just created. And then we should be able to replace all the local instantiation of that class with a parameter that we can pass in and assign to a field. That's a whole lot of low‑level detail to go into that one little review comment. Let's look at it with patterns. We have some tight coupling to the database here. Why don't we use the repository pattern to eliminate it? By using a pattern name that's well understood by everyone involved, it's both faster and clearer to communicate design intentions. This is what I'm talking about when I say knowing design patterns helps improve team communication.

How Should We Learn Design Patterns?
Now, how should we go about learning design patterns? Should we simply read about them or watch presentations, like this one? Maybe we should just memorize all their names. Everyone learns differently, but I have some recommendations for how you can most effectively learn design patterns to materially improve your code and your career. In my own experience with patterns, as well as in other areas like sports and martial arts, I found there are distinct stages of learning. The first stage is simply ignorance. You don't know that a concept, technique, or pattern exists. This is where everyone begins, but it's also the easiest stage from which to progress. The next stage is what I call awakening. In this stage, you become aware of the thing about which you want to learn. Here you might say, wow, I just learned that the XYZ pattern could help my design. I'm not really sure how to apply it, but I'm keen to find out. In this stage, you've probably never actually applied the pattern; you've only heard about it from others. Of course, as they say, a little knowledge is a dangerous thing. And so the next stage is where experimentation and some of the real learning takes place. Knowing there's a pattern others have found helpful, you may try to use it everywhere you can. Generally, it's less painful to practice new techniques in a controlled environment rather than in production or on game day. Eventually, with enough practice, you'll learn where the pattern fits and where it doesn't until eventually you reach the final stage. This stage requires that you actually apply the pattern yourself in a variety of contexts. You can't expect to master a pattern you've never actually applied. However, with mastery, the final stage of learning, you've internalized the skill or pattern. You've developed a kind of muscle memory for applying it that no longer requires you to break down the steps and consciously go through them one by one. When you see an opportunity to apply the pattern, you quickly do so and move on. You also recognize situations where the pattern might seem a good fit, but you've tried it before, and you know better now. When considering knowledge or skills, a common recommendation is to strive to be T‑shaped, like the letter T. That is, have a broad understanding of general concepts, but also have deep practical understanding of a few specific things. It's generally less helpful to only have vague, encyclopedia‑like knowledge of a wide array of topics, but no ability to actually deliver anything of value using this knowledge. It's also not ideal to only have deep understanding of a very small number of tools or techniques without understanding any other ways to approach things. You risk being a one‑trick pony who has a golden hammer they apply to every problem. You can apply the concept of T‑shaped knowledge to design patterns as well. You should at least be familiar with a wide array of patterns. When someone mentions that they want to use the observer or flyweight to tackle a problem, you should immediately recognize that they're referring to a specific pattern. It's okay if you don't know that pattern intimately, but your broad knowledge of patterns should let you at least participate in the discussion. You'll also know how to find out more about any specific pattern by quickly watching it's associated Pluralsight course or finding an appropriate book or online resource. These patterns you can keep at the awakening knowledge level. Of course, for those patterns that are most applicable to the kind of software you deliver, it'll be very helpful for you to master at least a few of them. These patterns you might make use of every day, and you should know them well enough that you can explain how they're used to new members of your team. Eventually, the number of patterns you've mastered is likely to grow, but there will probably always be patterns you don't use often enough to truly master. Which patterns should you go deep in? Well, that depends on what kind of applications you're building, but I'll offer some suggestions at the end of this course.

What Makes up a Design Pattern?
So, what makes up a design pattern? Typically, patterns are defined using a set of documentation that describes different aspects of the pattern. The gang of four's book, Design Patterns, helped establish these well‑defined sections that are still used today. The first section is the name and classification of the pattern. Second, it's good to describe the intent of the pattern. What is the problem that it's trying to solve? What is the goal of the pattern? Many patterns go by numerous different names because they exist in the wild and different developers call them by different names, and so it's useful to represent a given pattern along with other names it might be known as. We'll talk about the motivation for the pattern, a scenario or problem that this pattern applies to, and related to that, the applicability, different situations in which this pattern could be usable. We'll talk about the structure of the pattern. This is usually done with class diagrams and interaction diagrams or sequence diagrams, typically using UML to kind of show how the different parts of this pattern interact with one another. Along with that, there'll be some detail about the participants. This is a list of the classes and objects that are used in the pattern, and their individual roles in its design. The next thing the pattern section usually covers is a detailed view of collaboration. So looking at those classes and objects, how do they interact with one another? Not just what their own individual responsibilities are, but what are their interactions? How do they collaborate? Then, most design decisions involve trade‑offs, so you'll also learn about the side effects or the design trade‑offs that this pattern brings with it. Finally, you'll see how to actually implement the pattern, which represents the solution to the problem that was set up earlier in the definition. There should be some sample code in some particular programming language; it varies with the source. After that, you'll see any known uses of the pattern. This helps you identify real world implementations of that pattern that you could look at for future reference and see how it has actually been applied outside of an academic context. And finally, because many patterns work well with one another, you'll also see related patterns, other patterns that have some relationship with this pattern, either because they can be used side‑by‑side or because the patterns share some structure, but differ in intent or other ways. If you're just aiming for a breadth of knowledge, the bare minimum amount that you should understand about a pattern in order to get to that awakening stage of learning, you should know the pattern's names, both its primary name, as well as any aliases it might go by, you should know what its goal or intent is, and you should know at least some of the scenarios, situation, or context in which that pattern is appropriate. This is usually covered in the motivation and applicability section of the definition. This tells you what is the problem that it's seeking to solve, and this will help you because then when you see that kind of problem, you'll remember that there was a pattern that could be applied there.

Design Pattern Structure
Design patterns in object‑oriented programming are often described using UML diagrams, like this one. In this diagram, we have a Client. The Client makes a call to a service, which exposes some method. There's also a Proxy, which calls a RealService. The implementation of this interface, this IService, is done by either the Proxy or the RealService. Now, in this completed UML diagram, we can see that the Client is going to make a reference to an abstraction, the IService type, and then at runtime, we may have implementations for the Proxy, as well as the RealService, that we could swap in as part of this pattern. In diagrams like these, the boxes typically represent classes, or occasionally interfaces in your code. Lines represent some kind of relationship, which could be inheritance or interface implementation, it could be composition, or it could be some kind of invocation, like a call. Each box may include details about the class's members, typically with important fields or properties listed at the top and methods at the bottom. Not all design patterns are complex. For instance, the singleton pattern's diagram has just one class. This class has a private _instance field available and a static method called Instance that returns a singleton. Of course, to start to really know a pattern, you're going to need to go deeper. You should understand the structure of the pattern. You should be able to recognize the pattern from its unlabeled diagram. Be aware, though, that several patterns will usually share the same structure and differ only in their intent and applicability. You should know the different participants and how they interact. If you really understand the structure diagram, you should already know this part. And finally, you should also be familiar with how to implement the pattern in your programming language of choice. Having done so many times, you should also understand the consequences and trade‑offs involved in using this particular pattern.

When Should We Apply Design Patterns?
When should we think about applying design patterns, especially if you're still in the overzealous stage of learning? It can be very tempting to apply a newly learned pattern anywhere and everywhere. Just throw it at the wall and see what sticks. But that's usually not the best approach, especially in your production code. When you think about how you want to apply a pattern, it's a good idea to start in a controlled practice environment. Do a coding exercise or a coding kata. Write tests to verify your understanding of how the pattern works. Write tests for the code before you apply the pattern, and then apply the pattern and verify that those tests continue to pass and work just the way they did before. You should repeat this several times with different variations. Maybe try applying a different pattern that you're already familiar with. Try and compare and contrast the different behavior you get and how you would prefer the design using one pattern or another versus your original unmodified code. You can also practice on real code in its own separate branch, but then you should probably delete it. If you are going to work in real code, be sure that you're following refactoring fundamentals. See my course here on Pluralsight on Refactoring Fundamentals, or the revised version, Refactoring for C# Developers. Make sure you have test coverage. Whenever you're doing any kind of refactoring, it's an excellent idea to make sure you have some tests in place that will verify that your code has not broken with the introduction of a refactoring or the application of a design pattern. Do your work in a separate branch, and then use a pull request or a similar tool to merge it in. Ideally, you should have someone review that code to make sure that it looks good before it goes into the master branch. Finally, verify that the behavior is still consistent after you've completed that refactoring. If you do have any problems, if you get stuck because you're really not that familiar yet with this pattern, be prepared to just delete and start all over. It's better for you to just throw away the code and walk away with the experience and the knowledge that you've gained than to try and shoehorn a pattern into your production code where it really doesn't fit.

Demo: Practice with Patterns
Now let's look at a demo on how to practice applying design patterns using a coding kata in C#. You should feel free to take this kata and perform it yourself and see how it works for you with the same patterns that I'm showing, or even different design patterns that you think could apply in this particular scenario. For this demo, we're going to use a programming kata. If you're not familiar with katas, you can do a quick search online. You'll find a lot of them. I have a small catalog of them on GitHub at the URL shown here, my kata‑catalog. In here, one of my favorite katas is the Gilded Rose, which is a very flexible refactoring kata. One of the things that makes it different from a lot of other exercises you might do is that it comes with the code to start with. So this kata has the instructions, you'll find them here. Basically it includes the requirements for a system that is going to update items in a store, and the store's items have a Quality and a SellIn property that is going to get modified every night as a scheduled job that's going to run. You can download the code in a bunch of different languages from the resources linked down here at the bottom. Click on this and you'll find Emily Bache has a whole bunch of them here. I'm using the csharpcore version as my starting point. You'll find the completed work and all the demos for all of my design patterns courses here in my GitHub repo DesignPatternsInCSharp. As you can see from this screen, I have written a bunch of tests already. When you get the kata, there's no tests. That's part of the exercise is to write the test, but we're just going to be showing some quick design patterns. So I've already written all the tests. You'll see some of them are failing. That's because I haven't implemented the last step of the kata, which is to support a new item type called ConjuredItems. However, what I have so far is the basic class here that comes with the kata, and it includes this GildedRose class that's going to be the thing we run against, and that has an UpdateQuality method here. Inside of UpdateQuality, there is a lot of complex code here, and that's the goal of this refactoring exercise is to clean this up, so it's a little bit easier to follow. There's a few ways that we can do this. I've done this kata many different times. I covered a little bit in some of my other Pluralsight courses for different purposes. In this example, I'm going to try and apply a bunch of different patterns just so you can see how they work. So one of the rules of this kata is that you can't touch the Item class. The Item class is very simple. It just has the Name, the SellIn, and the Quality, and some getters and setters. So I want to be able to protect access to this Item class so that you can't exceed certain ranges that are allowed based on their requirements. Looking at this complex if code, you'll see a lot of places where it says, well, if the Quality is greater than 0, or if the Quality is less than 50. I want to provide a way to make it so that it can't possibly be decremented below 0 or above 50. So I'm going to introduce a new type of item, and it's going to be an ItemProxy. The ItemProxy wraps the item and controls access to it so that you can't directly manipulate the item. You'd have to go through the proxy, and the proxy provides you with access to the underlying item. So in this case, what I've done is I've exposed the Name, the SellIn, and the Quality directly, but you can't just set those values. Now if you want to increment the value, you have to call a method to increment Quality and a method to decrement it, another one to reset the Quality to 0, and finally, one to decrement the SellIn. And with this in place, I can run all my tests, and they still work. Now, what does this do to the code? Here everywhere I have one of these if checks, I can get rid of that. Let's update the code again. Now, at this point, if we scroll out a little bit, you'll see that the code has gotten a little bit shorter; still pretty long, but there are no longer any range checks for item quality. Those have all been removed because the proxy is now responsible for those checks. So what can we do next? One thing that I've found very useful in this type of application is to take all these different rules that are currently just embedded as duplicate if statements and pull them out into first class citizens as actual rules. In my Rules Engine course, I go into this in more detail. But what we'll see here is that we can quickly just add some helper methods and then we'll turn those into rules. Let me do a quick check out of my code once more. Now, at this point, inside of my UpdateQuality method, you can see I've got if statements that say, if the item is this, then call this helper method. If it's something else, call the UpdateAgedBrie helper method, et cetera. Here I haven't fully done the refactoring. I've pulled out a couple of them. So you see these first two, Sulfuras, Aged Brie, correspond to these two helper methods here. These helper methods are going to turn into my rules, right? But even just by pulling out these helpers, you can see that I'm greatly simplifying the code in here. Like now that I've checked here, if it's Aged Brie that I'm just going to return, I no longer have to check for Aged Brie anywhere else. I can pull this out, right? And so in my next update, I'm going to show you that that stuff all gets pulled out. Once we've completed pulling all these things out into their own separate methods, we have an UpdateBackstagePasses, we have an UpdateNormalItem. We even have an UpdateConjuredItem now, so our test should pass. And then inside UpdateQuality, we just say if it's this thing, run its method, if it's that thing, run its method, et cetera. All right, really easy to follow at this point. Let's verify the tests all work now. Everything's green, so that's good. We've implemented the feature. Now we want to take these helper methods and we want to pull them out into separate classes that represent these rules. So the first thing we'll do is we'll create a base rule type, and the two things we need for our rule in that pattern is to say whether or not the rule matches a particular item and then provide the logic for doing the updating. In this case, our base class just has an IsMatch Boolean to say whether or not it should be applied, and then the actual logic to do the update. The NormalItemRule is pretty simple. Because normal items are just any item that didn't match something else, our IsMatch is just going to return true, which makes that our default rule. It's going to be the one that we use if we don't use anything else. Now that will become important to remember when we get to how we build our rule's engine, but for now, imagine that it just always matches whatever item. And then the logic is very simple for a normal item .It just decrements the Quality and decrements the SellIn, and if the SellIn is passed, it decrements the Quality again. Now, we're going to follow that and add additional rules, and then move them to different files. So let me pull the code out, and then let's look at the Solution Explorer for a moment. I've pulled the different tests into separate test classes. That wasn't necessarily clear, since I haven't shown you the test. So that's what each one of these are. They say GildedRoseUpdateQualityGiven this scenario, GivenAgedBrie, GivenBackstagePasses, that's just an easy way for me to organize my test. And the nice thing is, now that I'm going to rules, if I want to move those tests so that they apply to the rules, it's really easy for me to do that. They're already organized that way. But here's our normal item rule. Let's look at the ConjuredItemRule here real quick. The ConjuredItemRule matches if the name is Conjured Mana Cake, and it simply decrements twice as quickly. You saw the normal item a second ago. I just called DecrementQuality twice, both at the beginning and if the SellIn has passed. We'll add rules for AgedBrie and BackstagePasses. They'll be similar. And when we're done with that, it's going to look like this. The most complicated rule is this BackstagePassesRule, but now even it fits very easily inside one screen here, even at this large font. Now, if we look at the GildedRose class itself, what we're doing in here is we're just creating a list of these rules. We're adding all those types of rules that we've created into it, and then we loop over that list of rules and call UpdateItem if the rule matches. That's the entire logic of this UpdateQuality method now. So it's a lot simpler, although it could be a little easier because right now it still has to know a lot about how to apply these rules. And remember, it's very important the order of these rules, at least NormalItemRule. That one has to be last. And right now there's nothing that really informs the developer of that, so it would be nice if we had a way to make that clear to the developer. All right, so what if we pull the rule engine into its own class? At this point, the UpdateQuality method can simply delegate to an ItemQualityRuleEngine and call its ApplyRules method. That's going to do all the work. So what does that engine look like? It basically has the same logic that was previously inside of UpdateQuality now embedded inside this engine. And the nice thing about it is that the NormalItemRule is always last here as well, and this is the only place that needs to know about it. So it's a little less likely that someone would screw this up because they'd only be in here if they were working on the rules engine itself. But this isn't very flexible, right? Every time we need to add another rule, we have to come into the rules engine itself and instantiate it right here and add it to that collection. It would be nice if there was some way for us to flexibly build an engine that had an arbitrary set of rules, but still was able to enforce that the NormalItemRule was always last. So, let's create a builder. We're going to use the builder design pattern in combination with the rules engine pattern to provide a very flexible approach. Now we've changed the rules engine so it just takes in a list of rules, but notice that that's a private constructor that's taking in those rules. What we've done is we've protected this rules engine, so there's no way to create it directly. You have to create it with the builder, and in this case, because we wanted to be able to protect against creating it directly, we've made the Builder as a nested class. So here is this nested public class Builder inside of the engine, and it is where you're going to add the rules. Now, the way the builder pattern works is you provide it with a bunch of methods that typically have names like with this or with that, and so here we're going to say I want to create this engine with Builder WithAgedBrie, WithSulfuras, WithConjuredItem, et cetera, et cetera, and when you're all done, you call Build. And the Build method is what is going to actually return back the fully instantiated engine. And here inside Build, that's where I'm going to tack on the NormalItemRule at the end. You don't have a choice about whether that one's there, right? If you just get an engine and you use the builder and you say Build, you can imagine it only works for normal items. There's nothing you can do about that. So this ensures that that will always be created in the correct way. All right, now, if you put that rule first, then it's going to hit everything. Right? None of your other rules will work. Now let's look at some of these rules. If we look at Aged Brie, you can see that its UpdateItem method goes and increments the Quality, decrements the SellIn, and then if the SellIn is less than 0, it increments the Quality again. If we look at the normal item, it's very similar. Decrement, DecrementSellIn, if we're negative, DecrementQuality. That is sort of a template, right? We could imagine three separate methods that you could override; one for decrementing the Quality just the normal way, one for doing whatever you need to do with SellIn, usually decrement, 90% of these rules just decrement the SellIn, there's only one exception to that, and then what do you do, if anything, when the SellIn is less than 0? So we can use another pattern called the template method pattern. We put the template method into the base type. So right now, our rule base just has an abstract UpdateItem. We're going to change that. We're going to get rid of that UpdateItem abstract, and we're going to provide a template method that is defined in rule base that you can't change, and we're going to provide different methods for each of those three parts that the rules have to override. Let's see what that looks like. Now here UpdateItem is our template method. Notice it's not virtual. You can't override it. It's not abstract, either. This will always be the UpdateItem method that gets called. Inside of it, it calls three other methods. It calls AdjustQuality, AdjustSellIn, and then AdjustQualityForNegativeSellIn only inside that if statement. So that logic is now embedded into the base rule. We don't need to have that logic in every other rule; however, we have to adjust those rules so that they now override the appropriate ones of these methods. The abstract ones they have to implement, the AdjustSellIn one they only have to do if they want to change it. So, by default, all of them are just going to decrement the SellIn with the exception of one rule, which is Sulfuras. So let's look at a normal item rule. Now our normal item rule just has to implement AdjustQuality and AdjustQualityForNegative. In both cases, it just decrements it by one. Looking at the Sulfuras rule, it has to override the AdjustQuality and AdjustQualityForNegativeSellIn abstract methods, it is the only one that overrides AdjustSellIn because it's the only one never changes its SellIn. And so while the default behavior is to decrement SellIn by 1, you can see on line 17 here that the AdjustSellIn for Sulfuras just does nothing. That's an example of some different ways that we can apply design patterns in the context of a kata. Real quick, in this demo, you saw how to use the proxy pattern to control access to a class. You saw how to use rules to break apart complex logic into simple classes that each do one thing, and then build a rules engine that applies those rules. You saw how to construct that engine in a flexible way using the builder pattern. And then finally, we saw how you can use the template method pattern to create a template for how certain steps must happen in sequence in a given set of subclasses. And then you can force each subclass to still follow that same sequence, but customize how each step works based on that subtype's behavior.

A Few Good Design Patterns
I promised that I would recommend a few patterns to investigate before this course was over. So here are a few good patterns for C# developers to understand if you're looking for a starting point. The strategy design pattern is definitely one of my favorites. If you're working with systems that use dependency injection, you're already somewhat familiar with the strategy design pattern. It's definitely worth your time to become more expert with this pattern and to recognize where it applies and how to apply it with different variations. Another pattern that works very well with the strategy pattern is the repository. The repository is a data access pattern. There are many ways to apply it. There are a few ways to apply it incorrectly, but overall it tends to do a really good job of decoupling your system from its persistence concerns. And I really like this pattern because you can stack it with other patterns. For instance, I've done quite a bit of work with cached repositories, which you could search for and you'll find some articles I've written on it, which takes the repository and combines it with other things, like a decorator and strategy pattern to make it so that you can easily get huge performance wins in your applications. Another one of the most common patterns is the adapter. You're probably already familiar with this, even if you don't necessarily recognize its name or its structure. You should investigate this course and learn a little bit more about how the adapter pattern works and how how to apply it. And then, once you understand that, you'll see opportunities to use the adapter all over the place in your code, even after you're out of that overzealous stage of learning. Frequently in our systems, we may have objects that are somewhat difficult to create. The factory design pattern is an excellent pattern for you to recognize and understand. This pattern is tightly related to the idea of an IoC container, which I like to say is basically just a factory on steroids. So if you have a good understanding of the factory design pattern, it will also help you understand dependency injection and IoC containers even better. Next, you should probably understand the proxy and the decorator patterns. These two patterns are very closely related, but they have different intents. Structurally they're almost identical, but the way we use them and the reason we use them differs. And both of them are very common, as well as very powerful patterns to use, and they're extremely useful for stacking with other patterns. And then, lastly, I think you should be familiar with the singleton pattern. This pattern almost wasn't covered in the gang of four's Design Patterns book because they didn't think it was a good pattern for them to discuss. Ultimately, it did get included, but there are still many today who consider it to be an anti‑pattern. You should understand how to apply the singleton in the proper way because it's easy to get wrong, but you should also understand how to solve the problem that singleton solves in other ways that might be more appropriate. Also, if you're looking to learn domain‑driven design, check out the DDD Fundamentals course, which also introduces the basic design patterns that are used in DDD.

Key Takeaways
Let's review the key takeaways from this Design Patterns Overview course. First, we learned that design patterns are general solutions to existing problems. They apply to a certain context, and initially, they weren't even a software concept, but the idea was borrowed from city planning and building architecture. Patterns are worth knowing for a variety of reasons, but most importantly, they will help you to avoid reinventing the wheel and trying to come up with a solution that may be sub‑optimal when a well‑known and proven solution already exists. Further, using patterns, you can have higher‑level conversations with your team, and you can communicate your intent more clearly in your code. Although the topic of design patterns is quite expansive, you learned about the value of having a T‑shaped knowledge of patterns. That is, you should be familiar with a broad range of patterns, but you should also go deep in your mastery of those patterns that are most relevant to the kinds of software you write. When it comes time to apply patterns, especially while you're still learning them, be sure to practice and be sure to follow good refactoring techniques. There are several courses that can help you with refactoring here on Pluralsight. Finally, I recommended a few good patterns for you to investigate. I also suggest that as you start learning more patterns, you look for ways to combine them. Often, the most powerful and elegant solutions come from the application of a few different patterns in combination with one another. Thanks for watching this course! I hope you found it helpful. You'll find the demo code in the course download, but also the latest version will always be available in my Design Patterns GitHub repository here. Don't forget to leave a review, and if you have any questions, leave a comment, or find me on Twitter as @ardalis. Until next time, keep improving!