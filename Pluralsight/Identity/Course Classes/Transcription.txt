Course Overview
Course Overview
Hello. My name is Roland Guijt, and welcome to my course, Authentication and Authorization in ASP.NET Core. I'm a Microsoft MVP, an independent consultant, and trainer based in The Netherlands. The objective of this course is to give you a thorough understanding of the modern authentication and authorization aspects of an application architecture, while at the same time giving you the ability to implement these aspects in your ASP.NET Core application. Some of the major topics we will cover include authentication with and without the Identity Framework, utilizing centralized authentication using an identity provider, and applying authorization with policies. By the end of this course, you will understand the internals of ASP.NET Core authentication and authorization, plus you will be able to implement both. You will even have the skills to build your own identity provider. Before beginning the course, you should have at least getting started‑level knowledge of ASP.NET Core. Get ready to secure your application in the right way with my course, Authentication and Authorization in ASP.NET Core, at Pluralsight.

Understanding Authentication and Authorization in ASP.NET Core
Introduction
Welcome. By the end of this module, you will have a good understanding how ASP.NET Core authentication and authorization in its basic form works. I'll start with comparing authentication with authorization, and you'll learn what claims‑based authentication means. The identity cookie is ASP.NET Core's way to keep track of who logged in. We'll see how to use cookie authentication in its most basic form, without a framework like ASP.NET Core Identity. You'll also get to know the role of the ClaimsPrincipal object, as well as how to use external identity providers, like Google, to log in. All this will not only give you the ability to implement authentication from scratch, but it will also give you the foundational knowledge to understand the rest of the course.

Authentication and Authorization
To explain the difference between authentication and authorization, I'm using an analogy. First, authentication. When you go to a hotel with a reservation, the first thing they ask for is some form of ID because only then they know for sure you are who you say you are. They know that because there are certain claims on the document, like your name and your birth date. These claims make up your identity. Authentication is about determining the identity of somebody. In a world where everyone is 100% honest, it would be enough to just ask a person for their identity. But unfortunately, that's not the case. We have to have some proof that the person is telling the truth. The hotel needs a passport. An application often needs a password. In an application, typically a password has to be given to check to see if the username you provided is really you. When that's out of the way, other claims about you are made available to the application, like birth date, place of birth, etc. But claims can also be organization specific like employee number or department. In ASP.NET Core, you can choose from a number of options to authenticate. I'm covering the current recommended ways to do authentication in this course. The most basic one is just the Identity cookie support in ASP.NET Core. ASP.NET Core Identity also uses that, but offers a complete framework around it. And finally, if authentication has to go beyond the scope of just one application, we can use an OpenID Connect identity provider. Now, what is authorization? Back to the analogy. After the hotel makes sure who you are, you're handed a hotel key, but not before certain claims are checked on the passport. Maybe the hotel clerk just checks your name claim, but he might also check your birth date claim. The hotel key only gives you access to certain parts of the building. You can, of course, open the door of your own room, but also the door to the pool, but not the doors of other rooms. So the key offers you limited access to, in this case, the hotel building. That is called authorization. It's about what somebody can do, but what somebody can do can only be determined if there was some form of authentication first. Authorization is built into ASP.NET Core in a sophisticated way. I'm going to cover that in the final module of this course. But first, let's build some authentication in an existing app in the next clip.

Setting Up
Here's the app we're working with in this course. The starting code doesn't have any authentication or authorization in place. It's called ConfArch, and it is intended for conference organizers. There are a couple of conferences already in the database, and new ones can be added by using the Add button. Each conference has talk proposals that are sent in by speakers. These are accessible with the Proposals link. On the page that follows, proposals can be approved, and new ones can be added. This is an MVC application, but the cool thing about ASP.NET Core is that all application types use the same authentication and authorization mechanism. So if you're using Razor Pages or Blazor, everything that follows will be the same for you. The app accesses a SQL database using Entity Framework. If you want to run the demo code, first, make sure you create the database by running the migrations. Type update‑database on a command prompt in the project folder. By default, a SQL Server LocalDB database will be created called ConfArch. If you don't like that, feel free to change the connection string in appsettings.json first. The application uses two assemblies, one with all the data‑related stuff like the entities, the migrations, the models, and the repositories and one which contains the controllers and the views. If these terms don't sound familiar or you're missing basic ASP.NET Core knowledge, I would recommend to stop watching this course for now and first watch my course, Understanding ASP.NET Core 3.x. Explaining the source code we're starting out with is out of scope for this course.

Adding Cookie Authentication
Let's build in some authentication into this application. In the start up class of the Conf.Arch.Web assembly, in the ConfigureServices method, we configure authentication by calling the AddAuthentication extension method on the ISserviceCollection object. On the object we get back from that we're calling AddCookie to AddCookie authentication. This adds an authentication scheme to the configuration. An authentication scheme is just a way to do authentication, and there can be multiple ways to do that. Quick analogy, in real life, you can authenticate with your passport, but when you go to the gym, you need to show your membership card. Each time you configure an authentication method, you have to specify and name for the authentication scheme, which serves as the lookup string for the authentication methods configured. But hold on, Roland, I hear say, we just added cookie authentication, and you didn't specify a name. You're totally correct. If you don't specify a scheme name when calling AddCookie, by default the scheme name Cookies is used. If you don't like that, just specify the name you want as the first parameter. But for now, I'm fine with the default. There's another thing. Later, we're going to do checks to see if a user is authenticated. ASP.NET Core has to know the default scheme it has to use for those kinds of checks, as well as certain actions that can be run against the scheme. I cover these later. You can specify a default scheme as the first parameter to add authentication. So in this case, this would be Cookies. Luckily, instead of having to specify a magic string like that, you can also use CookieAuthenticationDefaults.AuthenticationScheme, which contains the static string value Cookies. Now that we've configured cookie authentication, we have to place a piece of middleware that does the actual authentication in the pipeline. We do that in the configure method. The order in which you specify middleware is important, especially with authentication and authorization. Place the middleware between UseRouting and UseEndpoints, so it knows at which endpoint the request will arrive. Never do it after UseEndpoints, because then authentication will happen after requests ends over the endpoint. We can set up the middleware by just calling UseAuthentication on the app object. UseAuthorization is already there. It was already there because it is in the starting template of an ASP.NET Core web application. To test things out, switch to the ProposalController and decorate the class with the authorize attribute, which is an authorization filter. It ensures that nothing in the controller can be accessed if a user is not authenticated. The name authorize might come across as not very logical, since we're just working on authentication, not authorization. But picture this, we're back at the hotel, the checked in guest goes to breakfast. To enter the breakfast area, in other words, to be authorized for the breakfast area, she must show her hotel key to prove that she is checked in, in other words, authenticated. So placing the authorized attribute like this authorizes just authenticated users to enter this controller. The authorize attribute checks the default scheme we just configured. If you wanted to check another scheme, you can do so by setting the name of the scheme you want to check in the authentication schemes property. The authorize attribute is also used in Razor Pages. You can just put it above the page model class there, and in Blazer, you can use it to decorate your code behind file or use the at attribute directive in the markup of your pages. The authorize attribute can also be used on individual actions in the controller like this. So you could just go into your application and use the authorize attribute many times to secure your application. Controllers and actions that don't have the attribute, intentionally or unintentionally, are unprotected. I don't like this unsecured by default scenario very much. to make the application secure by default register authorize as a global filter. That means that it is implicitly applied to all controllers. If you're using Razor Pages, you can apply the authorized attribute to all pages like this. Now every controller in our MVC app needs a logged in user. To opt out of that, we can use the AllowAnonymous attribute. For now I'm using that on the ConferenceController. When we now run the application and click on the Proposals link, which redirects to the proposal controller, we see an error page. The Cookie scheme seems to want to redirect us to Account/Login, but there's nothing there. In the next clip, we're doing something about that.

Logging Users in and Out
We just saw that ASP.NET redirects to account/login when an unauthenticated user tries to access a part of the application that is protected with the Authorize attribute. I want to show a login page to let the user authenticate and then redirect back to the URL he came from. By the way, if you don't like the account/login path, you can also change that by setting LoginPath when configuring the cookie scheme. But we are leaving it at the default setting right now. I've prepared a new AccountController with a getLogin action that shows the login page. Don't forget to decorate it with the AllowAnonymous attribute. This action will be triggered when cookie authentication tries to access account/login because I'm using default MVC routing. When you're on Razor Pages or Blazor, you can just create a page at this path. This action captures the return URL. That's the URL the user came from. Return URL is automatically passed in by ASP.NET by using a query string. When Login is called directly by the application, for example with a Login botton, there is no return URL. I then default to root. The method returns a View with a LoginModel with a ReturnUrl property. In the class is also a Username, Password, and RememberLogin property. The view uses bootstrap and tag helpers to render the form. In the AccountController, I've added an action that captures the submitted form. Again, it needs AllowAnonymous. In the action, I'm asking a userRepository object to get me a user given the username and a password that was entered in the form. The userRepository doesn't use a database right now. I just have an in‑memory user defined in it. The password, in this case, is a string secret. But note that that is not a string in the repository. It is a hash of that string. A hash is a cryptographic function that transforms data into a string of a fixed length. There is no way to transform the fixed string back to the original data when the hash is of sufficient strength. You should always store passwords as hashes in your data store. And then when a user enters a password, create a hash of the password typed in by the user and compare that to the hash in the data store. I'm using an extension method included in the project for that. With this precaution measure, a potential attacker who somehow gains access to the data store doesn't have all the passwords for all users. Okay, back to the AccountController. When no user is found, the Unauthorized HTTP result is returned. If there is a user, we construct a List of Claim object. Claim is a class with a type and a value property. Remember the hotel example. When there's a place of birth on your ID, the claim type could be the string place of birth and the value is the actual place of birth. In the constructor of the Claim class, we can specify the claim type and the claim value. In this example, we use four claim types. Three of them are standard claim types, the names of which can be found in the static class, ClaimTypes. These are NameIdentifier, Name, and Role. The other one is a nonstandard claim time, something specific for my application or organization. In this case, the only slightly non‑boring example I could think of was FavoriteColor, but it could, of course, be anything. NameIdentifier is a claim that uniquely identifies the user. It is also known as the subject ID. Once we have the list of claims, we are to create an identity object of the type ClaimsIdentity, specifying the claims and the scheme this identity is for. The last step before we can actually sign the user in is creating a ClaimsPrincipal object with the identity. Now what's that all about? In ASP.NET Core, the object that represents the user is called a ClaimsPrincipal. The ClaimsIdentity contains an identity object for an authenticated scheme. If your app only uses one scheme, the ClaimsPrincipal will contain just one ClaimsIdentity object. But if an application also uses a scheme to, for example, log into Google, which I will add later in this module, there could be more. All ClaimsIdentity objects will contain claims, and all the claims from all ClaimsIdentity objects combined are made available as a property in the ClaimsPrincipal object. The property is simply called Claims. Now that we have all the necessary objects, we can sign the user in by calling SignInAsync on the HttpContext object. As the parameters, we have to specify which scheme we want to use to sign in, as well as the ClaimsPrincipal object, and some options can be set by creating an AuthenticationProperties object for the third parameter. In this case, I'm making the identity cookie that is set as the result of the sign‑in persistent, but only of the user checked the Remember me checkbox in the login form. That means that the cookie will persist even when the user closes the browser. You can limit a lifetime of a persistent cookie in a production app by setting the ExpiresUtc property. Finally, when the cookie is set, we redirect the user back to the URL he requested before the login page was shown. I'm using LocalRedirect instead of a NormalRedirect to make sure the redirection only happens to a URL of our application. This is needed to protect against open redirection attacks where attackers let users click a link where the login page redirects to the attacker's website. Now let's run the app. When I now try to access the Proposals controller, the login page is shown. Note that the return URL is passed in. When I enter the credentials, roland and secret, I'm redirected to the Proposals view, so it works. Logging out users is pretty straightforward. You can just add a Logut action in the AccountController. In it call SignOutAsync on HttpContext, specifying the scheme, after which I redirect to the root of the app. The next step is to make it more visible for the user that he is logged in, and that's for the next clip.

Understanding and Accessing ClaimsPrincipal
In the last clip, I mentioned that when we sign in a user, a cookie is set. This cookie is called the identity cookie. But why is that cookie needed? Typically, a web application is stateless, and processes requests of potentially many concurrent users. A cookie is a way to know which request came from which user. Once we sign in the user, our application puts all user information in the cookie, including the claims, and encrypts it using a key only the server‑side application has. That same key is needed to decrypt the cookie. So when the cookie arrives in the browser, nobody can read it. Cookies are sent along automatically with each new request through the same server. When the server gets it, it will decrypt it using the key, read the user information, and reconstruct the ClaimsPrincipal object that is made available in the application. In ASP.NET Core, encryption works with a framework called data protection, which is used behind the scenes, which is automatically configured when you add cookie authentication support to your application. Data protection takes care of storing the key securely, and it rotates the key periodically. Let's run the project again and log in. When I open the F12 tools of the browser and take a look at the cookies, you can see ASP.NET's cookie is here. It's called AspNetCore.cookies, and it is indeed hard to read. When I now log out by calling the Logout action by typing account/logout in the address bar, the cookie disappears. Okay, so the cookie reconstructs the ClaimsPrincipal. But how is ClaimsPrincipal made available to us? Well, to illustrate, let's display a greeting when the user is logged in. We do that in the layout page. There's a convenient property available in controllers and views called User. The User property is of type ClaimsPrincipal. On the ClaimsPrincipal is a property called Identity. This is the primary identity of the ClaimsPrincipal. That is the identity that was created the first time the user logged into a screen. On the ClaimsIdentity object is a property to check if the user is signed in or not. If that's true, I display a greeting with a link to the Logout action. If it's false, I display a Login button that redirects to the Login action on the AccountController. The User object also gives us access to the claims of the user. We can also check if the user has a certain claim to do authorization in the app. With that information, you can, for example, display a piece of UI or not or check a claim in controllers. But in general, don't do this. There's a nicely centralized way to do authorization. I'm explaining that in a later module. But for demo purposes, I'm adding this Razor code to the index view of the ConferenceController, and that is our landing page for the application that displays the claims of the authenticated user by iterating through User.Claims. When I run the app, there's now the Login button I can press. And when I'm logged in, the Logout button is shown. And I can see the claims we associated with the user when we signed them in. Identity cookies are great, but they have a problem, especially when you use the persistent cookie option I showed you when the user selects the Remember me option in the login page. These cookies potentially remain valid for a long time. Let's say an employee has authenticated and gets fired. He will have access to the application until the cookie expires. Luckily, we can also react to events in the ConfigureServices method by creating a CookieAuthenticationEvents object and put that in the Events property of the options object. Besides the event we need, OnValidatePrincipal, there are several more events to react to. OnValidatePrincipal is the one in which the status of the user can be checked if needed. It fires when the application receives the identity cookie. You can look at the claims of the principal to see if a user is allowed in or not. If the user isn't allowed access, call context RejectPrincipal and sign the user out so that the cookie disappears. The next clip is about external identity providers like Google and how to integrate these into your app.

Understanding External Identity Providers
It's great that users can have a username and a password to authenticate with our app. But maintaining credentials for every web app out there is a hassle for the user. In this clip, I'm talking about leaving the login process to common external identity providers. Here's a list of them. They are all supported by installing NuGet packages. The listed ones are maintained by Microsoft, but there are many community projects out there that complement this list. As an example, we're going to use Google to log users in. I'm picking one external identity provider because the process to add others is very similar. Before we write the code, first some explanation about how an external login process works. When the browser does a request and the server wants to authenticate the user, instead of showing an in‑app login page, we redirect to the external identity provider, in our case Google, to login. Google needs to know which application is trying to authenticate. So we're sending along a client ID and a client secret. These credentials have nothing to do with the user. They are needed for Google to know which application does the login request. How do we get these credentials? Well, we have to register the application at Google. I'll show you that in a second. When the user logs in with Google, Google does an HTTP request, delivering a token at a special URI called the redirect URI. This URI has to be known at Google, and it is part of the registration process we're doing in a second. In the token are Google's user claims, which are then used to create the ASP.NET identity cookie. On subsequent requests, the identity cookie is then used as normal to recreate the ClaimsPrincipal. Google is not needed anymore once the user is logged in. This authentication process with tokens is described in standards called OAuth and OpenID Connect. In the module about centralized authentication, I'll explain more around that topic. Now let's get the Google credentials. An easy way to register an application in Google is by using this page. You need a Google account to use this. After you log in at Google, when you press Configure a project, we get a wizard. We can create a new project, giving it a name, and we can then use a friendly name for the application that will be shown in pages Google will show to the user. Next, we have to tell Google which kind of application this is. For an ASP.NET Core application, choose Web server. Now enter the redirect URI, which is the URI where the application is running on followed by /signin‑google. This is the endpoint the middleware is going to listen to to receive tokens when we have configured it. We're running localhost right now since we're still testing. When this app goes to production, you should add the production URI as well. On my machine the port is 5001. But on yours, that might be different. Please check that. When I now press Create, I get a client ID and secret. Copy and paste these to a text document or something. We will need both in the part that follows. You can also download the entire configuration.

Adding External Identity Providers
In the ConfArch project in Visual Studio, we have to install the Microsoft ASP.NET Core authentication Google NuGet package. Once we have it, we can go to the Startup class, and after AddCookie and ConfigureServices, type AddGoogle, followed by a lambda that gets on options object. On the options object, we can specify the client ID in secret, but it's a bad idea to put secrets in source code directly. Instead, use a configuration object to get them. You might think, oh, so I'm putting client ID in secret in the appsettings.json then. That works, but it still isn't great because that file is also checked into source control. A good way to do it is to add ID in secret with a secret manager tool. Right‑click the project and select Manage User Secrets. This will also edit the file, but that file will only be available on this machine and will not be checked into source control. Selecting the Menu option also adds a UserSecretsId to the project file. That is used to make sure the secrets we added will only be available to this application. You can't see it, but the secrets.json file is in a directory with this ID. You can also add secrets from the command‑line. First, run the init command to create a user‑secrets ID, and then you're good to go adding the secrets you want. These secrets are automatically made available in the Configuration object, so the code that gets them remains the same. With a call to AddGoogle, an authentication scheme is added to the application. The name of the scheme is simply Google by default. Would we run the application now, it would just work as before, without Google. Why is that? Because we have set the default scheme to the cookie scheme. That means that all scheme actions are done on that scheme. There are three scheme actions. Authenticate is about how the claims principle gets reconstructed on every request. Since we're using the cookie to do that, we want to keep it as it is. The challenge determines what happens if the user tries to access a resource for which authentication is required. We already saw that the cookie scheme will redirect to account/login by default when that happens. We want to change that now, since we want Google to take care of logins. Forbid determines what happens if the user accesses a resource she can't access because she doesn't have the rights. The cookie scheme will redirect to account/accessdenied by default, and that's still what we want. So we want to keep all actions at the default scheme, except the challenge action. We can configure that by using a lambda with an options object as a parameter where we do the call to add authentication. We set the DefaultSheme to Cookie like before, but we want to make an exception for the ChallengeScheme, setting it to Google using a static class that came with the NuGet package. When testing this out, don't press the Login button because that explicitly redirects to the login action in the account controller that signs in using the cookie scheme. But when I press the Proposals link, I get a Google login page. Notice the friendly name of the configured application, and on the next page, Google warns that ConfArch will get my personal data if I continue, and I get a Google two‑factor authentication screen because my Google account has that enabled. By the way, I get a login page only because I was not already logged into Google with my browser. If that was the case, I would be automatically logged in. That is called single sign‑on. Let's take a look at the claims Google sent. They all use the prefix we saw earlier. They are standard claims. The name identifier is now the user ID from Google. We have a name, which is my full name, and also given name and surname. And the email address is now a separate claim. Our greeting now shows my full name because it still uses the name claim, which now comes from Google. This works like a charm, but my enthusiasm about this is not at its peak yet. We're totally dependent on Google now, and we still have the Login button that logs the user in with the local account. Stay tuned, because in the next clip, we will fix all this.

Working with Multiple Identity Providers
Users can now only log in with Google, and all claims come from Google. What about our local claims like favorite color and row? It will be great if the user could log in with Google and the application could issue its own claims. And letting the user choose a login method might be more user friendly than just defaulting to Google. Let's work on that. In the login screen, I've added an extra login button with Google, which points to an action in account controller login with Google. It passes in the return URL. Since we now want the login page to be shown every time when the user tries to access a resource that requires authentication, I'm commenting out the DefaultChallengeScheme in the startup class because now we want to execute the login action on the account controller again, and that's done by the Cookie scheme. Remember, the LoginWithGoogle action must be marked with AllowAnonymous. It returns a Challenge result specifying the name of the scheme that has to be challenged. It also passes in an authentication properties object that has a redirect URI. This is not the redirect URI Google uses to deliver the token. It is simply a method that gets called when the authentication at Google is complete. In that callback method, I can access the dictionary property Items, and that way I can send context information along, in this case, the return URL, but it could be anything. When Google authenticates the user, I wanted to set a cookie. In the startup class, I'm creating a Cookie container for it with another call to AddCookie. I then instruct the Google authentication scheme to use a new Cookie container for its sign in action. I've created the ExternalAuthenticationEefaults class myself. The value of AuthenticationScheme is a string external identity, but it could be anything. Back to the account controller in the GoogleLoginCallback method, I'm now pasting in, I'm reading that Cookie. The result object lets me access the claims principal of that scheme, of which I can get the claims. Note that these are Google claims. I have to somehow associate the Google user to the local user. The way to do that is to get the user ID Google uses, the subject ID, it is in the NameIdentifier claim. Once I have it, I'm accessing my user repository to get the entity. You might have noticed that I gave myself a Google ID already. A user doesn't know the ID, of course, so you could somehow create functionality in your application that auto associates the user with Google. You could, for example, look at the email address claim Google returns and match that. For simplicity's sake, that is out of scope now, but it could be a homework challenge. Get it? Okay, when I have the entity, I can just create the claims list, as before. I'm not doing it here, but of course, you also have the option to reissue the claims Google returned. That process is called claims transformation. I construct the identity and claims principal object and sign in the user, but not before deleting the Google cookie we used. Finally, I'm redirecting to the return URL. I passed it to the callback method in the Items dictionary, remember? I can get to that using Properties on the result object. Now the magic moment, let's run. I'm trying the Proposals link again, and the login page is there with a Login with Google button. Let's go for it. I'm already logged in with Google, so I don't have to enter credentials. And bam, it works. When I go to the home page, our own claims are visible.

Summary
Here's the summary of this module. We showed the factors at play with authentication, user information in the form of claims, and we showed you how to issue claims. Also, authorization is something you can do after authentication. We covered some basic examples. We then took an application and implemented authentication to see how it all works in its most basic form with the Identity cookie and the ClaimsPrincipal object that contains the identities of the user. Finally, you are now up to speed on how to use external identity providers like Google to do your bidding. In the next module, we're taking a look at ASP.NET Core Identity, a framework that can save you a lot of work while still using cookie authentication.

Implementing Authentication with ASP.NET Core Identity
Introduction
ASP.NET Core Identity is a framework built around the cookie authentication we did in the previous module. At the end of this module, you'll know the ins and outs because I'll show you how to create a new project with it and how to retrofit it into an existing project. Along the way, you'll learn the various aspects of Identity, such as how Identity stores its data and how it is configured, and Identity's UI and helper classes. You'll see how claims work in Identity and how you can assign them to the user. And roles are supported, but have to be enabled. Two‑factor authentication is also something that's delivered out of the box. And finally, we'll configure external identity providers.

Creating a New Project
Let's discover what the ASP.NET Core Identity framework is by creating a new project that uses it. In a dialog it lets us select a template. Choose an ASP.NET Core Web Application and then the MVC option. By default, there is no authentication configured in the initial project. We're changing that. Select the option Individual User Accounts, and leave the drop‑down as it is showing Store user accounts in‑app. If you don't use Visual Studio, it's also possible to create a project template with the .NET CLI. When we run the resulting project, there are Register and Login links on the home page. When I press Register, there's a nice registration page. Notice the path it is on, /Identity/Account/Register. I fill out my email and password. My favorite password is secret, but don't tell anybody else. The validation of the page prevents me from using that password. Secret isn't a strong enough password, obviously. I'll change it to something that complies with the password restrictions. We see another page. Identity uses a database that has to be created first. We're getting instructions on how to run the necessary migrations. Alternatively, there's a convenient button with which we can do that. When the migration's complete, I can refresh the page, after which I'm told that no real email sender is configured, so no email can be sent out to confirm my account. We'll fix that later. For now, I can just use the link to confirm my account. The new user is created, and I can log in using the new credentials. Instead of the Register and Login link, the application now shows that I am logged in. So what is Identity? Identity uses the same authentication mechanism we saw in the previous module, cookies. The advantage of Identity is that there are helper classes that prevent you from writing potentially complex code yourself, and all the UI you need around authentication is also contained in Identity. Even the Entity Framework DbContext and its entities are there out of the box. We don't have to write code to log in a user, to register a user, or to reset a forgotten password, for example. At the same time, Identity is designed to be customized. There's a default way in which Identity works, but if you want to deviate from the default behavior, you can, in most cases. Identity also works with sensible default settings like the password policy, which can also be changed. Here's an overview of the most important features of Identity. These are all things needed in almost every app that does authentication. Instead of writing all these ourselves, we can save a lot of time by letting Identity take care of them. But how does Identity pull that off? We're diving into the answer of that question during the rest of the module. We'll start by exploring the data store Identity uses in the next clip.

Examining the Data Store
Part of the project template we've created is a data folder, in it, is an ApplicationDbContext class and the migrations for it. We just ran the migrations where we pressed the blue button. Things like DbContext and migrations are used in Entity Framework. If you're not familiar with Entity Framework, I would recommend watching a course on that topic first. I'm assuming Entity Framework knowledge in this course. When I open ApplicationDbContext, there is not a lot to see. Its constructor is in a format needed to configure it using the Configure Services method, something we'll see in a minute. Instead of deriving directly from the DbContext, however, it derives from IdentityDbContext. This is a DbContext included in the Identity framework. That class derives from a generic version off IdentityDbContext. That generic version inherits from several more ancestors until the final IdentityDbContext arrives from the Entity Frameworks DbContext. The first generic parameter is the entity it should use for the user, the second is the entity used for a role, and the third, the primary key type for both. The identity user and identity roll classes are also included in the Identity framework. When I take a look at the code for IdentityUser, it derives from IdentityUser of string where string is a primary key type. In that generic version of IdentityUser, the generic parameter is called TKey. We can see it is used as the type for the ID property. There are also a lot of other properties that are typical for a user, such as email, username, password, hash, etc. The code for identity role follows the same structure, but has less properties. Identity role basically just contains a name. Now let's switch back to the ApplicationDbContext class included in the project. Why does it derive from Identity DbContext? Because Identity DbContext contains all the DbSets, in other words, the tables needed for identity. At the same time, you can easily add your own application specific DbSets to this ApplicationDbContext like a DbSet of Product like this, but this is just an example. Let's take a look at the generated database. It has a machine‑generated name. When we created a template, the connection string for the DbContext was also generated, and was put in the appsetting.json file. When we ran the migrations, Entity Framework used that name to generate a new database. It's totally fine, of course, to change the name to whatever name you want. All the table's Identity users are added to the database by the migration, their name is prefixed with AspNet. One of the tables is AspNetUsers, it has columns that correspond to the properties we just saw in the Identity User class. The same goes for AspNetRoles, which has the properties of identity role. If you don't like the names of the tables, you can change their name by overriding onModel creating and use a configuration API of Entity Framework to rename them. If you're okay with the structure of the default entities used, such as identity user and identity role, setting up is typical for identity, it provides you with sensible defaults to get going straightaway, but also typical for identity is that we have the ability to deviate from defaults. Let's say we need an extra column in the AspNet users table called career started, which is the date the current career of the user started. With the info you got until now, can you figure out how to do it? Create a new class that represents your user. Let's call it ApplicationUser for now, derive that class from IdentityUser, the User class built into identity. Add the CareerStarted property, which we decorate with the PersonalData attribute, identity as a feature with which users can delete their account. When that happens, all data marked with this attribute will be deleted. Users also have the ability to download their personal data. Adding the attribute also makes sure that, in this case, CareerStarted is included in the downloaded data. We'll see these two features in action soon. Now in ApplicationDbContext, instead of deriving from IdentityDbContext, they arrive from one of its generic versions. One of them just takes one generic parameter for the user, that's the one we need. But if you need further customization for roles or some of the other entities, you can just use a more specific one. Since we only have a custom user, I'm using the IdentityDbContext that accepts just the generic parameter for user. As we already generated the database, the next step is to add a migration and then update the database. The CareerStarted column is now added to the table. If you want to use other data stores for all or parts of the data Identity uses you can, explaining that part, however, is beyond the scope of this course. But if you visit this URL, you can see how it works. We're taking a look at the Startup class of the project next.

Configuring Identity in the Startup Class
I've opened the startup class of the project to see how Identity is configured there. In the ConfigureServices method of the startup class, the identity framework DbContext is registered. Then Identity is configured with a call to AddDefaultIdentity. Here we have to specify the user type we want to use because a number of classes that are registered in the dependency injection container with a call to AddDefaultIdentity are generic, and the generic type is a user class. Since we made a classic that derives from IdentityUser that added the CareerStartup property, I have to change the default IdentityUser to ApplicationUser here. Identity has a lot of settings that all have default values. We can deviate from the defaults by specifying a lambda that gets an identity options object. With the out‑of‑the‑box configuration, it is not required to have an account that was confirmed by email to login, but in the project template, we deviate from that default. In the options object, the many settings are categorized. There are settings that have to do with an account lockout, with passwords like the password policy, with sign‑in, with stores where the needed data comes from, and with generated tokens needed to make things like password resets secure. As an example, let's say we want to adjust the default password policy. We don't want the requirement of a non‑alphanumeric character like a star, dollar sign, or exclamation mark. To make this happen in the password category, we can just set a property to false. To find out more about the many configuration options, take a look at this URL. On the object that comes back from the AddDefaultIdentity call, we can then call other extension methods. Here AddEntityFrameworkStores tells Identity to use the application DbContext to get its data. Out of the box, just Entity Framework is supported, but other ORM vendors could create their own extension methods for Identity as well. There are a number of other extension methods that let you customize identity to the max. Identity contains classes to help with sign‑in, creating users and roles, and validate passwords. You don't have to write any of these because out‑of‑the‑box versions of these types are included. But if you want, you can create your own. You could, for example, create a user manager class from scratch or derive from the default UserManager and then tell Identity to use it by calling the AddUserManager extension method. Let's take a look at the configure method now. A call to AddDefaultIdentity also sets up cookie authentication in the same way we did in the previous module. It does that internally. To activate that in the pipeline, a call to UseAuthentication in the configure method is needed. There is something odd going on here. In UseEndpoints, both MVC and Razor Pages endpoints are set up. We chose the MVC project template when we created this project, so that explains to use of MapControllerRoute, but there's also a call to MapRazorPages. Let's investigate this mystery in the next clip.

Identity's UI
So why is Razor Pages support configured? By the way, if you're not familiar with Razor Pages, now would be a good time to watch my explanation of it in the course, Understanding ASP.NET Core 3x. Let's go on a quest. Find the identity views, such as a Login page and the Registration page. Let's open the Views folder first. There is a Home and a Shared folder, no sign of the identity views here. Wait a minute. There is also an Areas folder, let's open that. Ah‑ha! An identity folder, it makes sense because when we redirect it to the Login and Registration page, the first part of the URL was the string identity. There is the subfolder pages, so that's why a support for Razor Pages is needed. UI of identity is not in the form of MVC views, but they are Razor Pages. Let's quickly open that folder. Bummer. No Razor pages, just an _viewStart.cshtml, which checks the Layout page to the Layout page in the Shared folder on the views. So where are the Razor Pages? The answer lies in the projects dependencies. When we open packages, there is a NuGet package Microsoft ASP.NET Core Identity UI referenced, that's where the Razor Pages reside. Now I hear you think, hold on, Roland, those pages are fixed. I want to customize them. Well, you can if you want, but first you have to ask yourself the question if that's needed for every single page. All pages have a neutral layout and already use the layout page of the project because of the _ViewStart.cshtml, so things like the logo and the menu are already displayed. Chances are that you want to customize pages like the Registration page, but the probability that you'll want a change to the page to confirm an email address is lower. Here is an overview of the different categories of UI that Identity provides out of the box. There is, of course, a Login and Logout page. Users can send an email asking them to confirm the email address, there is UI for that. There are pages to let the user change the password as well and for when the user forgets it. I already showed the Registration page. An account can also be locked out, that happens by default if the user enters a wrong password five times. There is a page that notifies the user that the account is in the locked‑out state. Two‑factor authentication also needs UI to log in with it, but also to give the user the ability to enable or disable it. And finally, I mentioned personal data that is downloadable and removable by the user. A number of pages I mentioned can be examined when we run the project again, but wait a minute, I'm getting an Error page, something about a user manager of identity user that can be injected. The cause is some piece of identities UI that is not in the assembly with the Razor Pages. You can find it on the Views, Shared, and there is _LoginPartial.cshtml. It's the area on the page where it shows the logged in user or the Registration and Login buttons. This partial view gets SignIn manager and UserManager of IdentityUser injected. Since the types SignIn manager and UserManager of ApplicationUser are now registered in dependency injection container, we have to change this. When I now run and click on the email address when logged in, the page used to change my profile, email address, password, and two‑factor authentication settings are all there, as well as the functionality for personal data. If you want to know how to customize these pages, keep watching because I'll explain that in the next clip when we're retrofitting Identity in the existing confarch project.

Retrofitting Identity
Here's the existing ConfArch project we worked on in the previous module. We added cookie authentication without identity, but I've undone these changes, so this is the project without any authentication. I've copied over the ApplicationUser class that derives from IdentityUser, the one with a CareerStartedDate property. While we have it open, I'm adding another property, the string FullName. To start with Identity in an existing project, right‑click on the project, select Add and then New Scaffolded Item. That's an option that is also available when you don't retrofit Identity but start a project from scratch with it. Select Identity in the left pane, highlight Identity, and press Add. This installs a couple of needed NuGet packages. A dialog comes up. There are some options. The first one is the Layout page that has to be used for the Razor Pages of Identity. This Layout configuration will be added to the viewstart.cs HTML file we already saw previously. The layout page we already have in the project does the job perfectly. Next, we have an overview of every page that exists in the UI assembly, and we have the option to scaffold these out. That means they will be copied over from the UI assembly to the project so we can see and change them. I'm picking just a login page and the registration page for now. You also have to choose a data context class to use. The only option here really is to create a new one with the plus sign and accept the default name. Lastly, I can configure the user class, which has set to our ApplicationUser. I'm using the Add button, which again, adds some NuGet packages. One of them is a UI Assembly. When the scaffolder has done its work, we see this text file appear with some info and instructions. There's now code added for Identity under Areas/Identity, and configuration for Identity is done in a special file there. We'll take a look at these in a second. It then tells us to check if the static files middleware and the authentication middleware is configured. I already have static files. I'm adding authentication. Next, the text file suggests to check if MVC and Razor Pages are configured. I have AddControllersWithViews, which is fine, and I need to AddRazorPages in the ConfigureServices method. The text file is suggesting to call AddMvc, which configures both Razor Pages and MVC. You can either do that or add Razor Pages explicitly like this. In the Configure method I already have MVC in the endpoint middleware. I'm adding endpoints for the Razor Pages. The last action point in the text file is the instruction to create an initial Entity Framework migration and update the database with it. But before we do that, first let's take a look at the data context the scaffolder created. There's indeed in Areas Folder with an Identity subfolder. In that is a Data folder with a new DbContext. At this point, it makes sense to move the ApplicationUser class inside the Data folder. The DbContext derives from IdentityDbContext of ApplicationUser. And in the appsettings.json file there's a connection string added for it. It picked the project name as the database name. I'm changing this to something more to the point. Maybe you're wondering, since this application already has a DbContext, why do we need another? Well, we don't. We could just derive the existing DbContext from IdentityDbContext and create a migration for it. But since Identity is separated from the rest of the functionality in the application, it makes sense to separate the DbContext as well. If you do, you will still have the option to point the connection strings of both to the same database in the configuration file. But since we're creating an API in the next module that will access application‑related data, I'm keeping the two DbContexts in separate databases for now. It's time to create the migration. Because I have multiple DbContexts, now I have to specify for which one I want the migration. Updating the database with the migration also needs me to specify the DbContext. The scaffolder also generated a file called IdentityHostingStartup.cs. It has an assembly attribute in it that marks it as a hosting startup class. A class like that has to implement IHostingStartup, and it works like the startup class of the project. It is triggered whenever the application starts. In the Configure method, an IWebHostBuilder object is supplied, and with that, we can create additional lines of code for ConfigureServices and Configure. In this case, there's just code for ConfigureServices that configures the DbContext and Identity. I like the fact that this configuration specific for identity is in a separate file. If you don't, you can, of course, copy these files over to the regular startup class if you want. When I run the project now, I can test Identity by navigating to /identity/account/register, but I get an error about the Scripts section in the Layout page that isn't rendered. Apparently, the Razor Pages used this section, so I have to add it. It's a good thing to make it optional, in this case, or else every view that uses this Layout page must have a Scripts section, including the existing pages. While we're in the Layout page, let's also add the LoginPartial view in the page header, which was also scaffolded out the views/shared folder. There we go. Now we have the Register and Login links on the page, and when I press Register, the registration page shows. I can register a user, and the UI experience is exactly like I demonstrated earlier when we started a project from scratch. We're taking a closer look at what the scaffolder generated in the next clip.

Exploring Identity's Classes
We're taking a closer look at a LoginPartial view. We already saw that this partial view makes use of two of identity's helper classes, which are injected. They're already generically typed to ApplicationUser, our custom user class, because we configured our custom user class in the scaffolded dialog. SignInManager is used to check if a user is signed in by calling IsSignedIn passing in the claims principal. It can also be used to actually sign in a user in and out. When a user is signed in, UserManager is used to display the username by calling GetUserName, again passing in the claims principal. UserManager can also be used to add claims for a user, add users to a row, reset a user's password, and so on. Let's see what we got in the Pages folder under Account. I'm not showing you all of Identity's pages, but I'm covering the two we scaffolded to give you a feel of how they work. With that knowledge as a basis, you will be able to explore and modify the others on your own. First, the login page. It's a fairly straightforward form bound to LoginModel, which is the code‑behind class for the page. Note that there's the AllowAnonymous attribute decorating the class. In the constructor, the user and signInManager are injected. There's a BindProperty input that has the type InputModel. A BindProperty is a property that gets filled by the model binder when the form gets posted. The Input elements are binding to this property. The InputModel type is a class with three simple properties. In the OnGetAsync method, there is some housekeeping done to make sure we get a clean login. And in the OnPostAsync method, the method that fires when the user has submitted a login page, the signInManager is used to sign the user in. The parameters are the username, in our case, the email address, the password, whether or not a persistent Identity cookie must be set, and, finally, a Boolean that indicates if we want to use the lockout feature. It is now set to false. But if you want to lock the account after five wrong password attempts, set this to true. If you don't like the number five, you can, of course, change it in the Identity options. PasswordSignInAsync returns a sign‑in result object. That object can be used to see what the outcome of the login was. If it succeeded, we do the local redirect to the returnUrl. We got that URL as a method parameter. If two‑factor authentication is required, we redirect to another page. When the account is locked, we show a relevant page for that. Apart from the userManager and signInManager, the code‑behind for the registration page also gets an IEmailSender object injected. The page, again, uses an InputModel. And in OnPostAsync that fires when the user has submitted the registration form, it is used to create a new user object, and the userManager is told to create the user in the data store. The password is supplied separately because it has to be hashed. It is done automatically by Identity. It then generates an email confirmation token and a link to Accounts/confirmEmail. That link is put in an email so that users can acknowledge their email address. The confirmation email is sent using the IEmailSender object. When the option that requires a confirmed account is set to true, the user is redirected to the RegisterConfirmation page. If false, the user is automatically signed in with the signInManager. In the next clip, you'll learn how to customize Identity's pages, and at the same time, you'll know where Identity keeps its claims.

Working with Claims
In the Index view of the conference controller, which is the landing page, I'm adding the same piece of Razor I used in the previous module to show the claims. When I run the application and log in, there are three claims. The first is of type nameidentifier. This claim type looks like a URL, but it isn't. Everything in front of the word nameidentifier is the namespace of this claim. Nameidentifier is a standardized claim. That's why it has this official looking long name. The value of nameidentifier is a unique string identifying the user that is logged in. In this case, it is the primary key of the user in the database. The name claim represents the user's name, and it is also a standard claim. In this case, it's the email address of the user, but it doesn't have to be. SecurityStamp isn't part of the standard claims. It is specific for ASP.NET Core Identity, and its value is stored in the User table. This is a random value that changes whenever a user's credentials change or the account is locked. When the user logs in, the Identity cookie is set with the SecurityStamp claim. Now let's say the account is locked by an administrator, the SecurityStamp on the server will change. As soon as a user makes a new request, the SecurityStamp in the existing cookie doesn't match the one on the server, and Identity will deny the existing cookie automatically. Finally, the amr claim specifies the login method. Amr stands for authentication method reference. Wait a minute. What about the CareerStarted and FullName properties we added to the user? We don't see these as claims. That's because Identity doesn't know it has to add these as claims. We have to do socalled claims transformation to make that happen. First, let's make sure there are values for the two claims in the database by directly adding the values to the table. I'm adding a class called ApplicationUserClaimsPrincipalFactory, which derives from UserClaimsPrincipalFactory of ApplicationUser. UserClaimsPrincipalFactory is used by Identity internally when signing is called on the UserManager. Its function is to add claims to the claims principle. It only adds the claims you saw, so we are creating our own version deriving from the original one. In the constructor, I have to capture a UserManager object and an object containing the settings for Identity. Both were registered in the dependency injection container when we added Identity. I'm passing these on to the base constructor. Now we can override GenerateClaimsAsync, which gives me the user object. In the method, I'm getting the current ClaimsIdentity with a base call. This base call adds the standard Identity claims. And then I can add any claim I want to the ClaimsIdentity. So in this case, I'm adding a FullName and a CareerStarted claim. They both get their values from the user object. After that, I'm returning the modified identity object. The last step is to register the new class in a dependency injection container. With this call, we're overriding the registration that is done internally by AddDefaultIdentity. When I now run the application, the new claims are displayed. ClaimsPrincipalFactory is used within the Identity framework only. An alternative way to do this is to create a class that implements IClaimsTransformation and register that in a dependency injection container. You can then implement TransformAsync. The advantage of this is that this method also works outside the Identity framework. The disadvantage is that using IClaimsTransformation requires a bit more work. We just get the ClaimsPrincipal, and we have to figure out which ClaimsIdentity we want to add claims to and get the user entity object with an extra call to UserManagerGetUser. The greeting part of the view is still not very personal, showing the email address of the user instead of the user's name. The greeting is in the shared view LoginPartial. The user property used here is the ClaimsPrincipal. To get to the FullName claim. I'm declaring a variable, the value of which is the FullName claim if the user is authenticated. I can just access the claims property to do it. Then I replace the greeting with the value from that claim. There's yet another way to add claims, which are automatically picked up by Identity. Let's directly manipulate the database to add a Birthdate claim for the user. Here's my user's record in the AspNetUsers table. I'm copying the ID to the clipboard. Then in the AspNetUsers claims table, I add the Birthdate claim. I'm kind of reluctant to use my real birth date here to be honest. When I now run the application, the claim is there. If you don't see it, try logging out and in again. Adding claims directly to the database like this is all fine and well. But, ideally, we want to ask the values for these claims in the registration page and then add them programmatically. To do that, we first add an input field for FullName, binding it to a property on Input that does not exist yet. I'm doing the same for CareerStarted and BirthDate. Now I quickly add the new properties to the Input class. In the OnPostAsync method, we have to store the new values. FullName and CareerStarted are in the ApplicationUser entity. I can just add them to the property list when ApplicationUser gets created. BirthDate isn't in the entity. I added the claim in the AspNetUser claims table manually a minute ago. To do that in code, you can use the userManager again. When the creation of the user was successful, call addClaimAsync specifying the user and the new instance of the Claim class that takes the claim type and the value as constructor parameters. When I now test the application and go to the registration page, create a new user and log in with it, the claims are displayed. We're looking at the role subsystem next.

Enabling Roles
An important thing to realize when we configure identity in the startup class with a call to add default identity is that role support isn't on. By default, identity only uses direct claim. Now, this can get confusing. Isn't a role a claim? Yes, it is. The difference lies in where the claim and associated claims come from. On this slide, the orange box represents our application user entity that gets its data from the ASP.NET users table. There are a couple of claims in it, including UserName and CareerStarted. In addition to that, we already saw the ASP.NET UserClaims table in action in which additional claims can be added for a user. All claims we used thus far are defined directly on the level of the user. The claim role comes from an indirect source. When a user is in a role, the role claim gets automatically added to the claims list. role claims can be associated with roles. In this example, both the organizer and speaker roles have a permission claim associated with them. You can, of course, also add multiple role claims for the same role if you want. For the user in our example, which both has the organizer and the speaker role, the resulting claims list could look like this: UserName and CareerStarted come from the user entity, birth date and bank accounts from the user claims table. The role claims come from ASP.NET user roles that associate users with roles. And the RoleClaims permission is added twice, because the user is in both roles. Role claims are in the APS.NET RoleClaims table. As you can see, it's fine to have multiple claims of the same type. Since roles are off by default, the role manager class, which is available to manage the roles, isn't available, and the claim role and its role claims will be ignored. Now let's do _____ roles. The easiest way to do that is to not use a default identity. Instead, use AddIdentity, specifying the user and role types, and generic parameters. If you want, you can create your own type that represents the role, just like we did with the user, but I'm using a default identity role type for now. A call to AddIdentity doesn't add support for identities UI so we have to add a separate call to enable that. Also, token providers, a topic I'm covering later, are not registered. To enable that we need to call to AddDefaultTokenProviders, but there's another thing that must change. Our current UserClaimsPrincipalFactory doesn't support roles. To fix that, use another version of UserClaimsPrincipalFactory to inherit from. The one with role support takes another generic parameter with a role type. The constructor now takes an extra parameter for the role manager, which we have to pass on to the base class. Now let's add the role organizer to the database in the table AspNetRoles and associate the user with it in the Asp.NetUserRoles table. In the AspNetRoleClaims table, I'm adding the claim permission that is added to all users that are a member of the specified role, in this case, our new organizer role. Let's run the application again. There's now a role claim with a value organizer and the permission claim is added as well. Adding a user to an existing role in code is possible with a user manager. Here we are back in the on post of the register page. Call AddToRoleAsync on the UserManager object, specifying the user and the role name. With roles enabled, we can also inject a role manager object. With it we can, for example, check if certain roles exist, create new ones, and add claims to a role. We're fixing the fact that the application can't send emails in the next clip.

Utilizing Tokens and Adding Email Support
Identity uses email for two parts of its functionality. One is to confirm an email address when an account is created. The other is when users forget their password. When you don't implement email functionality, Identity will, by default, revert to clicking links on the website itself, which is not safe. So implementing this is very important, but luckily quite straightforward. We're adding another class called EmailSender that implements the IEmailSender interface that is included with Identity. We already saw EmailSender in action when we examined the code for the registration page. We have to implement one method, SendEmailAsync, which gets the email address the email has to be sent to, the subject of the email, and the email body. Let's call that last parameter simply message. I'm making this method async. Now you can implement this any way you want. I like to use the SendGrid cloud service that offers an API to send emails with. On SendGrid.com, you can find more information and create a free account. It's also available through Azure. Once you have the account, you can generate an API key. There's a NuGet package called SendGrid, which makes working with SendGrid very easy. I've already installed this. I also added the API key to the application secrets, and I have a fromName and fromEmail setting in appsettings.json that SendGrid will use as the sender information. In the constructor of the EmailSender class, we can now ask for IConfiguration and set three private fields that contain the settings we need. Here's the implementation of SendEmailAsync. I'm constructing a SendGridClient object with the API key. SendGridClient is included in the SendGrid NuGet package. SendGridMessage too, which is used to construct the email. Calling AddTo on the message adds a recipient. We then turn click tracking off. This is only used if you use SendGrid for marketing campaigns. Finally, we're sending the message. Now we have to register the new class in the dependency injection container, and we're good to go. When I now register a new user really quickly filling out all the fields, the message on the next page has changed. When I now open my mailbox, there's an email with a link. The link navigates to account/confirm email when I click it. It has a user ID and the code in the query string. Let's take another look at the code that sends the email in the registration page. With the GenerateEmailConfirmationTokenAsync call on userManager, a token is generated. This call needs the default token providers in a dependency injection container. That's why we added the call to add default token providers earlier. The token is stored in a database upon creation. The userManager has all kinds of methods to generate tokens for a wide variety of functionality. When a token is created, the link is constructed, which the user has to click in the email. It contains the token in the query string parameter code. To see what's going on when a user clicks the link, I've scaffolded the confirm email page out. We can see a call to userManager, ConfirmEmailAsync, which gets the user and the code. This call will verify that the code supplied was issued for that user and that it is still valid. When everything checks out, it will set the email confirmed bit for the user to true in the database. Tokens have a lifetime. That lifetime is configurable with a default of one day. If you feel like it, you could also do some exploration on your own to see how the reset password functionality works. It is very similar, and it uses the exact same EmailSender. In the next clip, we're enabling two factor authentication.

Two-factor Authentication
It turns out that two‑factor authentication, also known as 2FA, already works out of the box. When we log into the app and go to the account management page, we can select the Two‑factor authentication tab. By default, Identity offers support for 2FA using an authenticator app. It asks the user to enter a code manually. That's not very user friendly, but we can also support a QR code with a few extra steps. Download qrcode.js on this URL and copy the JavaScript file manually to a location in www.root. I've created a lib folder. I'm using the minified version here. Then scaffold out the two‑factor authentication page we just saw. Go back to Add, New Scaffolded Item, and then Identity. Now select the page EnableAuthenticator. In the drop‑down, select a data context, and let the scaffolder do its work. Open the markup of the page, and scroll all the way down. In the Scripts section of the partial view, add a script reference to the qrcode JavaScript file. And then in a separate script tag, enter this code. It news up a QRCode object that is going to render itself in the HTML element with the ID qrCode. It's a div in the HTML. The text the JavaScript library should transform into a QR code is already in the model of the page, so we can just use that. Now delete the line that links to the instructions to add a QR code. The div I mentioned earlier is there as well. Finally, switch to the code of the page and look for the method GenerateQrCodeUri. The second parameter of string.Format is the name of the application the user will see in the authenticator app. It's the name of the Visual Studio project. You might want to change that if necessary. When we now run and go to the page again, there's a nice QR code the user can scan with the authenticator app to add this website. I'm doing it right now. After I enter the verification code I get from the app, I get some recovery codes. When I lose my phone, I can use the codes to regain access. When I now log out and log in after entering my username and password, the app asks for the code from the app. Let's open the management page again. It now gives us options to manage the configured two‑factor authentication, using this existing code as a template and by using the methods on User Manager to create various verification codes, adding more 2FA methods like sending text messages to a phone with a service like Trilio wouldn't take too much time. Next, I'm talking about external identity providers.

External Identity Providers
I already explained the gist of external identity providers in the previous module. This clip is only about the identity specifics. Maybe you've already noticed this section on the login page. The login page seems to already support external identity providers. The only thing we have to do is to add one in the IdentityHostingStartup class. We already have a call to AddIdentity, which internally calls AddAuthentication. But because we want to use an extension method on the object that is returned by that call, we do it again and use the same code to add a Google scheme, as I showed you before. Remember, you need a Microsoft ASP.NET Authentication Google NuGet package for this. I've put the ClientSecret in the application secrets. To get to the configuration object in IdentityHostingStartup, access context.Configuration. There's no need to configure a separate cookie container for the Google scheme. Identity will take care of that. Now run again. On the login page, now a Google button appears. When I press it, I don't see a Google login screen because I'm already authenticated with Google. We then see a screen that tries to auto‑register the now‑logged‑in Google user. It has already extracted the email claim. When I press Register, Identity sees that there's already a user with this email address. Luckily, there's also a feature that lets the user associate an existing account. I'm logging in using the local username and password. Enter the 2FA code and go to the manage page again. There's a tab External logins with a Google button. When I press that, I've associated the local account with the Google account. There's a table ASP.NET User Logins in a database where the association is persisted. When I now log out and in again with Google, it works. The part in the markup of the login page, where the external identity providers are listed uses an ExternalLogins property on the model. It's a collection of authentication scheme objects. Submit buttons are rendered for each of the external logins with the scheme name as the value, and the friendly name is put on the button. The button submits to a page called ExternalLogin. I've scaffolded out the ExternalLogin page just out of curiosity. The OnPost method returns a ChallengeResult with a provider, which is the scheme name which is passed in. The necessary properties are created by the signInManager. There's a callback method too. It's basically the same code as we wrote in the previous module for the callback. The only difference is that helper methods are used on signInManager to do the heavy lifting. It gets all the passed‑in properties in a nice object, and then it is used again to log in using the external identity provider. The name of the provider comes from the passed‑in properties, so this callback method is suitable for all identity providers, not just Google. Is Identity suitable to do authentication from multiple applications? You will get an answer next.

Using Identity beyond One Application
Okay, so identity is about local authentication, meaning authentication for just one website. What if we don't have a single application, but more like an application landscape, maybe with multiple APIs that are called by the web application and maybe call each other. You want to protect the APIs against unauthorized access. One solution could be to place these APIs on a part of the network, either physical or virtual in the cloud, that can only be reached by the web application, not from the public Internet, but even when they're not publicly available, you might want to add an extra layer of security. And what if the APIs also need to know who the users are and get their claims? Then identity doesn't suffice. Identity is built around cookie authentication, and cookies are typically meant for one URL. If you Google on the topic, you'll find ways to get around that, and you could invent your own authentication mechanism, but I strongly advise against both, because it's virtually impossible to factor in all tricks attackers have up their sleeves. The way to do it is to use a proven mechanism, something that is trusted by the industry and was carefully crafted using a committee of security experts. It is available in the form of the OpenID Connect standard. In the next module, you learn all the ins and outs of that.

Summary
Showing you every detail of Identity would make this a very long and tedious course. This module is designed to give you a feel of how Identity sticks together and how it can be customized. We saw that Identity is a claims‑centered framework to add local authentication to your application. There is support for third‑party identity providers that associates the external identity provider's account with a local account in Identity. Identity is highly customizable, not only the UI, but also almost all helper classes. It comes with sensible configuration defaults, which you can easily override by using the options object in the Startup class or in Identity HostingStartup. See you in the next module.

Applying an OpenIdConnect Identity Provider
Introduction
At the end of this module, you will understand how centralized authentication, also known as federated authentication, with identity providers works. You'll know that a job of identity providers is to provide clients, which are applications, with tokens, which contain the identity of the user or provide access to APIs. Flows are ways to get tokens. You will know exactly which flow to use when. Here's something that's really cool about this module. I'll show you how to build your own identity provider, giving you a thorough understanding of OpenID Connect. And finally, I'll talk about cloud identity providers in case you don't want to build your own.

Authenticating with an Identity Provider
When your application architecture has similarities to this picture, using the ASP.NET Core Identity framework is not enough, as I explained in the closing of the previous module. An identity provider is a special kind of API that is added to the application landscape. It facilitates a centralized way to authenticate that works across all of the different parts of the application. It is centralized because authentication doesn't take place at the application used by the user, but at the identity provider. At the same time, there is only one identity provider for all applications in an organization. You don't need one for every single application. And that brings another benefit to the table. When users use different web applications that all trust the same token service, they have to log in only once in order to use all of these applications. This effect is known as SSO, or single sign‑on. You've probably seen that in action when using Microsoft or Google web applications. When you access the email app, you log in. But when you then go to the calendar app, for example, you don't have to log in again. In a new incarnation of the ConfArch app, the web application does HTTP requests to a RESTful API to get and post the conferences and the proposals. Authentication for the web app is not done by the app itself, but by a separate application called the identity provider, and the API is protected against unauthorized access, while at the same time, the API can access user claims. This module focuses on how this all works. But first, I'm showing you the finished running solution. There are three applications running; the web application, which has now all control as protected by the Authorize attribute, the API, and the identity provider. The web application is running on localhost port 5001. But when I enter this URL in the browser, I'm redirected to localhost 5000 to log in. That's where the identity provider lives. The login screen looks exactly like the login screen we saw in the previous module. That's because it is using the Identity Framework. I enter the credentials, and now we get to a screen we didn't see before. It's called the consent screen. The identity provider asks if it's okay if it discloses personal information to the application ConfArch, which is the web application. The personal data includes my user identifier; in other words, my subject ID claim, my user profile, which has claims like first and last name, and a special profile called ConfArch with the claim's full name, careerstarted, rolle, and permission. It also asks if it's okay if the ConfArch web application accesses an API called ConfArch API. That seems odd at first glance, but this is because the API will get the subject ID claim and it might get some other claims, too. When I allow all of this, I'm at localhost 5001 again, and I'm logged in because we see a bunch of claims. Apart from some extra ones, we see the claims we've worked with in the previous module. As before, I access the identity managed overview page, but it's not on the web application anymore, but on the identity provider URL. In the next clip, we're taking a look at the terminology of an identity provider.

Understanding Identity Provider Concepts
Now, how does this all work conceptually? Let's return to the analogy we used in the previous module, but it's now time for the enhanced edition. We're back in the hotel with the reservation. Like I explained earlier, they will ask for an ID. Let's assume that it is a passport to check the claims that are on it. But there's more to it. Everybody can fabricate a document with some claims. That's why the passport is issued by an authority, an organization that keeps your personal information safe. The passport is only issued by the authority with your permission. The authority might be the government of the country you're living in. The hotel knows that the passport is issued by the authority because the document says so. To prevent others from fabricating a similar document or copying the document, the document also has certain characteristics. It could be a stamp or a hologram mark or a certain kind of paper. But that is not enough for the hotel to know for sure that you are who you say you are. There also has to be a trust relationship between the hotel and the authority. The hotel has to trust that the personal information on file at the government, and thus the claims in the document, are the truth. This trust relationship is the reason the hotel doesn't accept your golf club membership card as an ID document. There's also a trust relationship between you and the issuer of the document because you trust the issuing organization to keep your information safe. Now, we're taking this analogy to the world of applications, applications protected by an identity provider. In our analogy, the hotel was the party that needed authentication. In the application world, an application needs authentication. An application that needs an authentication mechanism is called a client, so our confarch web application is a client. For now, we'll assume that every client has users. Just like the hotel had a trust relationship with the issuing organization of the passport, the client has a trust relationship with a special kind of API application that is called the identity provider. And just as you, the guest of the hotel, had that same trust relationship, the user of a client has it too. The issuer of your passport keeps all your information safe. Same thing for the identity provider. The identity provider protects personal data in the form of claims and a second type of resource, access to an API on behalf of you. And, of course, to make sure eavesdroppers have no chance, all identity provider interaction is done with HTTPS. That's great, but somehow this information has to be conveyed to the client. We need something like the passport was for the hotel, something that can show the client claims, while at the same time the client knows for sure it can trust these claims to be true. That is what a token is. In the previous module, we also talked about tokens that were generated to verify an email address, etc., but we're talking about a different kind of token here, tokens that are issued by the identity provider, but only with your permission and not before certain cryptographic characteristics are added to them, the digital version of the anti‑forgery measures of the passport. The token is then sent to the client, which verifies the token using these characteristics. It makes sure the token came from the identity provider it trusts, and it checks if a token wasn't tampered with along the way. There are two types of tokens corresponding to the two types of resources the identity provider protects. The identity token contains the personal data of the user, in other words, the claims. Whenever the client does a request to an API, it has to send along the access token. It serves two purposes. One is that it acts like a key that gains access to the API, and the other one is that it also contains one or more claims of the user so the API can know which user is accessing it. You don't need an access token for each API. There's one for all APIs the client has to access. The two tokens, as well as the way they are obtained from the identity provider, are described in standards. The older OAuth2 is a standard that describes access tokens. OAuth2 is part of OpenID Connect, but OpenID Connect as identity token support. The advantage of having these standards is that all identity providers can be used in the same way, no matter which platform they're running on. There are several ways with which the tokens can end up at the client. These ways are called flows. I'm going to talk about these in a minute, but first we'll take a look at the client authentication process.

Delegating Client Authentication
In the demo I showed you, I was redirected from localhost on port 5001 to localhost on port 5000 as soon as the web application, the client, saw that I was not authenticated. It redirected to the authorization endpoint on the identity provider. This is just one endpoint described in the OpenID Connect standard. We'll get to some of the others later. This endpoint needs information from the client. This information is sent to the identity provider as part of the redirect, most of the time in a query string. First of all, the authorization endpoint has to know which client is doing the authentication request. The client sends the client ID along, together with, depending on the type of client, a client secret. The identity provider then checks if such a client is known, and when a secret is supplied, it checks if that is correct. An alternative way to authenticate clients is to use certificates. Secondly, the identity provider has to know what the client wants, which claims, and access to which APIs. A scope can either be a collection of claims, or it can represent access to one API. The identity provider, of course, will check if the client has access to these scopes. ResponseType is what the client wants from the authorization endpoint. Maybe you're thinking now, that's easy, Roland, tokens, of course. Sounds logical, but it depends on the flow. The client can't request just any response type. Response types are also restricted by the client configuration on the OpenID Connect identity provider. The identity provider also wants to know where the client wants the things it requested from the authorization endpoint delivered. I'm calling the things it requested artifacts. The location is a URL on the client the identity provider will redirect to. This can't be any URL, just URLs the identity provider knows about. Only if all provided information checks out, the login screen and consent screen are shown, after which the artifacts requested are delivered to the client by redirecting to the specified redirect URL. Let's take a look at the ConfArch.Web application now. I again started out with the application without any authentication, so no cookies and no identity framework. I then gave all controllers the Authorize attribute and ConfigureServices of the Startup class, and I added a call to AddAuthentication, and I added user authentication in the configure method too. We still need cookie authentication because we need the identity cookie. But I also added a scheme for OpenID Connect. This configures the Microsoft OpenID Connect middleware that can be used with any identity provider that implements the OpenID Connect standard. I set the DefaultScheme to the cookie scheme and a challenge scheme to the OpenID Connect one. Now let's take a look at the configuration of AddOpenIdConnect. First of all, the Authority. This is the URL of the identity provider. We're telling the web application to trust the identity provider on this URL. Then we see the ClientId and ClientSecret. To make this easier to read, I'm putting the secret in source code, but don't do this in production. Use application secrets like I showed you. Next, the scopes. I'm requesting the confarch scope, which is a claim scope and the confarch_api scope, which is an API scope. The scope openid instructs the identity provider to send the identity token with the user subject id claim, and profile includes the user's standard personal info claims in the identity token. But we don't see these because they are automatically added by the middleware. SaveTokens means that the access token must be saved in the HTTP context. We need that because the application will need it later to access the API. To keep the identity cookie as small as possible, by default, the identity token will not contain all claims. When GetClaimsFromUserInfoEndpoint is enabled, an extra request to the user info endpoint on the identity provider will be done to get the rest. After that, we see calls to MapUniqueJsonKey on the ClaimsActions object. These are mappings between claims that are received in the token and from the user endpoint to the claims we want to use in this application. Standard claims like claims in the OpenID and profile scopes are mapped automatically, but we have to do the mapping for the custom claims ourselves. The first parameter is the name of the claim type we want in this application, the second as it is in the data that comes from the identity provider. Even though I want to use the same names in this case, I still have to do the mapping. Yep, I know; I don't like it either. Next is ResponseType I talked about. We're requesting a code from the authorization endpoint here. This enables authorization. code flow. Let's look at that next.

Choosing an OpenIdConnect Flow
The entire process I just described is done with a browser. Think about it. When the client discovers that a user isn't authenticated, it initiates a redirect. The redirect is executed by the browser, and the information sent along is contained in the query string. Then the login and consent screen will be sent to the browser, and then the identity provider uses the redirect URI to redirect the browser again with the artifacts in the query string by default. Maybe you've noticed that I use ResponseMode as form_post in the client configuration. With this setting, the artifacts are sent in the request body instead of using a query string, which is safer because request payload is protected with TLS. Query strings are not. Anyways, back to my point. All interaction with the authorization endpoint is done with the browser. This is called the front channel. The browser is considered unsafe. Everything you send to the browser is readable and can be extracted, manipulated, and potentially exploited. That's why authorization code flow was invented. Using that flow, tokens aren't sent in the redirect back to the client from the authorization endpoint. Instead, a code is sent. The code can then be used by the client to do a back channel request. That's a request done at the client level the browser doesn't know about. In this request, the code is exchanged for an access token at a token endpoint. When the client does the request to the token endpoint, it has to present its client ID and secret. If the OpenID scope is among the requested scopes, the token endpoint also sends the identity token in the response. That's great, but there's a problem. Under certain conditions, attackers could intercept the code and use it to get the tokens at the token endpoint. It's called a code substitution attack. You can read up on the details on this URL. That's why PKCE, and add‑on to the existing authorization code flow, was invented. It is pronounced pixie. Every time the client does a redirect to the authorization endpoint, it generates a secret. When the identity provider hands out the code, it remembers that this secret belongs to the issued code. It's can either be cryptographically merged with a code, or the identity provider can store the association in a data store. Now, when the code gets exchanged at the token endpoint, the identity provider checks if secret and code still match. Should attackers get the code, it would be very difficult for them to also obtain the secret needed to exchange the code for tokens. Now I know that this is an ASP.NET Core course, but what if we have an application without a server part, a single‑page application using Angular or React, for example? Then the tokens are still fetched using the back channel, but the tokens will be exposed since the application only runs in the browser. So the browser will have the tokens. In this, guys, we have no choice. With PKCE, however, it still is safer than any other available flow. A single‑page application is a so‑called public client. It can't keep a secret as opposed to a confidential client, a client that can keep a secret. Because a single‑page application is a public client, the client secret that has to be presented at the token endpoint is not a real secret, so it's pointless to use it. Therefore, for single‑page application clients, we turn off the requirement for clients to present a secret in the identity provider configuration. Mobile applications and desktop applications are also considered public clients because they run on the user's device, and they also do the back channel request themselves. What about the other flows? There are the implicit and hybrid flow, also designed for interactive clients. Interactive clients are clients with a user involved. I'm not explaining these flows in this course because authorization code flow with PKCE is now recommended for all interactive clients. Implicit flow is not safe enough, and hybrid is too complicated now that we have authorization code with PKCE, unless PKCE is not available, of course, which is not the case for an ASP.NET Core application because in the OpenID Connect middleware I can just turn PKCE on. Of course, the identity provider has to support it too. Should you be interested in implicit and hybrid flow, this web page has a good overview of them and also lists the response types associated with them. Sometimes a client isn't interactive. For example, when an API from a customer wants to call our API. In that case, we use client credentials flow. It's for confidential clients. There's no problem with an unsafe browser or application because it only runs in the server. With client credentials flow, the client can just send the client credentials to the token endpoint and get the token. Singular token because it's always just an access token without claims. Since there's no user involved, there's no identity token. So that makes the flow chart to choose a flow pretty straightforward. The only question is, is the client an interactive client? If not, use client credentials. If it is, use authorization code with PKCE. Next, we're exploring how an identity provider sticks together code‑wise.

Exploring an Identity Provider Implementing IdentityServer
In the solution of the ConfArch app, I've created my own identity provider using a framework called Identity server. Now, is it a requirement to create your own identity provider? No, you could just use one in the cloud, like Azure Active Directory, Auth0, or Okta, or maybe an Active Directory on‑premises. I've chosen to build one myself for this course, because I think I can explain the workings of an identity provider way better by showing you the internals. I'll talk more about cloud‑based identity providers at the end of this module. Because the ConfArch web application relies on the identity provider to do authentication, it doesn't need the Identity framework anymore. Whenever I refer to Identity framework from now on, I mean the ASP.NET Core Identity framework I explained in the previous module. I've moved the complete Identity framework setup we did in the previous module to a new a ASP.NET Core application called ConfArch.IdentityProvider. This was the app that ran on localhost port 5000 when I ran the demo. This project now has the identity area with a scaffold of pages; the DbContext, the UserClaimsPrincipalFactory, and the email sender. It also has the IdentityHostingStartup file. Apart from all the Razor pages, the Identity framework provides for its functionality, there are also a couple of controllers with additional functionality. Identity server redirects to the consent controller to display the consent screen, and we will see the grants and home controller in action later on. The startup class of the project now has some extra code lines. In ConfigureServices, I now have a call to add IdentityServer. IdentityServer is an open‑source framework that can turn any ASP.NET Core application into an OpenID Connect identity provider, adding the necessary endpoints, supporting the flows I talked about in the previous clip. It is not part of ASP.NET Core so I have to install a NuGet package called Identity Server 4. I came up with the code for this identity provider by looking at templates that are available at this URL. In the configure method of the startup class, the OpenID Connect endpoints like the authorization and token endpoints are added by calling UseIdentityServer. UseAuthentication seems to be missing here, but that's called internally by UseIdentityServer. Switching back to ConfigureServices, IdentityServer is configured, the two types of resources and the clients. The configuration in this case comes from the AppSettings.json file. If you prefer a database, that's also supported with an extra NuGet package called IdentityServer4.EntityFramework that contains two ready‑to‑go DbContexts: one for the configuration and one is the operational store, which persists things like codes and tokens. By default, this operational store is held in memory. Instructions to set up a database are at this URL. After configuring the resources and clients, we're adding a developer signing credential. This is used to encrypt the tokens. I'll come back to that in the part where I talk more about tokens. The next line is activating ASP.NET identity support. This is the integration with Identity framework. We have to specify the user type as a generic parameter. This extension method is available in a NuGet package called IdentityServer4.AspNetIdentity. The integration is great. The alternative is to write all features Identity framework offers like user and password manager to factor authentication yourself, including the UIs needed by those features. It's great, but also a little bit confusing. Wasn't Identity the framework that did authentication? And now we have Identity Server and the Identity framework in one project. Let me see if I can sort that out for you in the next clip.

Understanding Cookies and Single Sign-on
There's a chance that you might have contracted cookie confusion by now. Let me help out with this overview. We already saw this picture. The browser is redirected to the identity provider when login is required. The identity provider just logs a user in, just like any other ASP.NET Core application. That's why we can just use the Identity Framework here. As normal, after logging, the Identity cookie is set by the Identity Framework, and, as always, this cookie is used to reconstruct the ClaimsPrincipal on subsequent requests. The identity provider, in our case with the help of IdentityServer, takes the identity information in the cookie and constructs an identity token for the client together with an access token, which is created separately. When the client receives the tokens, it verifies them using the cryptographic characteristics on the tokens. The access token is kept for later use. The identity token is used to construct the ClaimsPrincipal, after which it is discarded. The client then sets the Identity cookie as normal. On subsequent requests, the identity provider isn't needed anymore as long as the browser has the cookie. Now let's say the user browses to another client that uses the same identity provider. That client redirects to the same URL, but the browser already has an Identity cookie, so the identity provider skips the login process, reconstructs the ClaimsPrincipal, and provides the tokens, after which the client sets its own Identity cookie in the browser. So, we have single sign‑on for every application that uses the same identity provider. Now let's take a look at the configuration of our identity provider in the next clip.

Configuring an Identity Provider
We're back at our identity provider with Identity Server. In appsettings.jsonunder IdentityResources, all identity scopes are configured. An identity scope is a collection of claims. We already saw the display names and descriptions on the consent screen when I did the demo. The first one is openid with the subject id claim, and then the profile scope defined in the OpenID Connect standard to have the list of claims. In the setup with Identity framework, we don't have all these claims. That's okay. Only the ones actually present will be put in the identity token. Next, a custom scope is defined called confarch, which has the claims we added with the Identity framework. Under APIResources, all APIs have to be defined. Remember, we have just one web application here that uses this identity provider to authenticate, but typically you have more applications that you use the same identity provider, so this lists all APIs that can be potentially available for all applications. The same goes for the identity resources. Each API has one or more scopes that are requested by the client. Now this can get confusing. With an identity resource, the scope the client requests is the name of the resource, for example, profile. The client then gets all claims of that scope. API resources are defined per API where an API has one or more scopes that can be requested by the client. You could have just one scope for general access like we have in the configuration, or multiple scopes that can be used for authorization in the API to unlock certain parts of it, for example. In the confarch_api, we could have a separate scope for the conferences and proposals functionality. Now the client configuration. The client ID Is confarch_web and the friendly name just confarch. We saw that name on the consent screen too. It has a client secret that is hashed. The readable version is in the comment above. Needless to say, hopefully, but don't include this comment in the production code. We grant the authorization code flow for this client, but only with Pkce. This client is allowed to request the listed scopes, which are the identity and API scopes mixed together. Next are the allowed redirect URIs, in this case, one. This is the endpoint on the client where the authorization endpoint redirects to. On the client, the OpenID Connect middleware sets up an endpoint at /signin‑oidc automatically. A post logout redirect URI is a URI that is redirected to when the user logs out at the identity provider and the front general logout URI is rendered in an IFrame by the identity provider when the user logs out there. This endpoint gets rid of a client cookie. Both are used when a single signout is triggered on the identity provider. There is a special endpoint for that called the end session endpoint. There are a multitude of other options you can set here that have to do with a lifetime of tokens, for example. All settings can be found at this URL, but I'm pointing out a couple of them. With the RequireConsent option, you can switch off the consent screen for a client. This is useful when the client is for internal use within an organization only, for example. Another one is AlwaysIncludesUserClaimsInIdToken, that makes sure all claims are always included in the identity token. The token will get bigger, but there is no need to do an extra request to the user info endpoint anymore. So when you have this option enabled, you can get rid of the line of code in the client that enables the request to the user endpoint. RequireClientSecret is true, by default. We'll turn it off for public lines for reasons I talked about earlier. When it's off, you can, of course, delete the line with a ClientSecret. We're protecting and calling the API in the next clip.

Protecting and Calling an API with an Access Token
Here's the Startup class of the API. It has the AddAuthentication UseAuthentication combo we saw a couple of times now. It doesn't need a cookie authentication scheme, just a scheme that can verify an access token. We can support that by adding a NuGet package, Microsoft.AspNetCore.Authentication.JwtBearer. The acronym JWT stands for JSON Web Token. It is pronounced "jot." Once the NuGet package is there, we can call AddJwtBearer to add the scheme that checks the token. We set the default scheme to that scheme in the call to add authentication. In the options we set the Authority, that's the identity provider this API has to trust, and the Audience. Audience is a special claim that is included in the token. Each API the access token is for has its own Audience claim. To check if the token is for this API, it has to know the name it has to look for in the Audience claim. In our case, that is confarch_api. All that's left now is to put the Authorize attribute on all controllers. That's it. The API will now require an access token in the request header on every request. If there's no access token, if it's expired, or the audience is incorrect, the API will return a 401 unauthorized. Now let's take a look at the web application. That has to include the access token in every request to the API now. I've created a class called ConfArch.Api.Service and a corresponding interface. It accepts an HttpClient object as a constructor parameter. HttpClient is the class to use to do HTTP requests to REST APIs. Because of the constructor parameter I can register ConfArchApiService in the ConfigureServices method with a call to add HttpClient, configuring the HttpClient object. I'm using an overload that passes in the IServiceCollection object. That's the same object we use in ConfigureServices to registered types, and the HttpClient object. I then use services to get the IHttpContext accessor from the dependency injection container. I need that because the token is saved in the HttpContext. Don't forget to call AddHttpContextAccessor to make this work. Now we can call GetTokenAsync on the HttpContext, passing in the string access_token to get the access token. The next line sets the token in the authorization header. Finally, I tell the HttpClient on which URL it can find the API it wants to call. Now that the HttpClient is configured, I can use it anywhere in ConfArch.Api.Service to do calls to the API, and the access token will be included. Note that PostAsJsonAsync and ReadContentAs, our extension methods that I created to make the code in ConfArch.Api.Service as brief as possible. The controllers get the API service injected and call the methods. But what if an external application wants to call our API? You will find out in the next clip.

Using Client Credentials Flow
I've added another client to the configuration of our identity provider. Its ID is attendeeposter, and I granted the use of the client_credentials flow. Client_credentials is meant for machine‑to‑machine communication in a situation where there's no user involved. Because of that, I will only get an access token from the identity provider. So in AllowedScopes, we can only specify API scopes, in this case, confarch_api. I've created a separate project called External API Client. Let's imagine that this is some kind of application developed by an outside organization, an organization that sells conference tickets. Each time a ticket is sold, that outside organization wants to do a call to the ConfArch API to let it know a new attendee has been registered. Because client_credentials flow is something that is part of the OAuth2 specification, any platform with a client library supporting OAuth2 can use it. The same goes, of course, for the authorization code flow, which we used previously. I've created a .NET console application, but it could be any kind of application. In a console application, we can't use middleware, so a library to talk to the identity provider would be handy. For a .NET project, IdentityModel is a good NuGet package to use. It's a collection of extension methods on HttpClient. So I first create an HTTP object and then call GetDiscoveryDocumentAsync on it, specifying the URL of the identity provider. This accesses the discovery endpoint on the identity provider. To see what that is, let's run the identity provider project again. It shows front page only when it runs on localhost. There's a home controller that takes care of that. On the front page is a link to the discovery document. Notice the URL. The discovery endpoint is available on all OpenID Connect identity providers on the same relative URL. The json it returns contains all kinds of information about the identity provider. With this information, the OpenID Connect middleware we used previously basically configures itself. IdentityModel makes all information from the discovery endpoint available in an object. When I request an AccessToken from the access token endpoint, the address of the TokenEndpoint is contained in that object. I also specify ClientId and Secret and the scope I want. I first check the response for errors, and if everything is good, I dump the AccessToken to the console and I create another HttpClient, which I configure to set the token in the HTTP header. SetBearerToken is an extension method included in IdentityModel. I then do a Post request to the AttendeeController of the API, putting 1 and Roland in the URL. If everything is fine, I'm writing Attendee posted to the console. The AttendeeController on the API has a Post method that gets ConferenceId and Name from the URL. It instructs the repository to add a new attendee with that data, after which it returns 201, created. Now let's run. Yes, the access token is printed, after which the new at attendee is posted. I'm copying the access token to the clipboard because we're going to inspect it in the next clip.

Protecting Tokens
The token we just saw looks encrypted, but is it? This is the website jwt.io. I'm pasting the access token in the box where says Encoded. On the right side, the payload of the token immediately becomes visible. That's because the token isn't encrypted; it's just base64 encoded. There are several token formats in existence. The one mostly used today is the JWT, the JSON Web Token, and that's why we see JSON on the right side. In the payload, there are several claims, none of which have to do with the user. Nbf means not before. The token can't be processed before this timestamp. The number is the number of seconds after January 1st, 1970. Exp is expiration. After this, a new token must be obtained. Iss is the issuer, which is the URL of the identity provider that issued the token. I talked about audience. Audience indicates for which APIs this access token is meant. Client_id is the ID of the client this token came from. And in the scope array, there are the requested API scopes. Now let's paste in the access token the web application gets. By the way, you can easily see the tokens that are issued by IdentityServer by turning trace logging on in appsettings.json. Don't use this in production, though, because tokens contain privacy sensitive information. This looks slightly different because it has been requested with a different flow, one involving a user. The identity scopes are included and the subject ID claim is there. If you want more claims included in the access token, you can specify them in the configuration of the API resource in the identity provider by using the UserClaims property, like this. I'm now pasting in an identity token that contains the subject ID and all other claims with my personal information. So clients and APIs can just read tokens without the need to do any form of decryption. True, but the client and the API have the responsibility to verify the token first. It has to note two things. One is if the token really came from the trusted authority, the identity provider it trusts. And secondly, if the token wasn't changed en route. That's why the identity provider creates a hash of the token contents and encrypts that with a private key. It attaches the output to the token. It's called the signature of the token. Something that is encrypted with a private key can only be decrypted with a public key. That type of encryption is called asymmetric encryption. When the client receives the token, it verifies it by using the public key to decrypt the signature, getting the hash. If the decryption works, it already knows that the token came from the trusted identity provider. It then hashes the readable contents of the token and compares it to the decrypted hash. If they are the same, it knows for sure the content wasn't tampered with. But where does the client or API get a public key? The answer lies in the discovery document. When I click on the jwks link, the public key is there. And where does IdentityServer get its private key? Well, in the ConfigureServices method, there's a call to AddDeveloperSigningCredential. This generates a file called tempkey.rsa, the contents of which contains the private and public key. This is great for testing purposes, but in production, the private key must not be exposed in a file like this. That's why in production you should not use AddDeveloperSigningCredential, but AddSigningCredential. The overload it is mostly used here is the one that loads up an X.509 certificate, the same kind of certificate that is used for TLS. You could find out the details on this URL. In the next clip, we're looking at refresh and reference tokens.

Adding Refresh and Reference Tokens
Until now, we learned a couple of things about access tokens. They are the key that unlocks the API, and when using a flow with users involved, they at least contain the subject Id claim and optionally more. But access tokens also have a limited lifetime. You can set the lifetime in the client configuration. By default, it is 1 hour. When the hour has elapsed, a new access token must be requested. With a web application, this could work without a need for the user to log in again because the browser still has the identity cookie for the identity provider. But in an environment where there are no cookies in a desktop or mobile app, that would require the user to log in again. We don't want that. That's why refresh tokens exist. This is a separate token sent along with the access token. With it, a new access token can be fetched from the identity provider without the need to reauthenticate. It has to have a longer expiration time than the access token, of course. When the new access token arrives, it is accompanied by a new refresh token. In that way, the cycle can go on forever. But why the fuss? Why not just issue an access token that is valid for 10 years or something? Access tokens are bearer tokens, and once you hand out one, it is irrevocable. The refresh token mechanism forces the client to contact the identity provider where a check can be done if the client and/or user still are allowed access. Because the refresh cycle can go on forever, identity providers should give users the option to stop the cycle, after all, tokens contain personal information. Remember the grants controller in the Identity Server project, its job is to do just that. With a simple button click, the user can revoke access. To enable refresh tokens in a client, set AllowOfflineAccess to true in its configuration on the identity provider and let the client request the offline access scope. The OpenID Connect middleware will automatically take care of getting a new access token once it expires. To check if it works, I'm logging in again. The Offline Access scope is now added to the Concent screen. I still have trace logging in the identity provider turned on. In the log, you can see there are now three tokens being issued after I log in. An alternative to using refresh tokens is to use reference tokens. A reference token is an access token that doesn't contain claims. Instead, the claims for the referenced token are kept on the identity provider. The reference token just contains a unique ID. When the API gets the access token, it must do an extra request to the identity provider using the introspection endpoint to get the claims. It reads the claims from its datastore using the unique ID. At this point, the check if the user or client still has access can be done. So this gets rid of the need for refresh tokens and keeps access tokens really small. The downside is that there are more requests to the identity provider needed, possibly a lot more. Here are the steps to enable reference tokens. First, we turn it on in a client configuration on the identity provider. We can get rid of the AllowOfflineAccess setting now, if you want, but don't forget to also remove offline access from the scope list in the client, and we give the API resource a secret. There it's needed as a credential for the introspection endpoint. Secondly, we have to revisit the Startup class of the API. The problem is that AddJwtBearer scheme from Microsoft doesn't support reference tokens. Luckily, the creators of Identity Server have a solution with the NuGet package, Identity Server for access token validation, that enables us to replace the Microsoft middleware for one that supports reference tokens by calling AddIdentityServerAuthentication. Audience in the options object is named API name here, but it's the same thing. Also, don't forget to change the default scheme. After that, we have to give this API the secret. It's also a good idea to enable caching so that the API caches the response from the introspection endpoint for 10 minutes. In that way, the API doesn't have to do a request to the introspection endpoint every time a request comes in from the same client. You can adjust the lifetime of the cache with another property on the options object. A requirement for the caching is to add some kind of memory cache in the configure services. When I run and look at the logs again, the access token is now much smaller. In the next clip, we're looking at identity providers in the cloud.

Utilizing Cloud Identity Providers
In the other modules of this course, we added support for the Google external Identity provider. Google's identity provider, of course, is also an OpenID Connect identity provider. In fact, the AddGoogle extension method we used calls AddOpenIdConnect internally. Our web application acted as a client for Google's authentication provider, getting the identity token and using the SubjectId claim to look up the user in its local store, issuing its own claims. There's nothing preventing us to do the exact same thing with our identity provider. It can be the client of another identity provider, associate the user, and hand out its own tokens to the client. Because we're using the Identity framework in our identity provider, we can just configure Google's authentication provider as before and we're done. You can, of course, also just rely on the identity of another identity provider. That brings us back to the introductory module where I first integrated Google's identity provider directly using the claims Google provides to sign in the user. The upside of this is that it is less complex. The downside is that you're limited to the features the other identity provider has. There's probably a way to add users and give them claims. But what if I have a local store I want to use to fetch users or if I want claims not only to come directly from the user records, but also from other sources, such as related tables or data stores? Besides the one by Google, there are many other excellent identity providers in the cloud with varying extensibility options. Each could warrant their own course. Just to name a few Azure Active Directory, Auth0, and Okta. I would recommend taking a look at these first and then decide if building your own makes sense. Of course, Azure Active Directory is a first‑class citizen of ASP.Net Core and Visual Studio. Let's create another project and take a look at the other authentication options. With the other option under Individual User Accounts called Connect to an existing user store in the cloud, you can use Azure Active Directory B2C as the identity provider. With B2C, you can configure several policies that each client can then optionally use. When we go to Work or School Accounts, we're also connecting to Azure Active Directory, but this time the non‑B2C variant. By selecting a cloud domain, the template will auto‑configure itself, and at the same time, a client configuration will be added to Azure Active Directory. Let's see what happens if I click OK and create a project. In the Startup class, the AuthorizeFilter is added to all controllers. There's a call to AddAuthentication, and the extension method AddAzureAD is used using Configuration from appsettings.json. Among some extra things, the ClientId and the CallbackPath are here. Let's take a look at the source code of AddAzureAD. There's a call to AddOpenIdConnect and AddCookie. So, basically, nothing new here. All identity providers have their own extension methods in NuGet packages that internally configure the OpenID Connect middleware. Once you understand one, you understand them all.

Summary
Wow, we covered a lot of ground in this module. I'm surprised you're still here. I started out by explaining what OpenID Connect is and all the terminology that comes with it. Then we zoomed into the client authentication process, which involved the client getting tokens via a flow. We focused on the authorization code flow with the PKCE add‑on. I showed you how to build your own identity provider using the excellent IdentityServer, and you now know how to protect APIs with tokens. Client credentials flow is used when there's a client without a user, and refresh and reference tokens are convenient to get around the limited lifetime of an access token. Finally, we briefly looked at other identity providers in the cloud and the advantages and disadvantages that come with them. In the next module, we're applying authorization to applications.

Applying Authorization
Introduction
We've already seen the Authorize attribute in action. We used it to allow access to controllers and actions only when a user is authenticated. In this module, we'll explore the possibilities to do more sophisticated authorization based on claims, roles, resources, and then views. I'll show you how to do this in multiple application types, the ConfArch web application and in the APIs. I will use the ConfArch solution with the identity provider as a basis for the demos.

Authorizing with Policies
Using ASP.NET Core authentication is working with claims. These claims can be used to do authorization. I'm back to the solution with the Identity Server identity provider from a previous module. The ConfArch application as two types of users, conference organizers and speakers. In the Identity Framework, I've configured roles for these, and I gave myself the role Organizer and the associated permission, AddConference. All authorization coming from claims or other sources is done in the client. The identity provider has nothing to do with it because it's only handling authentication. We're going to do some policy‑based authorization in the ConfArch web application, so I'm switching to that. First of all, check if a call to UseAuthorization is present in the Configure method. That enables the authorization middleware. To configure authorization policies, add an AddAuthorization call in ConfigureServices. As a parameter, you supply a lambda with an options object as a parameter. With the options object, you can add a policy. AddPolicy wants two parameters, the name of the policy and a policy itself. In this case, we say that the policy is named IsSpeaker and it requires the claim type Role with a value of Speaker. A policy using RequireRole will, by default, look for a claim where the type is a fancy name Microsoft came up with. To make sure it maps to the claim type role we defined, we have to tell the scheme to use that instead. You can create a policy for every claim you want in this way by using RequireClaim instead of RequireRole. Here's another policy named CanAddConference where I check if the user has the claim Permission with the value AddConference. Note that the value of a claim is not required if you just want to check for the presence of the claim without caring about the value of it. Now that we have these policies in place, we can set the policy name in the Authorize attribute wherever in the application we want the policy to be enforced. The Authorize attribute is an authorization filter. That means that it runs in the pipeline before the actual action it protects is ran. By default, it uses the default configured authentication scheme, but it's also possible to specify a scheme. With Razor Pages or Blazer, you can put the attributes on the methods in Code Behind class. Now maybe you're asking yourself, but the controller already has the Authorize attribute applied in ConfigureServices, does the second one work? The answer is yes. In the Add action, I can just override the existing Authorize attribute by placing another one, in this case with a Policy. AddProposal in the ProposalController is an action I only want speakers to execute, so I place the Authorize attribute on that one as well, this time specifying the speaker policy. So when I now log in with a test user, which has the claim type role with the value Organizer, and then go to the proposals of a conference where a press Add, I get the message Access denied. By default, a call is done to the access denied action on the account controller when that happens. And I've created a simple view for that action. Now, I have secured the controllers, but that has no affect on the user interface. Let's take a look at how to manipulate the UI based on authorization in the next clip.

Checking Policies in Views and Pages
It would be great if we could hide the Add button on the Proposals page for everybody who is not in a Speaker role. To do that, I have to inject the IAuthorizationService object in the view. IAuthorizationService is in the namespace Microsoft.AspNetCore.Authorization. I'm using MVC here, but this will also work in Razor Pages and Blazor. This object was registered in the dependency injection container when I added AddAuthorization to the ConfigureServices method of the Startup class. In a code block, we can now use the AuthorizationService to check the policy, getting back a result object. We have to pass in the ClaimsPrincipal and the name of the policy. And now we can just create an if statement with Razor to check if the check succeeded. When I now run the application and log into my account that has the role Organizer, you can see the button to add a proposal is gone. Please keep in mind that just doing authorization on views like this is never enough. You always also have to take care of authorizing the actions in the controller like I did in the previous clip. We have one open issue in the ConfArch web application. Proposals may only be approved by organizers. Can you work on that to make that happen both on the controller and the view level? In the next clip, I'm talking about requirements and handlers.

Understanding Requirements and Handlers
The two policies we created thus far were simple policies, just checking if claims with certain values were present. But what if we want to do something more complex, something that requires multiple lines of code? Let's say we only want speakers to be able to add a proposal if they have a certain number of years of experience. We can calculate the years of experience using the CareerStarted claim. In a policy, we would then check if the number of experience years is greater than or equal to an integer we specify. Let's see how to do that. First, we need a class that holds one or more configurable values needed for a policy. In the case of the years of experience policy, this is just an integer property, YearsOfExperience. We're going to set this value at the time we configure the policy. Next, we need a class that handles the requirement. In here, the logic around the data and the requirement takes place. In our example, we will check if a number of calculated experience years is greater than or equal to the YearsOfExperience property in the requirement. A handler can either call succeed or fail on a context object, or do nothing. If there's just one handler and succeed is called, obviously the policy will ground access. If it fails or does nothing, the policy will deny access. But there can be multiple handlers for the same requirement. Other handlers have their own logic and can succeed and fail explicitly as well, or do nothing. If none of the handlers explicitly signal success, the policy isn't fulfilled. But if one of them calls fail, the policy denies access no matter what the other handlers do. There could be multiple policies in place with multiple Authorize attributes. Only in rare cases you want to call fail because it stops all other handlers and policies from succeeding. There can be multiple policies in effect by using the Authorize attribute more than once on an action. Note that even when a handler explicitly succeeds or fails, the other handlers are still called. That is because there might be something else going on in the other handlers besides logic to check the requirement. For example, logging. Now why should you have multiple handlers for the same requirement? Well, for example, when employees of a company have a batch number used to gain access to resources, you will have a handler for that. But when non‑employees want access, they don't have a badge number, but maybe they are given a temporary visitor sticker with a number that limits access to certain resources only. In the next clip, let's see how to implement requirements and handlers.

Implementing Requirements and Handlers
I've created an Authorization folder in the web project with a requirement class for the YearsOfExperience policy and the handler. The Requirement class implement IAuthorizationRequirement, which is just a marker interface. That means it doesn't require you to implement anything in your class, there's just a YearsOfExperience property and there's a constructor that fills the property. The YearsOfExperienceAuthorizationHandler class derives from AuthorizationHandler, which generic type is a requirement it must handle. It has an overridden HandleRequirementAsync method, which has the context and the requirement instance as parameters. The context has access to the user, which is the ClaimsPrincipal. First, I check if the CareerStarted claim is present. Note that I also check the issuer of the claim here. It's to be on the safe side. Another authentication scheme could have provided a claim with exactly the same name. If the claim is not present, this handler can't do its thing, so I just return, leaving the authorization to possible other handlers and policies. Then, I get the value of the claim, calculate the years of experience, and compare it to the value of the requirement. I call Succeed if the user meets the minimum number of years of experience. Now we have to register the handler with the dependency injection container so that ASP.NET Core knows that the handler for this requirement exists. What's left is to define the actual policy by calling AddRequirements on the policy object, newing up the requirement and filling it with the needed data, in this case just a value for the minimum YearsOfExperience property. So a value of 30 means a user should have at least 30 years of experience. That's a lot. For now, I just add the policy to the Add action in the ProposalController. I've configured my test account to have the role Speaker now, and it has January 1, 2000 as the value for the CareerStarted claim, so that's less than 30 years. You can see I get the Access denied notice again when I press the button. Taking a look at resource‑based authorization next.

Applying Resource-based Policies
We're going to create an authorization policy that checks whether or not a proposal may be edited in the AddedProposal action on the ProposalController. When the approved property of the proposal is true, we can't add it. When it is false, we can. This policy is different than the YearsOfExperience policy since it will require inspection of the proposal model object to see if the approved property is true or not. I've created an empty proposal added requirement class. The handler is more interesting. Just like before, it derives from AuthorizationHandler, but now I'm using the second generic parameter to tell the handler it should do authorization on the ProposalModel instance. Now in the HandleRequirementAsync method, I get an instance of ProposalModel called resource. The handler remains neutral if the resource is approved. If not, it succeeds. With these two classes in place, we can create a policy called CanEditProposal, like we did before, using the requirement. Putting the policy in an Authorize attribute above an action in the controller won't work in this case since the ProposalModel instance only exists in the action. That's also why we don't need to register the handler. Instead, we inject the IAuthorizationService in the ProposalController. This is the object we saw in action earlier when we did authorization in views. On that object, we can call AuthorizeAsync and we can pass it the user, the proposal model instance, and the name of the policy. It returns the same result object we saw before. Only if the policy succeeded, we return the view. Else, we redirect to the AccessDenied action in the AccountController. So what's the benefit here? I could have just checked the approved property directly in the action. Defining a policy is more powerful. Its definition is centralized, and it can be reused across an application and even across multiple applications without reimplementing the logic time and time again. Also, complex authorization checks are possible using multiple requirements and handlers. And, you can write authorization handlers for any kind of object. If you're using Entity Framework, for example, you could write an authorization handler, checking certain properties of the entity before it gets modified. Let's do some authorization in the API, next.

Authorization in APIs
I would like to only allow the call to POST in the AttendeeController of the ConfArch API if it is specifically allowed. Since this action is called by clients using Client Credentials flow where there's no user, the right way to do this is to add an extra scope for the API. In the configuration of the identity provider, in the part where I configure the API resources, I've created an extra scope for our existing API. In the Startup class of the ConfArch API, we can now also call AddAuthorization in ConfigureServices and add a new policy called PostAttendee. It requires a claim of the type scope, and the value is the name of our new scope. So scopes that are in the access token are conveniently added to the list of claims. We already saw that when we inspected the access token. Of course, I can now just decorate the POST action in the AttendeeController with the Authorize attribute, specifying the policy. As you might remember, a separate console application makes a call to this action. Since that client doesn't request a new scope, it just gets an HTTP status code forbidden back now. There are two things that have to be done to make this work. You might even be able to figure these things out for yourself now. First, in the client configuration of the identity provider, we have to add the new scopes to the scopes this client is allowed to access. Secondly, the client itself must now request it in addition to the scope we already had. When we now run, it works again. Is authorization with claims present in the token always a good idea? I'll address this question in the next clip.

Exploring Alternative Authorization Data Sources
The identity token is meant for identity data. Earlier in the course, I compared it to the ID you show when checking into a hotel. But an ID doesn't contain authorization data, like can enter room 24, or may access the gym. This kind of information should be kept out of the identity token. Roles are okay, but if you need more data than the things that are applicable to all clients, you should think about another data source for authorization data. There should be no claims specific for one client in a token, just generic claims. Besides that, putting too much stuff in the identity token could cause problems. Besides to add event with, identity tokens could be passed in a URL, which has its limits. If you need authorization data that is not generic, my suggestion is to create a separate authorization API where the client or API gets the data from. This also has some added benefits, like the ability to use a more complex data structure than just key value pairs, and the ability to change authorizations effective immediately, which is difficult once claims are in the Identity cookie. The architecture to use could look like this. The client or API, but let's say it's a client, authenticates with the token service as normal and requests the scope for the authorization API resource, The access token comes back with a requested scope. The client gets the authorizations from the authorization service, sending the access token, but also a client name so that the authorization API knows the security context and will only hand out the authorizations relevant for this client. In the client, we then have a policy using a requirement/handler combo, which now not inspects the claims in the identity token, but the data that was fetched from the authorization API. I would recommend to cache this data for a limited time. By the way, requirements support dependency injection, so you could just inject your own object that contains the authorization data.

Summary
You've learned that creating and applying centralized policies is the way to go in ASP.NET Core authorization. They are usable in both web applications and the APIs doing authorization on controllers and views. You can also protect resources, which are objects with policies. And finally, think about where you get the data used to do authorization on. Thanks for watching this course. See you next time.